/*!
  * Bootstrap v4.3.1 (https://getbootstrap.com/)
  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('jquery')) :
	typeof define === 'function' && define.amd ? define(['exports', 'jquery'], factory) :
	(global = global || self, factory(global.bootstrap = {}, global.jQuery));
  }(this, function (exports, $) { 'use strict';

	$ = $ && $.hasOwnProperty('default') ? $['default'] : $;

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
		Object.defineProperty(obj, key, {
		  value: value,
		  enumerable: true,
		  configurable: true,
		  writable: true
		});
	  } else {
		obj[key] = value;
	  }

	  return obj;
	}

	function _objectSpread(target) {
	  for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? arguments[i] : {};
		var ownKeys = Object.keys(source);

		if (typeof Object.getOwnPropertySymbols === 'function') {
		  ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
			return Object.getOwnPropertyDescriptor(source, sym).enumerable;
		  }));
		}

		ownKeys.forEach(function (key) {
		  _defineProperty(target, key, source[key]);
		});
	  }

	  return target;
	}

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  subClass.__proto__ = superClass;
	}

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.3.1): util.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */
	/**
	 * ------------------------------------------------------------------------
	 * Private TransitionEnd Helpers
	 * ------------------------------------------------------------------------
	 */

	var TRANSITION_END = 'transitionend';
	var MAX_UID = 1000000;
	var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

	function toType(obj) {
	  return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
	}

	function getSpecialTransitionEndEvent() {
	  return {
		bindType: TRANSITION_END,
		delegateType: TRANSITION_END,
		handle: function handle(event) {
		  if ($(event.target).is(this)) {
			return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
		  }

		  return undefined; // eslint-disable-line no-undefined
		}
	  };
	}

	function transitionEndEmulator(duration) {
	  var _this = this;

	  var called = false;
	  $(this).one(Util.TRANSITION_END, function () {
		called = true;
	  });
	  setTimeout(function () {
		if (!called) {
		  Util.triggerTransitionEnd(_this);
		}
	  }, duration);
	  return this;
	}

	function setTransitionEndSupport() {
	  $.fn.emulateTransitionEnd = transitionEndEmulator;
	  $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
	}
	/**
	 * --------------------------------------------------------------------------
	 * Public Util Api
	 * --------------------------------------------------------------------------
	 */


	var Util = {
	  TRANSITION_END: 'bsTransitionEnd',
	  getUID: function getUID(prefix) {
		do {
		  // eslint-disable-next-line no-bitwise
		  prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
		} while (document.getElementById(prefix));

		return prefix;
	  },
	  getSelectorFromElement: function getSelectorFromElement(element) {
		var selector = element.getAttribute('data-target');

		if (!selector || selector === '#') {
		  var hrefAttr = element.getAttribute('href');
		  selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';
		}

		try {
		  return document.querySelector(selector) ? selector : null;
		} catch (err) {
		  return null;
		}
	  },
	  getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
		if (!element) {
		  return 0;
		} // Get transition-duration of the element


		var transitionDuration = $(element).css('transition-duration');
		var transitionDelay = $(element).css('transition-delay');
		var floatTransitionDuration = parseFloat(transitionDuration);
		var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

		if (!floatTransitionDuration && !floatTransitionDelay) {
		  return 0;
		} // If multiple durations are defined, take the first


		transitionDuration = transitionDuration.split(',')[0];
		transitionDelay = transitionDelay.split(',')[0];
		return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
	  },
	  reflow: function reflow(element) {
		return element.offsetHeight;
	  },
	  triggerTransitionEnd: function triggerTransitionEnd(element) {
		$(element).trigger(TRANSITION_END);
	  },
	  // TODO: Remove in v5
	  supportsTransitionEnd: function supportsTransitionEnd() {
		return Boolean(TRANSITION_END);
	  },
	  isElement: function isElement(obj) {
		return (obj[0] || obj).nodeType;
	  },
	  typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
		for (var property in configTypes) {
		  if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
			var expectedTypes = configTypes[property];
			var value = config[property];
			var valueType = value && Util.isElement(value) ? 'element' : toType(value);

			if (!new RegExp(expectedTypes).test(valueType)) {
			  throw new Error(componentName.toUpperCase() + ": " + ("Option \"" + property + "\" provided type \"" + valueType + "\" ") + ("but expected type \"" + expectedTypes + "\"."));
			}
		  }
		}
	  },
	  findShadowRoot: function findShadowRoot(element) {
		if (!document.documentElement.attachShadow) {
		  return null;
		} // Can find the shadow root otherwise it'll return the document


		if (typeof element.getRootNode === 'function') {
		  var root = element.getRootNode();
		  return root instanceof ShadowRoot ? root : null;
		}

		if (element instanceof ShadowRoot) {
		  return element;
		} // when we don't find a shadow root


		if (!element.parentNode) {
		  return null;
		}

		return Util.findShadowRoot(element.parentNode);
	  }
	};
	setTransitionEndSupport();

	/**
	 * ------------------------------------------------------------------------
	 * Constants
	 * ------------------------------------------------------------------------
	 */

	var NAME = 'alert';
	var VERSION = '4.3.1';
	var DATA_KEY = 'bs.alert';
	var EVENT_KEY = "." + DATA_KEY;
	var DATA_API_KEY = '.data-api';
	var JQUERY_NO_CONFLICT = $.fn[NAME];
	var Selector = {
	  DISMISS: '[data-dismiss="alert"]'
	};
	var Event = {
	  CLOSE: "close" + EVENT_KEY,
	  CLOSED: "closed" + EVENT_KEY,
	  CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
	};
	var ClassName = {
	  ALERT: 'alert',
	  FADE: 'fade',
	  SHOW: 'show'
	  /**
	   * ------------------------------------------------------------------------
	   * Class Definition
	   * ------------------------------------------------------------------------
	   */

	};

	var Alert =
	/*#__PURE__*/
	function () {
	  function Alert(element) {
		this._element = element;
	  } // Getters


	  var _proto = Alert.prototype;

	  // Public
	  _proto.close = function close(element) {
		var rootElement = this._element;

		if (element) {
		  rootElement = this._getRootElement(element);
		}

		var customEvent = this._triggerCloseEvent(rootElement);

		if (customEvent.isDefaultPrevented()) {
		  return;
		}

		this._removeElement(rootElement);
	  };

	  _proto.dispose = function dispose() {
		$.removeData(this._element, DATA_KEY);
		this._element = null;
	  } // Private
	  ;

	  _proto._getRootElement = function _getRootElement(element) {
		var selector = Util.getSelectorFromElement(element);
		var parent = false;

		if (selector) {
		  parent = document.querySelector(selector);
		}

		if (!parent) {
		  parent = $(element).closest("." + ClassName.ALERT)[0];
		}

		return parent;
	  };

	  _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
		var closeEvent = $.Event(Event.CLOSE);
		$(element).trigger(closeEvent);
		return closeEvent;
	  };

	  _proto._removeElement = function _removeElement(element) {
		var _this = this;

		$(element).removeClass(ClassName.SHOW);

		if (!$(element).hasClass(ClassName.FADE)) {
		  this._destroyElement(element);

		  return;
		}

		var transitionDuration = Util.getTransitionDurationFromElement(element);
		$(element).one(Util.TRANSITION_END, function (event) {
		  return _this._destroyElement(element, event);
		}).emulateTransitionEnd(transitionDuration);
	  };

	  _proto._destroyElement = function _destroyElement(element) {
		$(element).detach().trigger(Event.CLOSED).remove();
	  } // Static
	  ;

	  Alert._jQueryInterface = function _jQueryInterface(config) {
		return this.each(function () {
		  var $element = $(this);
		  var data = $element.data(DATA_KEY);

		  if (!data) {
			data = new Alert(this);
			$element.data(DATA_KEY, data);
		  }

		  if (config === 'close') {
			data[config](this);
		  }
		});
	  };

	  Alert._handleDismiss = function _handleDismiss(alertInstance) {
		return function (event) {
		  if (event) {
			event.preventDefault();
		  }

		  alertInstance.close(this);
		};
	  };

	  _createClass(Alert, null, [{
		key: "VERSION",
		get: function get() {
		  return VERSION;
		}
	  }]);

	  return Alert;
	}();
	/**
	 * ------------------------------------------------------------------------
	 * Data Api implementation
	 * ------------------------------------------------------------------------
	 */


	$(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
	/**
	 * ------------------------------------------------------------------------
	 * jQuery
	 * ------------------------------------------------------------------------
	 */

	$.fn[NAME] = Alert._jQueryInterface;
	$.fn[NAME].Constructor = Alert;

	$.fn[NAME].noConflict = function () {
	  $.fn[NAME] = JQUERY_NO_CONFLICT;
	  return Alert._jQueryInterface;
	};

	/**
	 * ------------------------------------------------------------------------
	 * Constants
	 * ------------------------------------------------------------------------
	 */

	var NAME$1 = 'button';
	var VERSION$1 = '4.3.1';
	var DATA_KEY$1 = 'bs.button';
	var EVENT_KEY$1 = "." + DATA_KEY$1;
	var DATA_API_KEY$1 = '.data-api';
	var JQUERY_NO_CONFLICT$1 = $.fn[NAME$1];
	var ClassName$1 = {
	  ACTIVE: 'active',
	  BUTTON: 'btn',
	  FOCUS: 'focus'
	};
	var Selector$1 = {
	  DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
	  DATA_TOGGLE: '[data-toggle="buttons"]',
	  INPUT: 'input:not([type="hidden"])',
	  ACTIVE: '.active',
	  BUTTON: '.btn'
	};
	var Event$1 = {
	  CLICK_DATA_API: "click" + EVENT_KEY$1 + DATA_API_KEY$1,
	  FOCUS_BLUR_DATA_API: "focus" + EVENT_KEY$1 + DATA_API_KEY$1 + " " + ("blur" + EVENT_KEY$1 + DATA_API_KEY$1)
	  /**
	   * ------------------------------------------------------------------------
	   * Class Definition
	   * ------------------------------------------------------------------------
	   */

	};

	var Button =
	/*#__PURE__*/
	function () {
	  function Button(element) {
		this._element = element;
	  } // Getters


	  var _proto = Button.prototype;

	  // Public
	  _proto.toggle = function toggle() {
		var triggerChangeEvent = true;
		var addAriaPressed = true;
		var rootElement = $(this._element).closest(Selector$1.DATA_TOGGLE)[0];

		if (rootElement) {
		  var input = this._element.querySelector(Selector$1.INPUT);

		  if (input) {
			if (input.type === 'radio') {
			  if (input.checked && this._element.classList.contains(ClassName$1.ACTIVE)) {
				triggerChangeEvent = false;
			  } else {
				var activeElement = rootElement.querySelector(Selector$1.ACTIVE);

				if (activeElement) {
				  $(activeElement).removeClass(ClassName$1.ACTIVE);
				}
			  }
			}

			if (triggerChangeEvent) {
			  if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {
				return;
			  }

			  input.checked = !this._element.classList.contains(ClassName$1.ACTIVE);
			  $(input).trigger('change');
			}

			input.focus();
			addAriaPressed = false;
		  }
		}

		if (addAriaPressed) {
		  this._element.setAttribute('aria-pressed', !this._element.classList.contains(ClassName$1.ACTIVE));
		}

		if (triggerChangeEvent) {
		  $(this._element).toggleClass(ClassName$1.ACTIVE);
		}
	  };

	  _proto.dispose = function dispose() {
		$.removeData(this._element, DATA_KEY$1);
		this._element = null;
	  } // Static
	  ;

	  Button._jQueryInterface = function _jQueryInterface(config) {
		return this.each(function () {
		  var data = $(this).data(DATA_KEY$1);

		  if (!data) {
			data = new Button(this);
			$(this).data(DATA_KEY$1, data);
		  }

		  if (config === 'toggle') {
			data[config]();
		  }
		});
	  };

	  _createClass(Button, null, [{
		key: "VERSION",
		get: function get() {
		  return VERSION$1;
		}
	  }]);

	  return Button;
	}();
	/**
	 * ------------------------------------------------------------------------
	 * Data Api implementation
	 * ------------------------------------------------------------------------
	 */


	$(document).on(Event$1.CLICK_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {
	  event.preventDefault();
	  var button = event.target;

	  if (!$(button).hasClass(ClassName$1.BUTTON)) {
		button = $(button).closest(Selector$1.BUTTON);
	  }

	  Button._jQueryInterface.call($(button), 'toggle');
	}).on(Event$1.FOCUS_BLUR_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {
	  var button = $(event.target).closest(Selector$1.BUTTON)[0];
	  $(button).toggleClass(ClassName$1.FOCUS, /^focus(in)?$/.test(event.type));
	});
	/**
	 * ------------------------------------------------------------------------
	 * jQuery
	 * ------------------------------------------------------------------------
	 */

	$.fn[NAME$1] = Button._jQueryInterface;
	$.fn[NAME$1].Constructor = Button;

	$.fn[NAME$1].noConflict = function () {
	  $.fn[NAME$1] = JQUERY_NO_CONFLICT$1;
	  return Button._jQueryInterface;
	};

	/**
	 * ------------------------------------------------------------------------
	 * Constants
	 * ------------------------------------------------------------------------
	 */

	var NAME$2 = 'carousel';
	var VERSION$2 = '4.3.1';
	var DATA_KEY$2 = 'bs.carousel';
	var EVENT_KEY$2 = "." + DATA_KEY$2;
	var DATA_API_KEY$2 = '.data-api';
	var JQUERY_NO_CONFLICT$2 = $.fn[NAME$2];
	var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key

	var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key

	var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

	var SWIPE_THRESHOLD = 40;
	var Default = {
	  interval: 5000,
	  keyboard: true,
	  slide: false,
	  pause: 'hover',
	  wrap: true,
	  touch: true
	};
	var DefaultType = {
	  interval: '(number|boolean)',
	  keyboard: 'boolean',
	  slide: '(boolean|string)',
	  pause: '(string|boolean)',
	  wrap: 'boolean',
	  touch: 'boolean'
	};
	var Direction = {
	  NEXT: 'next',
	  PREV: 'prev',
	  LEFT: 'left',
	  RIGHT: 'right'
	};
	var Event$2 = {
	  SLIDE: "slide" + EVENT_KEY$2,
	  SLID: "slid" + EVENT_KEY$2,
	  KEYDOWN: "keydown" + EVENT_KEY$2,
	  MOUSEENTER: "mouseenter" + EVENT_KEY$2,
	  MOUSELEAVE: "mouseleave" + EVENT_KEY$2,
	  TOUCHSTART: "touchstart" + EVENT_KEY$2,
	  TOUCHMOVE: "touchmove" + EVENT_KEY$2,
	  TOUCHEND: "touchend" + EVENT_KEY$2,
	  POINTERDOWN: "pointerdown" + EVENT_KEY$2,
	  POINTERUP: "pointerup" + EVENT_KEY$2,
	  DRAG_START: "dragstart" + EVENT_KEY$2,
	  LOAD_DATA_API: "load" + EVENT_KEY$2 + DATA_API_KEY$2,
	  CLICK_DATA_API: "click" + EVENT_KEY$2 + DATA_API_KEY$2
	};
	var ClassName$2 = {
	  CAROUSEL: 'carousel',
	  ACTIVE: 'active',
	  SLIDE: 'slide',
	  RIGHT: 'carousel-item-right',
	  LEFT: 'carousel-item-left',
	  NEXT: 'carousel-item-next',
	  PREV: 'carousel-item-prev',
	  ITEM: 'carousel-item',
	  POINTER_EVENT: 'pointer-event'
	};
	var Selector$2 = {
	  ACTIVE: '.active',
	  ACTIVE_ITEM: '.active.carousel-item',
	  ITEM: '.carousel-item',
	  ITEM_IMG: '.carousel-item img',
	  NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
	  INDICATORS: '.carousel-indicators',
	  DATA_SLIDE: '[data-slide], [data-slide-to]',
	  DATA_RIDE: '[data-ride="carousel"]'
	};
	var PointerType = {
	  TOUCH: 'touch',
	  PEN: 'pen'
	  /**
	   * ------------------------------------------------------------------------
	   * Class Definition
	   * ------------------------------------------------------------------------
	   */

	};

	var Carousel =
	/*#__PURE__*/
	function () {
	  function Carousel(element, config) {
		this._items = null;
		this._interval = null;
		this._activeElement = null;
		this._isPaused = false;
		this._isSliding = false;
		this.touchTimeout = null;
		this.touchStartX = 0;
		this.touchDeltaX = 0;
		this._config = this._getConfig(config);
		this._element = element;
		this._indicatorsElement = this._element.querySelector(Selector$2.INDICATORS);
		this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
		this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);

		this._addEventListeners();
	  } // Getters


	  var _proto = Carousel.prototype;

	  // Public
	  _proto.next = function next() {
		if (!this._isSliding) {
		  this._slide(Direction.NEXT);
		}
	  };

	  _proto.nextWhenVisible = function nextWhenVisible() {
		// Don't call next when the page isn't visible
		// or the carousel or its parent isn't visible
		if (!document.hidden && $(this._element).is(':visible') && $(this._element).css('visibility') !== 'hidden') {
		  this.next();
		}
	  };

	  _proto.prev = function prev() {
		if (!this._isSliding) {
		  this._slide(Direction.PREV);
		}
	  };

	  _proto.pause = function pause(event) {
		if (!event) {
		  this._isPaused = true;
		}

		if (this._element.querySelector(Selector$2.NEXT_PREV)) {
		  Util.triggerTransitionEnd(this._element);
		  this.cycle(true);
		}

		clearInterval(this._interval);
		this._interval = null;
	  };

	  _proto.cycle = function cycle(event) {
		if (!event) {
		  this._isPaused = false;
		}

		if (this._interval) {
		  clearInterval(this._interval);
		  this._interval = null;
		}

		if (this._config.interval && !this._isPaused) {
		  this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
		}
	  };

	  _proto.to = function to(index) {
		var _this = this;

		this._activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);

		var activeIndex = this._getItemIndex(this._activeElement);

		if (index > this._items.length - 1 || index < 0) {
		  return;
		}

		if (this._isSliding) {
		  $(this._element).one(Event$2.SLID, function () {
			return _this.to(index);
		  });
		  return;
		}

		if (activeIndex === index) {
		  this.pause();
		  this.cycle();
		  return;
		}

		var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;

		this._slide(direction, this._items[index]);
	  };

	  _proto.dispose = function dispose() {
		$(this._element).off(EVENT_KEY$2);
		$.removeData(this._element, DATA_KEY$2);
		this._items = null;
		this._config = null;
		this._element = null;
		this._interval = null;
		this._isPaused = null;
		this._isSliding = null;
		this._activeElement = null;
		this._indicatorsElement = null;
	  } // Private
	  ;

	  _proto._getConfig = function _getConfig(config) {
		config = _objectSpread({}, Default, config);
		Util.typeCheckConfig(NAME$2, config, DefaultType);
		return config;
	  };

	  _proto._handleSwipe = function _handleSwipe() {
		var absDeltax = Math.abs(this.touchDeltaX);

		if (absDeltax <= SWIPE_THRESHOLD) {
		  return;
		}

		var direction = absDeltax / this.touchDeltaX; // swipe left

		if (direction > 0) {
		  this.prev();
		} // swipe right


		if (direction < 0) {
		  this.next();
		}
	  };

	  _proto._addEventListeners = function _addEventListeners() {
		var _this2 = this;

		if (this._config.keyboard) {
		  $(this._element).on(Event$2.KEYDOWN, function (event) {
			return _this2._keydown(event);
		  });
		}

		if (this._config.pause === 'hover') {
		  $(this._element).on(Event$2.MOUSEENTER, function (event) {
			return _this2.pause(event);
		  }).on(Event$2.MOUSELEAVE, function (event) {
			return _this2.cycle(event);
		  });
		}

		if (this._config.touch) {
		  this._addTouchEventListeners();
		}
	  };

	  _proto._addTouchEventListeners = function _addTouchEventListeners() {
		var _this3 = this;

		if (!this._touchSupported) {
		  return;
		}

		var start = function start(event) {
		  if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
			_this3.touchStartX = event.originalEvent.clientX;
		  } else if (!_this3._pointerEvent) {
			_this3.touchStartX = event.originalEvent.touches[0].clientX;
		  }
		};

		var move = function move(event) {
		  // ensure swiping with one touch and not pinching
		  if (event.originalEvent.touches && event.originalEvent.touches.length > 1) {
			_this3.touchDeltaX = 0;
		  } else {
			_this3.touchDeltaX = event.originalEvent.touches[0].clientX - _this3.touchStartX;
		  }
		};

		var end = function end(event) {
		  if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
			_this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;
		  }

		  _this3._handleSwipe();

		  if (_this3._config.pause === 'hover') {
			// If it's a touch-enabled device, mouseenter/leave are fired as
			// part of the mouse compatibility events on first tap - the carousel
			// would stop cycling until user tapped out of it;
			// here, we listen for touchend, explicitly pause the carousel
			// (as if it's the second time we tap on it, mouseenter compat event
			// is NOT fired) and after a timeout (to allow for mouse compatibility
			// events to fire) we explicitly restart cycling
			_this3.pause();

			if (_this3.touchTimeout) {
			  clearTimeout(_this3.touchTimeout);
			}

			_this3.touchTimeout = setTimeout(function (event) {
			  return _this3.cycle(event);
			}, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);
		  }
		};

		$(this._element.querySelectorAll(Selector$2.ITEM_IMG)).on(Event$2.DRAG_START, function (e) {
		  return e.preventDefault();
		});

		if (this._pointerEvent) {
		  $(this._element).on(Event$2.POINTERDOWN, function (event) {
			return start(event);
		  });
		  $(this._element).on(Event$2.POINTERUP, function (event) {
			return end(event);
		  });

		  this._element.classList.add(ClassName$2.POINTER_EVENT);
		} else {
		  $(this._element).on(Event$2.TOUCHSTART, function (event) {
			return start(event);
		  });
		  $(this._element).on(Event$2.TOUCHMOVE, function (event) {
			return move(event);
		  });
		  $(this._element).on(Event$2.TOUCHEND, function (event) {
			return end(event);
		  });
		}
	  };

	  _proto._keydown = function _keydown(event) {
		if (/input|textarea/i.test(event.target.tagName)) {
		  return;
		}

		switch (event.which) {
		  case ARROW_LEFT_KEYCODE:
			event.preventDefault();
			this.prev();
			break;

		  case ARROW_RIGHT_KEYCODE:
			event.preventDefault();
			this.next();
			break;

		  default:
		}
	  };

	  _proto._getItemIndex = function _getItemIndex(element) {
		this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(Selector$2.ITEM)) : [];
		return this._items.indexOf(element);
	  };

	  _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
		var isNextDirection = direction === Direction.NEXT;
		var isPrevDirection = direction === Direction.PREV;

		var activeIndex = this._getItemIndex(activeElement);

		var lastItemIndex = this._items.length - 1;
		var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

		if (isGoingToWrap && !this._config.wrap) {
		  return activeElement;
		}

		var delta = direction === Direction.PREV ? -1 : 1;
		var itemIndex = (activeIndex + delta) % this._items.length;
		return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
	  };

	  _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
		var targetIndex = this._getItemIndex(relatedTarget);

		var fromIndex = this._getItemIndex(this._element.querySelector(Selector$2.ACTIVE_ITEM));

		var slideEvent = $.Event(Event$2.SLIDE, {
		  relatedTarget: relatedTarget,
		  direction: eventDirectionName,
		  from: fromIndex,
		  to: targetIndex
		});
		$(this._element).trigger(slideEvent);
		return slideEvent;
	  };

	  _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
		if (this._indicatorsElement) {
		  var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(Selector$2.ACTIVE));
		  $(indicators).removeClass(ClassName$2.ACTIVE);

		  var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

		  if (nextIndicator) {
			$(nextIndicator).addClass(ClassName$2.ACTIVE);
		  }
		}
	  };

	  _proto._slide = function _slide(direction, element) {
		var _this4 = this;

		var activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);

		var activeElementIndex = this._getItemIndex(activeElement);

		var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);

		var nextElementIndex = this._getItemIndex(nextElement);

		var isCycling = Boolean(this._interval);
		var directionalClassName;
		var orderClassName;
		var eventDirectionName;

		if (direction === Direction.NEXT) {
		  directionalClassName = ClassName$2.LEFT;
		  orderClassName = ClassName$2.NEXT;
		  eventDirectionName = Direction.LEFT;
		} else {
		  directionalClassName = ClassName$2.RIGHT;
		  orderClassName = ClassName$2.PREV;
		  eventDirectionName = Direction.RIGHT;
		}

		if (nextElement && $(nextElement).hasClass(ClassName$2.ACTIVE)) {
		  this._isSliding = false;
		  return;
		}

		var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

		if (slideEvent.isDefaultPrevented()) {
		  return;
		}

		if (!activeElement || !nextElement) {
		  // Some weirdness is happening, so we bail
		  return;
		}

		this._isSliding = true;

		if (isCycling) {
		  this.pause();
		}

		this._setActiveIndicatorElement(nextElement);

		var slidEvent = $.Event(Event$2.SLID, {
		  relatedTarget: nextElement,
		  direction: eventDirectionName,
		  from: activeElementIndex,
		  to: nextElementIndex
		});

		if ($(this._element).hasClass(ClassName$2.SLIDE)) {
		  $(nextElement).addClass(orderClassName);
		  Util.reflow(nextElement);
		  $(activeElement).addClass(directionalClassName);
		  $(nextElement).addClass(directionalClassName);
		  var nextElementInterval = parseInt(nextElement.getAttribute('data-interval'), 10);

		  if (nextElementInterval) {
			this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
			this._config.interval = nextElementInterval;
		  } else {
			this._config.interval = this._config.defaultInterval || this._config.interval;
		  }

		  var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
		  $(activeElement).one(Util.TRANSITION_END, function () {
			$(nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(ClassName$2.ACTIVE);
			$(activeElement).removeClass(ClassName$2.ACTIVE + " " + orderClassName + " " + directionalClassName);
			_this4._isSliding = false;
			setTimeout(function () {
			  return $(_this4._element).trigger(slidEvent);
			}, 0);
		  }).emulateTransitionEnd(transitionDuration);
		} else {
		  $(activeElement).removeClass(ClassName$2.ACTIVE);
		  $(nextElement).addClass(ClassName$2.ACTIVE);
		  this._isSliding = false;
		  $(this._element).trigger(slidEvent);
		}

		if (isCycling) {
		  this.cycle();
		}
	  } // Static
	  ;

	  Carousel._jQueryInterface = function _jQueryInterface(config) {
		return this.each(function () {
		  var data = $(this).data(DATA_KEY$2);

		  var _config = _objectSpread({}, Default, $(this).data());

		  if (typeof config === 'object') {
			_config = _objectSpread({}, _config, config);
		  }

		  var action = typeof config === 'string' ? config : _config.slide;

		  if (!data) {
			data = new Carousel(this, _config);
			$(this).data(DATA_KEY$2, data);
		  }

		  if (typeof config === 'number') {
			data.to(config);
		  } else if (typeof action === 'string') {
			if (typeof data[action] === 'undefined') {
			  throw new TypeError("No method named \"" + action + "\"");
			}

			data[action]();
		  } else if (_config.interval && _config.ride) {
			data.pause();
			data.cycle();
		  }
		});
	  };

	  Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
		var selector = Util.getSelectorFromElement(this);

		if (!selector) {
		  return;
		}

		var target = $(selector)[0];

		if (!target || !$(target).hasClass(ClassName$2.CAROUSEL)) {
		  return;
		}

		var config = _objectSpread({}, $(target).data(), $(this).data());

		var slideIndex = this.getAttribute('data-slide-to');

		if (slideIndex) {
		  config.interval = false;
		}

		Carousel._jQueryInterface.call($(target), config);

		if (slideIndex) {
		  $(target).data(DATA_KEY$2).to(slideIndex);
		}

		event.preventDefault();
	  };

	  _createClass(Carousel, null, [{
		key: "VERSION",
		get: function get() {
		  return VERSION$2;
		}
	  }, {
		key: "Default",
		get: function get() {
		  return Default;
		}
	  }]);

	  return Carousel;
	}();
	/**
	 * ------------------------------------------------------------------------
	 * Data Api implementation
	 * ------------------------------------------------------------------------
	 */


	$(document).on(Event$2.CLICK_DATA_API, Selector$2.DATA_SLIDE, Carousel._dataApiClickHandler);
	$(window).on(Event$2.LOAD_DATA_API, function () {
	  var carousels = [].slice.call(document.querySelectorAll(Selector$2.DATA_RIDE));

	  for (var i = 0, len = carousels.length; i < len; i++) {
		var $carousel = $(carousels[i]);

		Carousel._jQueryInterface.call($carousel, $carousel.data());
	  }
	});
	/**
	 * ------------------------------------------------------------------------
	 * jQuery
	 * ------------------------------------------------------------------------
	 */

	$.fn[NAME$2] = Carousel._jQueryInterface;
	$.fn[NAME$2].Constructor = Carousel;

	$.fn[NAME$2].noConflict = function () {
	  $.fn[NAME$2] = JQUERY_NO_CONFLICT$2;
	  return Carousel._jQueryInterface;
	};

	/**
	 * ------------------------------------------------------------------------
	 * Constants
	 * ------------------------------------------------------------------------
	 */

	var NAME$3 = 'collapse';
	var VERSION$3 = '4.3.1';
	var DATA_KEY$3 = 'bs.collapse';
	var EVENT_KEY$3 = "." + DATA_KEY$3;
	var DATA_API_KEY$3 = '.data-api';
	var JQUERY_NO_CONFLICT$3 = $.fn[NAME$3];
	var Default$1 = {
	  toggle: true,
	  parent: ''
	};
	var DefaultType$1 = {
	  toggle: 'boolean',
	  parent: '(string|element)'
	};
	var Event$3 = {
	  SHOW: "show" + EVENT_KEY$3,
	  SHOWN: "shown" + EVENT_KEY$3,
	  HIDE: "hide" + EVENT_KEY$3,
	  HIDDEN: "hidden" + EVENT_KEY$3,
	  CLICK_DATA_API: "click" + EVENT_KEY$3 + DATA_API_KEY$3
	};
	var ClassName$3 = {
	  SHOW: 'show',
	  COLLAPSE: 'collapse',
	  COLLAPSING: 'collapsing',
	  COLLAPSED: 'collapsed'
	};
	var Dimension = {
	  WIDTH: 'width',
	  HEIGHT: 'height'
	};
	var Selector$3 = {
	  ACTIVES: '.show, .collapsing',
	  DATA_TOGGLE: '[data-toggle="collapse"]'
	  /**
	   * ------------------------------------------------------------------------
	   * Class Definition
	   * ------------------------------------------------------------------------
	   */

	};

	var Collapse =
	/*#__PURE__*/
	function () {
	  function Collapse(element, config) {
		this._isTransitioning = false;
		this._element = element;
		this._config = this._getConfig(config);
		this._triggerArray = [].slice.call(document.querySelectorAll("[data-toggle=\"collapse\"][href=\"#" + element.id + "\"]," + ("[data-toggle=\"collapse\"][data-target=\"#" + element.id + "\"]")));
		var toggleList = [].slice.call(document.querySelectorAll(Selector$3.DATA_TOGGLE));

		for (var i = 0, len = toggleList.length; i < len; i++) {
		  var elem = toggleList[i];
		  var selector = Util.getSelectorFromElement(elem);
		  var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {
			return foundElem === element;
		  });

		  if (selector !== null && filterElement.length > 0) {
			this._selector = selector;

			this._triggerArray.push(elem);
		  }
		}

		this._parent = this._config.parent ? this._getParent() : null;

		if (!this._config.parent) {
		  this._addAriaAndCollapsedClass(this._element, this._triggerArray);
		}

		if (this._config.toggle) {
		  this.toggle();
		}
	  } // Getters


	  var _proto = Collapse.prototype;

	  // Public
	  _proto.toggle = function toggle() {
		if ($(this._element).hasClass(ClassName$3.SHOW)) {
		  this.hide();
		} else {
		  this.show();
		}
	  };

	  _proto.show = function show() {
		var _this = this;

		if (this._isTransitioning || $(this._element).hasClass(ClassName$3.SHOW)) {
		  return;
		}

		var actives;
		var activesData;

		if (this._parent) {
		  actives = [].slice.call(this._parent.querySelectorAll(Selector$3.ACTIVES)).filter(function (elem) {
			if (typeof _this._config.parent === 'string') {
			  return elem.getAttribute('data-parent') === _this._config.parent;
			}

			return elem.classList.contains(ClassName$3.COLLAPSE);
		  });

		  if (actives.length === 0) {
			actives = null;
		  }
		}

		if (actives) {
		  activesData = $(actives).not(this._selector).data(DATA_KEY$3);

		  if (activesData && activesData._isTransitioning) {
			return;
		  }
		}

		var startEvent = $.Event(Event$3.SHOW);
		$(this._element).trigger(startEvent);

		if (startEvent.isDefaultPrevented()) {
		  return;
		}

		if (actives) {
		  Collapse._jQueryInterface.call($(actives).not(this._selector), 'hide');

		  if (!activesData) {
			$(actives).data(DATA_KEY$3, null);
		  }
		}

		var dimension = this._getDimension();

		$(this._element).removeClass(ClassName$3.COLLAPSE).addClass(ClassName$3.COLLAPSING);
		this._element.style[dimension] = 0;

		if (this._triggerArray.length) {
		  $(this._triggerArray).removeClass(ClassName$3.COLLAPSED).attr('aria-expanded', true);
		}

		this.setTransitioning(true);

		var complete = function complete() {
		  $(_this._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).addClass(ClassName$3.SHOW);
		  _this._element.style[dimension] = '';

		  _this.setTransitioning(false);

		  $(_this._element).trigger(Event$3.SHOWN);
		};

		var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
		var scrollSize = "scroll" + capitalizedDimension;
		var transitionDuration = Util.getTransitionDurationFromElement(this._element);
		$(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
		this._element.style[dimension] = this._element[scrollSize] + "px";
	  };

	  _proto.hide = function hide() {
		var _this2 = this;

		if (this._isTransitioning || !$(this._element).hasClass(ClassName$3.SHOW)) {
		  return;
		}

		var startEvent = $.Event(Event$3.HIDE);
		$(this._element).trigger(startEvent);

		if (startEvent.isDefaultPrevented()) {
		  return;
		}

		var dimension = this._getDimension();

		this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
		Util.reflow(this._element);
		$(this._element).addClass(ClassName$3.COLLAPSING).removeClass(ClassName$3.COLLAPSE).removeClass(ClassName$3.SHOW);
		var triggerArrayLength = this._triggerArray.length;

		if (triggerArrayLength > 0) {
		  for (var i = 0; i < triggerArrayLength; i++) {
			var trigger = this._triggerArray[i];
			var selector = Util.getSelectorFromElement(trigger);

			if (selector !== null) {
			  var $elem = $([].slice.call(document.querySelectorAll(selector)));

			  if (!$elem.hasClass(ClassName$3.SHOW)) {
				$(trigger).addClass(ClassName$3.COLLAPSED).attr('aria-expanded', false);
			  }
			}
		  }
		}

		this.setTransitioning(true);

		var complete = function complete() {
		  _this2.setTransitioning(false);

		  $(_this2._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).trigger(Event$3.HIDDEN);
		};

		this._element.style[dimension] = '';
		var transitionDuration = Util.getTransitionDurationFromElement(this._element);
		$(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
	  };

	  _proto.setTransitioning = function setTransitioning(isTransitioning) {
		this._isTransitioning = isTransitioning;
	  };

	  _proto.dispose = function dispose() {
		$.removeData(this._element, DATA_KEY$3);
		this._config = null;
		this._parent = null;
		this._element = null;
		this._triggerArray = null;
		this._isTransitioning = null;
	  } // Private
	  ;

	  _proto._getConfig = function _getConfig(config) {
		config = _objectSpread({}, Default$1, config);
		config.toggle = Boolean(config.toggle); // Coerce string values

		Util.typeCheckConfig(NAME$3, config, DefaultType$1);
		return config;
	  };

	  _proto._getDimension = function _getDimension() {
		var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
		return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
	  };

	  _proto._getParent = function _getParent() {
		var _this3 = this;

		var parent;

		if (Util.isElement(this._config.parent)) {
		  parent = this._config.parent; // It's a jQuery object

		  if (typeof this._config.parent.jquery !== 'undefined') {
			parent = this._config.parent[0];
		  }
		} else {
		  parent = document.querySelector(this._config.parent);
		}

		var selector = "[data-toggle=\"collapse\"][data-parent=\"" + this._config.parent + "\"]";
		var children = [].slice.call(parent.querySelectorAll(selector));
		$(children).each(function (i, element) {
		  _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
		});
		return parent;
	  };

	  _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
		var isOpen = $(element).hasClass(ClassName$3.SHOW);

		if (triggerArray.length) {
		  $(triggerArray).toggleClass(ClassName$3.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
		}
	  } // Static
	  ;

	  Collapse._getTargetFromElement = function _getTargetFromElement(element) {
		var selector = Util.getSelectorFromElement(element);
		return selector ? document.querySelector(selector) : null;
	  };

	  Collapse._jQueryInterface = function _jQueryInterface(config) {
		return this.each(function () {
		  var $this = $(this);
		  var data = $this.data(DATA_KEY$3);

		  var _config = _objectSpread({}, Default$1, $this.data(), typeof config === 'object' && config ? config : {});

		  if (!data && _config.toggle && /show|hide/.test(config)) {
			_config.toggle = false;
		  }

		  if (!data) {
			data = new Collapse(this, _config);
			$this.data(DATA_KEY$3, data);
		  }

		  if (typeof config === 'string') {
			if (typeof data[config] === 'undefined') {
			  throw new TypeError("No method named \"" + config + "\"");
			}

			data[config]();
		  }
		});
	  };

	  _createClass(Collapse, null, [{
		key: "VERSION",
		get: function get() {
		  return VERSION$3;
		}
	  }, {
		key: "Default",
		get: function get() {
		  return Default$1;
		}
	  }]);

	  return Collapse;
	}();
	/**
	 * ------------------------------------------------------------------------
	 * Data Api implementation
	 * ------------------------------------------------------------------------
	 */


	$(document).on(Event$3.CLICK_DATA_API, Selector$3.DATA_TOGGLE, function (event) {
	  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
	  if (event.currentTarget.tagName === 'A') {
		event.preventDefault();
	  }

	  var $trigger = $(this);
	  var selector = Util.getSelectorFromElement(this);
	  var selectors = [].slice.call(document.querySelectorAll(selector));
	  $(selectors).each(function () {
		var $target = $(this);
		var data = $target.data(DATA_KEY$3);
		var config = data ? 'toggle' : $trigger.data();

		Collapse._jQueryInterface.call($target, config);
	  });
	});
	/**
	 * ------------------------------------------------------------------------
	 * jQuery
	 * ------------------------------------------------------------------------
	 */

	$.fn[NAME$3] = Collapse._jQueryInterface;
	$.fn[NAME$3].Constructor = Collapse;

	$.fn[NAME$3].noConflict = function () {
	  $.fn[NAME$3] = JQUERY_NO_CONFLICT$3;
	  return Collapse._jQueryInterface;
	};

	/**!
	 * @fileOverview Kickass library to create and place poppers near their reference elements.
	 * @version 1.14.7
	 * @license
	 * Copyright (c) 2016 Federico Zivolo and contributors
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */
	var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

	var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
	var timeoutDuration = 0;
	for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
	  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
		timeoutDuration = 1;
		break;
	  }
	}

	function microtaskDebounce(fn) {
	  var called = false;
	  return function () {
		if (called) {
		  return;
		}
		called = true;
		window.Promise.resolve().then(function () {
		  called = false;
		  fn();
		});
	  };
	}

	function taskDebounce(fn) {
	  var scheduled = false;
	  return function () {
		if (!scheduled) {
		  scheduled = true;
		  setTimeout(function () {
			scheduled = false;
			fn();
		  }, timeoutDuration);
		}
	  };
	}

	var supportsMicroTasks = isBrowser && window.Promise;

	/**
	* Create a debounced version of a method, that's asynchronously deferred
	* but called in the minimum time possible.
	*
	* @method
	* @memberof Popper.Utils
	* @argument {Function} fn
	* @returns {Function}
	*/
	var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

	/**
	 * Check if the given variable is a function
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Any} functionToCheck - variable to check
	 * @returns {Boolean} answer to: is a function?
	 */
	function isFunction(functionToCheck) {
	  var getType = {};
	  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
	}

	/**
	 * Get CSS computed property of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Eement} element
	 * @argument {String} property
	 */
	function getStyleComputedProperty(element, property) {
	  if (element.nodeType !== 1) {
		return [];
	  }
	  // NOTE: 1 DOM access here
	  var window = element.ownerDocument.defaultView;
	  var css = window.getComputedStyle(element, null);
	  return property ? css[property] : css;
	}

	/**
	 * Returns the parentNode or the host of the element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} parent
	 */
	function getParentNode(element) {
	  if (element.nodeName === 'HTML') {
		return element;
	  }
	  return element.parentNode || element.host;
	}

	/**
	 * Returns the scrolling parent of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} scroll parent
	 */
	function getScrollParent(element) {
	  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
	  if (!element) {
		return document.body;
	  }

	  switch (element.nodeName) {
		case 'HTML':
		case 'BODY':
		  return element.ownerDocument.body;
		case '#document':
		  return element.body;
	  }

	  // Firefox want us to check `-x` and `-y` variations as well

	  var _getStyleComputedProp = getStyleComputedProperty(element),
		  overflow = _getStyleComputedProp.overflow,
		  overflowX = _getStyleComputedProp.overflowX,
		  overflowY = _getStyleComputedProp.overflowY;

	  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
		return element;
	  }

	  return getScrollParent(getParentNode(element));
	}

	var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
	var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

	/**
	 * Determines if the browser is Internet Explorer
	 * @method
	 * @memberof Popper.Utils
	 * @param {Number} version to check
	 * @returns {Boolean} isIE
	 */
	function isIE(version) {
	  if (version === 11) {
		return isIE11;
	  }
	  if (version === 10) {
		return isIE10;
	  }
	  return isIE11 || isIE10;
	}

	/**
	 * Returns the offset parent of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} offset parent
	 */
	function getOffsetParent(element) {
	  if (!element) {
		return document.documentElement;
	  }

	  var noOffsetParent = isIE(10) ? document.body : null;

	  // NOTE: 1 DOM access here
	  var offsetParent = element.offsetParent || null;
	  // Skip hidden elements which don't have an offsetParent
	  while (offsetParent === noOffsetParent && element.nextElementSibling) {
		offsetParent = (element = element.nextElementSibling).offsetParent;
	  }

	  var nodeName = offsetParent && offsetParent.nodeName;

	  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
		return element ? element.ownerDocument.documentElement : document.documentElement;
	  }

	  // .offsetParent will return the closest TH, TD or TABLE in case
	  // no offsetParent is present, I hate this job...
	  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
		return getOffsetParent(offsetParent);
	  }

	  return offsetParent;
	}

	function isOffsetContainer(element) {
	  var nodeName = element.nodeName;

	  if (nodeName === 'BODY') {
		return false;
	  }
	  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
	}

	/**
	 * Finds the root node (document, shadowDOM root) of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} node
	 * @returns {Element} root node
	 */
	function getRoot(node) {
	  if (node.parentNode !== null) {
		return getRoot(node.parentNode);
	  }

	  return node;
	}

	/**
	 * Finds the offset parent common to the two provided nodes
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element1
	 * @argument {Element} element2
	 * @returns {Element} common offset parent
	 */
	function findCommonOffsetParent(element1, element2) {
	  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
	  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
		return document.documentElement;
	  }

	  // Here we make sure to give as "start" the element that comes first in the DOM
	  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
	  var start = order ? element1 : element2;
	  var end = order ? element2 : element1;

	  // Get common ancestor container
	  var range = document.createRange();
	  range.setStart(start, 0);
	  range.setEnd(end, 0);
	  var commonAncestorContainer = range.commonAncestorContainer;

	  // Both nodes are inside #document

	  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
		if (isOffsetContainer(commonAncestorContainer)) {
		  return commonAncestorContainer;
		}

		return getOffsetParent(commonAncestorContainer);
	  }

	  // one of the nodes is inside shadowDOM, find which one
	  var element1root = getRoot(element1);
	  if (element1root.host) {
		return findCommonOffsetParent(element1root.host, element2);
	  } else {
		return findCommonOffsetParent(element1, getRoot(element2).host);
	  }
	}

	/**
	 * Gets the scroll value of the given element in the given side (top and left)
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @argument {String} side `top` or `left`
	 * @returns {number} amount of scrolled pixels
	 */
	function getScroll(element) {
	  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

	  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
	  var nodeName = element.nodeName;

	  if (nodeName === 'BODY' || nodeName === 'HTML') {
		var html = element.ownerDocument.documentElement;
		var scrollingElement = element.ownerDocument.scrollingElement || html;
		return scrollingElement[upperSide];
	  }

	  return element[upperSide];
	}

	/*
	 * Sum or subtract the element scroll values (left and top) from a given rect object
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} rect - Rect object you want to change
	 * @param {HTMLElement} element - The element from the function reads the scroll values
	 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
	 * @return {Object} rect - The modifier rect object
	 */
	function includeScroll(rect, element) {
	  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  var scrollTop = getScroll(element, 'top');
	  var scrollLeft = getScroll(element, 'left');
	  var modifier = subtract ? -1 : 1;
	  rect.top += scrollTop * modifier;
	  rect.bottom += scrollTop * modifier;
	  rect.left += scrollLeft * modifier;
	  rect.right += scrollLeft * modifier;
	  return rect;
	}

	/*
	 * Helper to detect borders of a given element
	 * @method
	 * @memberof Popper.Utils
	 * @param {CSSStyleDeclaration} styles
	 * Result of `getStyleComputedProperty` on the given element
	 * @param {String} axis - `x` or `y`
	 * @return {number} borders - The borders size of the given axis
	 */

	function getBordersSize(styles, axis) {
	  var sideA = axis === 'x' ? 'Left' : 'Top';
	  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

	  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
	}

	function getSize(axis, body, html, computedStyle) {
	  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
	}

	function getWindowSizes(document) {
	  var body = document.body;
	  var html = document.documentElement;
	  var computedStyle = isIE(10) && getComputedStyle(html);

	  return {
		height: getSize('Height', body, html, computedStyle),
		width: getSize('Width', body, html, computedStyle)
	  };
	}

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
		throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
		for (var i = 0; i < props.length; i++) {
		  var descriptor = props[i];
		  descriptor.enumerable = descriptor.enumerable || false;
		  descriptor.configurable = true;
		  if ("value" in descriptor) descriptor.writable = true;
		  Object.defineProperty(target, descriptor.key, descriptor);
		}
	  }

	  return function (Constructor, protoProps, staticProps) {
		if (protoProps) defineProperties(Constructor.prototype, protoProps);
		if (staticProps) defineProperties(Constructor, staticProps);
		return Constructor;
	  };
	}();





	var defineProperty = function (obj, key, value) {
	  if (key in obj) {
		Object.defineProperty(obj, key, {
		  value: value,
		  enumerable: true,
		  configurable: true,
		  writable: true
		});
	  } else {
		obj[key] = value;
	  }

	  return obj;
	};

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i];

		for (var key in source) {
		  if (Object.prototype.hasOwnProperty.call(source, key)) {
			target[key] = source[key];
		  }
		}
	  }

	  return target;
	};

	/**
	 * Given element offsets, generate an output similar to getBoundingClientRect
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Object} offsets
	 * @returns {Object} ClientRect like output
	 */
	function getClientRect(offsets) {
	  return _extends({}, offsets, {
		right: offsets.left + offsets.width,
		bottom: offsets.top + offsets.height
	  });
	}

	/**
	 * Get bounding client rect of given element
	 * @method
	 * @memberof Popper.Utils
	 * @param {HTMLElement} element
	 * @return {Object} client rect
	 */
	function getBoundingClientRect(element) {
	  var rect = {};

	  // IE10 10 FIX: Please, don't ask, the element isn't
	  // considered in DOM in some circumstances...
	  // This isn't reproducible in IE10 compatibility mode of IE11
	  try {
		if (isIE(10)) {
		  rect = element.getBoundingClientRect();
		  var scrollTop = getScroll(element, 'top');
		  var scrollLeft = getScroll(element, 'left');
		  rect.top += scrollTop;
		  rect.left += scrollLeft;
		  rect.bottom += scrollTop;
		  rect.right += scrollLeft;
		} else {
		  rect = element.getBoundingClientRect();
		}
	  } catch (e) {}

	  var result = {
		left: rect.left,
		top: rect.top,
		width: rect.right - rect.left,
		height: rect.bottom - rect.top
	  };

	  // subtract scrollbar size from sizes
	  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
	  var width = sizes.width || element.clientWidth || result.right - result.left;
	  var height = sizes.height || element.clientHeight || result.bottom - result.top;

	  var horizScrollbar = element.offsetWidth - width;
	  var vertScrollbar = element.offsetHeight - height;

	  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
	  // we make this check conditional for performance reasons
	  if (horizScrollbar || vertScrollbar) {
		var styles = getStyleComputedProperty(element);
		horizScrollbar -= getBordersSize(styles, 'x');
		vertScrollbar -= getBordersSize(styles, 'y');

		result.width -= horizScrollbar;
		result.height -= vertScrollbar;
	  }

	  return getClientRect(result);
	}

	function getOffsetRectRelativeToArbitraryNode(children, parent) {
	  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  var isIE10 = isIE(10);
	  var isHTML = parent.nodeName === 'HTML';
	  var childrenRect = getBoundingClientRect(children);
	  var parentRect = getBoundingClientRect(parent);
	  var scrollParent = getScrollParent(children);

	  var styles = getStyleComputedProperty(parent);
	  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
	  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

	  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
	  if (fixedPosition && isHTML) {
		parentRect.top = Math.max(parentRect.top, 0);
		parentRect.left = Math.max(parentRect.left, 0);
	  }
	  var offsets = getClientRect({
		top: childrenRect.top - parentRect.top - borderTopWidth,
		left: childrenRect.left - parentRect.left - borderLeftWidth,
		width: childrenRect.width,
		height: childrenRect.height
	  });
	  offsets.marginTop = 0;
	  offsets.marginLeft = 0;

	  // Subtract margins of documentElement in case it's being used as parent
	  // we do this only on HTML because it's the only element that behaves
	  // differently when margins are applied to it. The margins are included in
	  // the box of the documentElement, in the other cases not.
	  if (!isIE10 && isHTML) {
		var marginTop = parseFloat(styles.marginTop, 10);
		var marginLeft = parseFloat(styles.marginLeft, 10);

		offsets.top -= borderTopWidth - marginTop;
		offsets.bottom -= borderTopWidth - marginTop;
		offsets.left -= borderLeftWidth - marginLeft;
		offsets.right -= borderLeftWidth - marginLeft;

		// Attach marginTop and marginLeft because in some circumstances we may need them
		offsets.marginTop = marginTop;
		offsets.marginLeft = marginLeft;
	  }

	  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
		offsets = includeScroll(offsets, parent);
	  }

	  return offsets;
	}

	function getViewportOffsetRectRelativeToArtbitraryNode(element) {
	  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  var html = element.ownerDocument.documentElement;
	  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
	  var width = Math.max(html.clientWidth, window.innerWidth || 0);
	  var height = Math.max(html.clientHeight, window.innerHeight || 0);

	  var scrollTop = !excludeScroll ? getScroll(html) : 0;
	  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

	  var offset = {
		top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
		left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
		width: width,
		height: height
	  };

	  return getClientRect(offset);
	}

	/**
	 * Check if the given element is fixed or is inside a fixed parent
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @argument {Element} customContainer
	 * @returns {Boolean} answer to "isFixed?"
	 */
	function isFixed(element) {
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY' || nodeName === 'HTML') {
		return false;
	  }
	  if (getStyleComputedProperty(element, 'position') === 'fixed') {
		return true;
	  }
	  var parentNode = getParentNode(element);
	  if (!parentNode) {
		return false;
	  }
	  return isFixed(parentNode);
	}

	/**
	 * Finds the first parent of an element that has a transformed property defined
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} first transformed parent or documentElement
	 */

	function getFixedPositionOffsetParent(element) {
	  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
	  if (!element || !element.parentElement || isIE()) {
		return document.documentElement;
	  }
	  var el = element.parentElement;
	  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
		el = el.parentElement;
	  }
	  return el || document.documentElement;
	}

	/**
	 * Computed the boundaries limits and return them
	 * @method
	 * @memberof Popper.Utils
	 * @param {HTMLElement} popper
	 * @param {HTMLElement} reference
	 * @param {number} padding
	 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
	 * @param {Boolean} fixedPosition - Is in fixed position mode
	 * @returns {Object} Coordinates of the boundaries
	 */
	function getBoundaries(popper, reference, padding, boundariesElement) {
	  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

	  // NOTE: 1 DOM access here

	  var boundaries = { top: 0, left: 0 };
	  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

	  // Handle viewport case
	  if (boundariesElement === 'viewport') {
		boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
	  } else {
		// Handle other cases based on DOM element used as boundaries
		var boundariesNode = void 0;
		if (boundariesElement === 'scrollParent') {
		  boundariesNode = getScrollParent(getParentNode(reference));
		  if (boundariesNode.nodeName === 'BODY') {
			boundariesNode = popper.ownerDocument.documentElement;
		  }
		} else if (boundariesElement === 'window') {
		  boundariesNode = popper.ownerDocument.documentElement;
		} else {
		  boundariesNode = boundariesElement;
		}

		var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

		// In case of HTML, we need a different computation
		if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
		  var _getWindowSizes = getWindowSizes(popper.ownerDocument),
			  height = _getWindowSizes.height,
			  width = _getWindowSizes.width;

		  boundaries.top += offsets.top - offsets.marginTop;
		  boundaries.bottom = height + offsets.top;
		  boundaries.left += offsets.left - offsets.marginLeft;
		  boundaries.right = width + offsets.left;
		} else {
		  // for all the other DOM elements, this one is good
		  boundaries = offsets;
		}
	  }

	  // Add paddings
	  padding = padding || 0;
	  var isPaddingNumber = typeof padding === 'number';
	  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
	  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
	  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
	  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

	  return boundaries;
	}

	function getArea(_ref) {
	  var width = _ref.width,
		  height = _ref.height;

	  return width * height;
	}

	/**
	 * Utility used to transform the `auto` placement to the placement with more
	 * available space.
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
	  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

	  if (placement.indexOf('auto') === -1) {
		return placement;
	  }

	  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

	  var rects = {
		top: {
		  width: boundaries.width,
		  height: refRect.top - boundaries.top
		},
		right: {
		  width: boundaries.right - refRect.right,
		  height: boundaries.height
		},
		bottom: {
		  width: boundaries.width,
		  height: boundaries.bottom - refRect.bottom
		},
		left: {
		  width: refRect.left - boundaries.left,
		  height: boundaries.height
		}
	  };

	  var sortedAreas = Object.keys(rects).map(function (key) {
		return _extends({
		  key: key
		}, rects[key], {
		  area: getArea(rects[key])
		});
	  }).sort(function (a, b) {
		return b.area - a.area;
	  });

	  var filteredAreas = sortedAreas.filter(function (_ref2) {
		var width = _ref2.width,
			height = _ref2.height;
		return width >= popper.clientWidth && height >= popper.clientHeight;
	  });

	  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

	  var variation = placement.split('-')[1];

	  return computedPlacement + (variation ? '-' + variation : '');
	}

	/**
	 * Get offsets to the reference element
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} state
	 * @param {Element} popper - the popper element
	 * @param {Element} reference - the reference element (the popper will be relative to this)
	 * @param {Element} fixedPosition - is in fixed position mode
	 * @returns {Object} An object containing the offsets which will be applied to the popper
	 */
	function getReferenceOffsets(state, popper, reference) {
	  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
	  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
	}

	/**
	 * Get the outer sizes of the given element (offset size + margins)
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Object} object containing width and height properties
	 */
	function getOuterSizes(element) {
	  var window = element.ownerDocument.defaultView;
	  var styles = window.getComputedStyle(element);
	  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
	  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
	  var result = {
		width: element.offsetWidth + y,
		height: element.offsetHeight + x
	  };
	  return result;
	}

	/**
	 * Get the opposite placement of the given one
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement
	 * @returns {String} flipped placement
	 */
	function getOppositePlacement(placement) {
	  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
	  return placement.replace(/left|right|bottom|top/g, function (matched) {
		return hash[matched];
	  });
	}

	/**
	 * Get offsets to the popper
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} position - CSS position the Popper will get applied
	 * @param {HTMLElement} popper - the popper element
	 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
	 * @param {String} placement - one of the valid placement options
	 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
	 */
	function getPopperOffsets(popper, referenceOffsets, placement) {
	  placement = placement.split('-')[0];

	  // Get popper node sizes
	  var popperRect = getOuterSizes(popper);

	  // Add position, width and height to our offsets object
	  var popperOffsets = {
		width: popperRect.width,
		height: popperRect.height
	  };

	  // depending by the popper placement we have to compute its offsets slightly differently
	  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
	  var mainSide = isHoriz ? 'top' : 'left';
	  var secondarySide = isHoriz ? 'left' : 'top';
	  var measurement = isHoriz ? 'height' : 'width';
	  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

	  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
	  if (placement === secondarySide) {
		popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
	  } else {
		popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
	  }

	  return popperOffsets;
	}

	/**
	 * Mimics the `find` method of Array
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Array} arr
	 * @argument prop
	 * @argument value
	 * @returns index or -1
	 */
	function find(arr, check) {
	  // use native find if supported
	  if (Array.prototype.find) {
		return arr.find(check);
	  }

	  // use `filter` to obtain the same behavior of `find`
	  return arr.filter(check)[0];
	}

	/**
	 * Return the index of the matching object
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Array} arr
	 * @argument prop
	 * @argument value
	 * @returns index or -1
	 */
	function findIndex(arr, prop, value) {
	  // use native findIndex if supported
	  if (Array.prototype.findIndex) {
		return arr.findIndex(function (cur) {
		  return cur[prop] === value;
		});
	  }

	  // use `find` + `indexOf` if `findIndex` isn't supported
	  var match = find(arr, function (obj) {
		return obj[prop] === value;
	  });
	  return arr.indexOf(match);
	}

	/**
	 * Loop trough the list of modifiers and run them in order,
	 * each of them will then edit the data object.
	 * @method
	 * @memberof Popper.Utils
	 * @param {dataObject} data
	 * @param {Array} modifiers
	 * @param {String} ends - Optional modifier name used as stopper
	 * @returns {dataObject}
	 */
	function runModifiers(modifiers, data, ends) {
	  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

	  modifiersToRun.forEach(function (modifier) {
		if (modifier['function']) {
		  // eslint-disable-line dot-notation
		  console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
		}
		var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
		if (modifier.enabled && isFunction(fn)) {
		  // Add properties to offsets to make them a complete clientRect object
		  // we do this before each modifier to make sure the previous one doesn't
		  // mess with these values
		  data.offsets.popper = getClientRect(data.offsets.popper);
		  data.offsets.reference = getClientRect(data.offsets.reference);

		  data = fn(data, modifier);
		}
	  });

	  return data;
	}

	/**
	 * Updates the position of the popper, computing the new offsets and applying
	 * the new style.<br />
	 * Prefer `scheduleUpdate` over `update` because of performance reasons.
	 * @method
	 * @memberof Popper
	 */
	function update() {
	  // if popper is destroyed, don't perform any further update
	  if (this.state.isDestroyed) {
		return;
	  }

	  var data = {
		instance: this,
		styles: {},
		arrowStyles: {},
		attributes: {},
		flipped: false,
		offsets: {}
	  };

	  // compute reference element offsets
	  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

	  // compute auto placement, store placement inside the data object,
	  // modifiers will be able to edit `placement` if needed
	  // and refer to originalPlacement to know the original value
	  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

	  // store the computed placement inside `originalPlacement`
	  data.originalPlacement = data.placement;

	  data.positionFixed = this.options.positionFixed;

	  // compute the popper offsets
	  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

	  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

	  // run the modifiers
	  data = runModifiers(this.modifiers, data);

	  // the first `update` will call `onCreate` callback
	  // the other ones will call `onUpdate` callback
	  if (!this.state.isCreated) {
		this.state.isCreated = true;
		this.options.onCreate(data);
	  } else {
		this.options.onUpdate(data);
	  }
	}

	/**
	 * Helper used to know if the given modifier is enabled.
	 * @method
	 * @memberof Popper.Utils
	 * @returns {Boolean}
	 */
	function isModifierEnabled(modifiers, modifierName) {
	  return modifiers.some(function (_ref) {
		var name = _ref.name,
			enabled = _ref.enabled;
		return enabled && name === modifierName;
	  });
	}

	/**
	 * Get the prefixed supported property name
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} property (camelCase)
	 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
	 */
	function getSupportedPropertyName(property) {
	  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
	  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

	  for (var i = 0; i < prefixes.length; i++) {
		var prefix = prefixes[i];
		var toCheck = prefix ? '' + prefix + upperProp : property;
		if (typeof document.body.style[toCheck] !== 'undefined') {
		  return toCheck;
		}
	  }
	  return null;
	}

	/**
	 * Destroys the popper.
	 * @method
	 * @memberof Popper
	 */
	function destroy() {
	  this.state.isDestroyed = true;

	  // touch DOM only if `applyStyle` modifier is enabled
	  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
		this.popper.removeAttribute('x-placement');
		this.popper.style.position = '';
		this.popper.style.top = '';
		this.popper.style.left = '';
		this.popper.style.right = '';
		this.popper.style.bottom = '';
		this.popper.style.willChange = '';
		this.popper.style[getSupportedPropertyName('transform')] = '';
	  }

	  this.disableEventListeners();

	  // remove the popper if user explicity asked for the deletion on destroy
	  // do not use `remove` because IE11 doesn't support it
	  if (this.options.removeOnDestroy) {
		this.popper.parentNode.removeChild(this.popper);
	  }
	  return this;
	}

	/**
	 * Get the window associated with the element
	 * @argument {Element} element
	 * @returns {Window}
	 */
	function getWindow(element) {
	  var ownerDocument = element.ownerDocument;
	  return ownerDocument ? ownerDocument.defaultView : window;
	}

	function attachToScrollParents(scrollParent, event, callback, scrollParents) {
	  var isBody = scrollParent.nodeName === 'BODY';
	  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
	  target.addEventListener(event, callback, { passive: true });

	  if (!isBody) {
		attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
	  }
	  scrollParents.push(target);
	}

	/**
	 * Setup needed event listeners used to update the popper position
	 * @method
	 * @memberof Popper.Utils
	 * @private
	 */
	function setupEventListeners(reference, options, state, updateBound) {
	  // Resize event listener on window
	  state.updateBound = updateBound;
	  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

	  // Scroll event listener on scroll parents
	  var scrollElement = getScrollParent(reference);
	  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
	  state.scrollElement = scrollElement;
	  state.eventsEnabled = true;

	  return state;
	}

	/**
	 * It will add resize/scroll events and start recalculating
	 * position of the popper element when they are triggered.
	 * @method
	 * @memberof Popper
	 */
	function enableEventListeners() {
	  if (!this.state.eventsEnabled) {
		this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
	  }
	}

	/**
	 * Remove event listeners used to update the popper position
	 * @method
	 * @memberof Popper.Utils
	 * @private
	 */
	function removeEventListeners(reference, state) {
	  // Remove resize event listener on window
	  getWindow(reference).removeEventListener('resize', state.updateBound);

	  // Remove scroll event listener on scroll parents
	  state.scrollParents.forEach(function (target) {
		target.removeEventListener('scroll', state.updateBound);
	  });

	  // Reset state
	  state.updateBound = null;
	  state.scrollParents = [];
	  state.scrollElement = null;
	  state.eventsEnabled = false;
	  return state;
	}

	/**
	 * It will remove resize/scroll events and won't recalculate popper position
	 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
	 * unless you call `update` method manually.
	 * @method
	 * @memberof Popper
	 */
	function disableEventListeners() {
	  if (this.state.eventsEnabled) {
		cancelAnimationFrame(this.scheduleUpdate);
		this.state = removeEventListeners(this.reference, this.state);
	  }
	}

	/**
	 * Tells if a given input is a number
	 * @method
	 * @memberof Popper.Utils
	 * @param {*} input to check
	 * @return {Boolean}
	 */
	function isNumeric(n) {
	  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
	}

	/**
	 * Set the style to the given popper
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element - Element to apply the style to
	 * @argument {Object} styles
	 * Object with a list of properties and values which will be applied to the element
	 */
	function setStyles(element, styles) {
	  Object.keys(styles).forEach(function (prop) {
		var unit = '';
		// add unit if the value is numeric and is one of the following
		if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
		  unit = 'px';
		}
		element.style[prop] = styles[prop] + unit;
	  });
	}

	/**
	 * Set the attributes to the given popper
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element - Element to apply the attributes to
	 * @argument {Object} styles
	 * Object with a list of properties and values which will be applied to the element
	 */
	function setAttributes(element, attributes) {
	  Object.keys(attributes).forEach(function (prop) {
		var value = attributes[prop];
		if (value !== false) {
		  element.setAttribute(prop, attributes[prop]);
		} else {
		  element.removeAttribute(prop);
		}
	  });
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} data.styles - List of style properties - values to apply to popper element
	 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The same data object
	 */
	function applyStyle(data) {
	  // any property present in `data.styles` will be applied to the popper,
	  // in this way we can make the 3rd party modifiers add custom styles to it
	  // Be aware, modifiers could override the properties defined in the previous
	  // lines of this modifier!
	  setStyles(data.instance.popper, data.styles);

	  // any property present in `data.attributes` will be applied to the popper,
	  // they will be set as HTML attributes of the element
	  setAttributes(data.instance.popper, data.attributes);

	  // if arrowElement is defined and arrowStyles has some properties
	  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
		setStyles(data.arrowElement, data.arrowStyles);
	  }

	  return data;
	}

	/**
	 * Set the x-placement attribute before everything else because it could be used
	 * to add margins to the popper margins needs to be calculated to get the
	 * correct popper offsets.
	 * @method
	 * @memberof Popper.modifiers
	 * @param {HTMLElement} reference - The reference element used to position the popper
	 * @param {HTMLElement} popper - The HTML element used as popper
	 * @param {Object} options - Popper.js options
	 */
	function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
	  // compute reference element offsets
	  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

	  // compute auto placement, store placement inside the data object,
	  // modifiers will be able to edit `placement` if needed
	  // and refer to originalPlacement to know the original value
	  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

	  popper.setAttribute('x-placement', placement);

	  // Apply `position` to popper before anything else because
	  // without the position applied we can't guarantee correct computations
	  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

	  return options;
	}

	/**
	 * @function
	 * @memberof Popper.Utils
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
	 * @returns {Object} The popper's position offsets rounded
	 *
	 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
	 * good as it can be within reason.
	 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
	 *
	 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
	 * as well on High DPI screens).
	 *
	 * Firefox prefers no rounding for positioning and does not have blurriness on
	 * high DPI screens.
	 *
	 * Only horizontal placement and left/right values need to be considered.
	 */
	function getRoundedOffsets(data, shouldRound) {
	  var _data$offsets = data.offsets,
		  popper = _data$offsets.popper,
		  reference = _data$offsets.reference;
	  var round = Math.round,
		  floor = Math.floor;

	  var noRound = function noRound(v) {
		return v;
	  };

	  var referenceWidth = round(reference.width);
	  var popperWidth = round(popper.width);

	  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
	  var isVariation = data.placement.indexOf('-') !== -1;
	  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
	  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

	  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
	  var verticalToInteger = !shouldRound ? noRound : round;

	  return {
		left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
		top: verticalToInteger(popper.top),
		bottom: verticalToInteger(popper.bottom),
		right: horizontalToInteger(popper.right)
	  };
	}

	var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function computeStyle(data, options) {
	  var x = options.x,
		  y = options.y;
	  var popper = data.offsets.popper;

	  // Remove this legacy support in Popper.js v2

	  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
		return modifier.name === 'applyStyle';
	  }).gpuAcceleration;
	  if (legacyGpuAccelerationOption !== undefined) {
		console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
	  }
	  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

	  var offsetParent = getOffsetParent(data.instance.popper);
	  var offsetParentRect = getBoundingClientRect(offsetParent);

	  // Styles
	  var styles = {
		position: popper.position
	  };

	  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

	  var sideA = x === 'bottom' ? 'top' : 'bottom';
	  var sideB = y === 'right' ? 'left' : 'right';

	  // if gpuAcceleration is set to `true` and transform is supported,
	  //  we use `translate3d` to apply the position to the popper we
	  // automatically use the supported prefixed version if needed
	  var prefixedProperty = getSupportedPropertyName('transform');

	  // now, let's make a step back and look at this code closely (wtf?)
	  // If the content of the popper grows once it's been positioned, it
	  // may happen that the popper gets misplaced because of the new content
	  // overflowing its reference element
	  // To avoid this problem, we provide two options (x and y), which allow
	  // the consumer to define the offset origin.
	  // If we position a popper on top of a reference element, we can set
	  // `x` to `top` to make the popper grow towards its top instead of
	  // its bottom.
	  var left = void 0,
		  top = void 0;
	  if (sideA === 'bottom') {
		// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
		// and not the bottom of the html element
		if (offsetParent.nodeName === 'HTML') {
		  top = -offsetParent.clientHeight + offsets.bottom;
		} else {
		  top = -offsetParentRect.height + offsets.bottom;
		}
	  } else {
		top = offsets.top;
	  }
	  if (sideB === 'right') {
		if (offsetParent.nodeName === 'HTML') {
		  left = -offsetParent.clientWidth + offsets.right;
		} else {
		  left = -offsetParentRect.width + offsets.right;
		}
	  } else {
		left = offsets.left;
	  }
	  if (gpuAcceleration && prefixedProperty) {
		styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
		styles[sideA] = 0;
		styles[sideB] = 0;
		styles.willChange = 'transform';
	  } else {
		// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
		var invertTop = sideA === 'bottom' ? -1 : 1;
		var invertLeft = sideB === 'right' ? -1 : 1;
		styles[sideA] = top * invertTop;
		styles[sideB] = left * invertLeft;
		styles.willChange = sideA + ', ' + sideB;
	  }

	  // Attributes
	  var attributes = {
		'x-placement': data.placement
	  };

	  // Update `data` attributes, styles and arrowStyles
	  data.attributes = _extends({}, attributes, data.attributes);
	  data.styles = _extends({}, styles, data.styles);
	  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

	  return data;
	}

	/**
	 * Helper used to know if the given modifier depends from another one.<br />
	 * It checks if the needed modifier is listed and enabled.
	 * @method
	 * @memberof Popper.Utils
	 * @param {Array} modifiers - list of modifiers
	 * @param {String} requestingName - name of requesting modifier
	 * @param {String} requestedName - name of requested modifier
	 * @returns {Boolean}
	 */
	function isModifierRequired(modifiers, requestingName, requestedName) {
	  var requesting = find(modifiers, function (_ref) {
		var name = _ref.name;
		return name === requestingName;
	  });

	  var isRequired = !!requesting && modifiers.some(function (modifier) {
		return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
	  });

	  if (!isRequired) {
		var _requesting = '`' + requestingName + '`';
		var requested = '`' + requestedName + '`';
		console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
	  }
	  return isRequired;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function arrow(data, options) {
	  var _data$offsets$arrow;

	  // arrow depends on keepTogether in order to work
	  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
		return data;
	  }

	  var arrowElement = options.element;

	  // if arrowElement is a string, suppose it's a CSS selector
	  if (typeof arrowElement === 'string') {
		arrowElement = data.instance.popper.querySelector(arrowElement);

		// if arrowElement is not found, don't run the modifier
		if (!arrowElement) {
		  return data;
		}
	  } else {
		// if the arrowElement isn't a query selector we must check that the
		// provided DOM node is child of its popper node
		if (!data.instance.popper.contains(arrowElement)) {
		  console.warn('WARNING: `arrow.element` must be child of its popper element!');
		  return data;
		}
	  }

	  var placement = data.placement.split('-')[0];
	  var _data$offsets = data.offsets,
		  popper = _data$offsets.popper,
		  reference = _data$offsets.reference;

	  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

	  var len = isVertical ? 'height' : 'width';
	  var sideCapitalized = isVertical ? 'Top' : 'Left';
	  var side = sideCapitalized.toLowerCase();
	  var altSide = isVertical ? 'left' : 'top';
	  var opSide = isVertical ? 'bottom' : 'right';
	  var arrowElementSize = getOuterSizes(arrowElement)[len];

	  //
	  // extends keepTogether behavior making sure the popper and its
	  // reference have enough pixels in conjunction
	  //

	  // top/left side
	  if (reference[opSide] - arrowElementSize < popper[side]) {
		data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
	  }
	  // bottom/right side
	  if (reference[side] + arrowElementSize > popper[opSide]) {
		data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
	  }
	  data.offsets.popper = getClientRect(data.offsets.popper);

	  // compute center of the popper
	  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

	  // Compute the sideValue using the updated popper offsets
	  // take popper margin in account because we don't have this info available
	  var css = getStyleComputedProperty(data.instance.popper);
	  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
	  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
	  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

	  // prevent arrowElement from being placed not contiguously to its popper
	  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

	  data.arrowElement = arrowElement;
	  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

	  return data;
	}

	/**
	 * Get the opposite placement variation of the given one
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement variation
	 * @returns {String} flipped placement variation
	 */
	function getOppositeVariation(variation) {
	  if (variation === 'end') {
		return 'start';
	  } else if (variation === 'start') {
		return 'end';
	  }
	  return variation;
	}

	/**
	 * List of accepted placements to use as values of the `placement` option.<br />
	 * Valid placements are:
	 * - `auto`
	 * - `top`
	 * - `right`
	 * - `bottom`
	 * - `left`
	 *
	 * Each placement can have a variation from this list:
	 * - `-start`
	 * - `-end`
	 *
	 * Variations are interpreted easily if you think of them as the left to right
	 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
	 * is right.<br />
	 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
	 *
	 * Some valid examples are:
	 * - `top-end` (on top of reference, right aligned)
	 * - `right-start` (on right of reference, top aligned)
	 * - `bottom` (on bottom, centered)
	 * - `auto-end` (on the side with more space available, alignment depends by placement)
	 *
	 * @static
	 * @type {Array}
	 * @enum {String}
	 * @readonly
	 * @method placements
	 * @memberof Popper
	 */
	var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

	// Get rid of `auto` `auto-start` and `auto-end`
	var validPlacements = placements.slice(3);

	/**
	 * Given an initial placement, returns all the subsequent placements
	 * clockwise (or counter-clockwise).
	 *
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement - A valid placement (it accepts variations)
	 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
	 * @returns {Array} placements including their variations
	 */
	function clockwise(placement) {
	  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  var index = validPlacements.indexOf(placement);
	  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
	  return counter ? arr.reverse() : arr;
	}

	var BEHAVIORS = {
	  FLIP: 'flip',
	  CLOCKWISE: 'clockwise',
	  COUNTERCLOCKWISE: 'counterclockwise'
	};

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function flip(data, options) {
	  // if `inner` modifier is enabled, we can't use the `flip` modifier
	  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
		return data;
	  }

	  if (data.flipped && data.placement === data.originalPlacement) {
		// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
		return data;
	  }

	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

	  var placement = data.placement.split('-')[0];
	  var placementOpposite = getOppositePlacement(placement);
	  var variation = data.placement.split('-')[1] || '';

	  var flipOrder = [];

	  switch (options.behavior) {
		case BEHAVIORS.FLIP:
		  flipOrder = [placement, placementOpposite];
		  break;
		case BEHAVIORS.CLOCKWISE:
		  flipOrder = clockwise(placement);
		  break;
		case BEHAVIORS.COUNTERCLOCKWISE:
		  flipOrder = clockwise(placement, true);
		  break;
		default:
		  flipOrder = options.behavior;
	  }

	  flipOrder.forEach(function (step, index) {
		if (placement !== step || flipOrder.length === index + 1) {
		  return data;
		}

		placement = data.placement.split('-')[0];
		placementOpposite = getOppositePlacement(placement);

		var popperOffsets = data.offsets.popper;
		var refOffsets = data.offsets.reference;

		// using floor because the reference offsets may contain decimals we are not going to consider here
		var floor = Math.floor;
		var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

		var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
		var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
		var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
		var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

		var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

		// flip the variation if required
		var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
		var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

		if (overlapsRef || overflowsBoundaries || flippedVariation) {
		  // this boolean to detect any flip loop
		  data.flipped = true;

		  if (overlapsRef || overflowsBoundaries) {
			placement = flipOrder[index + 1];
		  }

		  if (flippedVariation) {
			variation = getOppositeVariation(variation);
		  }

		  data.placement = placement + (variation ? '-' + variation : '');

		  // this object contains `position`, we want to preserve it along with
		  // any additional property we may add in the future
		  data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

		  data = runModifiers(data.instance.modifiers, data, 'flip');
		}
	  });
	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function keepTogether(data) {
	  var _data$offsets = data.offsets,
		  popper = _data$offsets.popper,
		  reference = _data$offsets.reference;

	  var placement = data.placement.split('-')[0];
	  var floor = Math.floor;
	  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	  var side = isVertical ? 'right' : 'bottom';
	  var opSide = isVertical ? 'left' : 'top';
	  var measurement = isVertical ? 'width' : 'height';

	  if (popper[side] < floor(reference[opSide])) {
		data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
	  }
	  if (popper[opSide] > floor(reference[side])) {
		data.offsets.popper[opSide] = floor(reference[side]);
	  }

	  return data;
	}

	/**
	 * Converts a string containing value + unit into a px value number
	 * @function
	 * @memberof {modifiers~offset}
	 * @private
	 * @argument {String} str - Value + unit string
	 * @argument {String} measurement - `height` or `width`
	 * @argument {Object} popperOffsets
	 * @argument {Object} referenceOffsets
	 * @returns {Number|String}
	 * Value in pixels, or original string if no values were extracted
	 */
	function toValue(str, measurement, popperOffsets, referenceOffsets) {
	  // separate value from unit
	  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
	  var value = +split[1];
	  var unit = split[2];

	  // If it's not a number it's an operator, I guess
	  if (!value) {
		return str;
	  }

	  if (unit.indexOf('%') === 0) {
		var element = void 0;
		switch (unit) {
		  case '%p':
			element = popperOffsets;
			break;
		  case '%':
		  case '%r':
		  default:
			element = referenceOffsets;
		}

		var rect = getClientRect(element);
		return rect[measurement] / 100 * value;
	  } else if (unit === 'vh' || unit === 'vw') {
		// if is a vh or vw, we calculate the size based on the viewport
		var size = void 0;
		if (unit === 'vh') {
		  size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
		} else {
		  size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
		}
		return size / 100 * value;
	  } else {
		// if is an explicit pixel unit, we get rid of the unit and keep the value
		// if is an implicit unit, it's px, and we return just the value
		return value;
	  }
	}

	/**
	 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
	 * @function
	 * @memberof {modifiers~offset}
	 * @private
	 * @argument {String} offset
	 * @argument {Object} popperOffsets
	 * @argument {Object} referenceOffsets
	 * @argument {String} basePlacement
	 * @returns {Array} a two cells array with x and y offsets in numbers
	 */
	function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
	  var offsets = [0, 0];

	  // Use height if placement is left or right and index is 0 otherwise use width
	  // in this way the first offset will use an axis and the second one
	  // will use the other one
	  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

	  // Split the offset string to obtain a list of values and operands
	  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
	  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
		return frag.trim();
	  });

	  // Detect if the offset string contains a pair of values or a single one
	  // they could be separated by comma or space
	  var divider = fragments.indexOf(find(fragments, function (frag) {
		return frag.search(/,|\s/) !== -1;
	  }));

	  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
		console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
	  }

	  // If divider is found, we divide the list of values and operands to divide
	  // them by ofset X and Y.
	  var splitRegex = /\s*,\s*|\s+/;
	  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

	  // Convert the values with units to absolute pixels to allow our computations
	  ops = ops.map(function (op, index) {
		// Most of the units rely on the orientation of the popper
		var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
		var mergeWithPrevious = false;
		return op
		// This aggregates any `+` or `-` sign that aren't considered operators
		// e.g.: 10 + +5 => [10, +, +5]
		.reduce(function (a, b) {
		  if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
			a[a.length - 1] = b;
			mergeWithPrevious = true;
			return a;
		  } else if (mergeWithPrevious) {
			a[a.length - 1] += b;
			mergeWithPrevious = false;
			return a;
		  } else {
			return a.concat(b);
		  }
		}, [])
		// Here we convert the string values into number values (in px)
		.map(function (str) {
		  return toValue(str, measurement, popperOffsets, referenceOffsets);
		});
	  });

	  // Loop trough the offsets arrays and execute the operations
	  ops.forEach(function (op, index) {
		op.forEach(function (frag, index2) {
		  if (isNumeric(frag)) {
			offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
		  }
		});
	  });
	  return offsets;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @argument {Number|String} options.offset=0
	 * The offset value as described in the modifier description
	 * @returns {Object} The data object, properly modified
	 */
	function offset(data, _ref) {
	  var offset = _ref.offset;
	  var placement = data.placement,
		  _data$offsets = data.offsets,
		  popper = _data$offsets.popper,
		  reference = _data$offsets.reference;

	  var basePlacement = placement.split('-')[0];

	  var offsets = void 0;
	  if (isNumeric(+offset)) {
		offsets = [+offset, 0];
	  } else {
		offsets = parseOffset(offset, popper, reference, basePlacement);
	  }

	  if (basePlacement === 'left') {
		popper.top += offsets[0];
		popper.left -= offsets[1];
	  } else if (basePlacement === 'right') {
		popper.top += offsets[0];
		popper.left += offsets[1];
	  } else if (basePlacement === 'top') {
		popper.left += offsets[0];
		popper.top -= offsets[1];
	  } else if (basePlacement === 'bottom') {
		popper.left += offsets[0];
		popper.top += offsets[1];
	  }

	  data.popper = popper;
	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function preventOverflow(data, options) {
	  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

	  // If offsetParent is the reference element, we really want to
	  // go one step up and use the next offsetParent as reference to
	  // avoid to make this modifier completely useless and look like broken
	  if (data.instance.reference === boundariesElement) {
		boundariesElement = getOffsetParent(boundariesElement);
	  }

	  // NOTE: DOM access here
	  // resets the popper's position so that the document size can be calculated excluding
	  // the size of the popper element itself
	  var transformProp = getSupportedPropertyName('transform');
	  var popperStyles = data.instance.popper.style; // assignment to help minification
	  var top = popperStyles.top,
		  left = popperStyles.left,
		  transform = popperStyles[transformProp];

	  popperStyles.top = '';
	  popperStyles.left = '';
	  popperStyles[transformProp] = '';

	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

	  // NOTE: DOM access here
	  // restores the original style properties after the offsets have been computed
	  popperStyles.top = top;
	  popperStyles.left = left;
	  popperStyles[transformProp] = transform;

	  options.boundaries = boundaries;

	  var order = options.priority;
	  var popper = data.offsets.popper;

	  var check = {
		primary: function primary(placement) {
		  var value = popper[placement];
		  if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
			value = Math.max(popper[placement], boundaries[placement]);
		  }
		  return defineProperty({}, placement, value);
		},
		secondary: function secondary(placement) {
		  var mainSide = placement === 'right' ? 'left' : 'top';
		  var value = popper[mainSide];
		  if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
			value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
		  }
		  return defineProperty({}, mainSide, value);
		}
	  };

	  order.forEach(function (placement) {
		var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
		popper = _extends({}, popper, check[side](placement));
	  });

	  data.offsets.popper = popper;

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function shift(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var shiftvariation = placement.split('-')[1];

	  // if shift shiftvariation is specified, run the modifier
	  if (shiftvariation) {
		var _data$offsets = data.offsets,
			reference = _data$offsets.reference,
			popper = _data$offsets.popper;

		var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
		var side = isVertical ? 'left' : 'top';
		var measurement = isVertical ? 'width' : 'height';

		var shiftOffsets = {
		  start: defineProperty({}, side, reference[side]),
		  end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
		};

		data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
	  }

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function hide(data) {
	  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
		return data;
	  }

	  var refRect = data.offsets.reference;
	  var bound = find(data.instance.modifiers, function (modifier) {
		return modifier.name === 'preventOverflow';
	  }).boundaries;

	  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
		// Avoid unnecessary DOM access if visibility hasn't changed
		if (data.hide === true) {
		  return data;
		}

		data.hide = true;
		data.attributes['x-out-of-boundaries'] = '';
	  } else {
		// Avoid unnecessary DOM access if visibility hasn't changed
		if (data.hide === false) {
		  return data;
		}

		data.hide = false;
		data.attributes['x-out-of-boundaries'] = false;
	  }

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function inner(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var _data$offsets = data.offsets,
		  popper = _data$offsets.popper,
		  reference = _data$offsets.reference;

	  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

	  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

	  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

	  data.placement = getOppositePlacement(placement);
	  data.offsets.popper = getClientRect(popper);

	  return data;
	}

	/**
	 * Modifier function, each modifier can have a function of this type assigned
	 * to its `fn` property.<br />
	 * These functions will be called on each update, this means that you must
	 * make sure they are performant enough to avoid performance bottlenecks.
	 *
	 * @function ModifierFn
	 * @argument {dataObject} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {dataObject} The data object, properly modified
	 */

	/**
	 * Modifiers are plugins used to alter the behavior of your poppers.<br />
	 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
	 * needed by the library.
	 *
	 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
	 * All the other properties are configurations that could be tweaked.
	 * @namespace modifiers
	 */
	var modifiers = {
	  /**
	   * Modifier used to shift the popper on the start or end of its reference
	   * element.<br />
	   * It will read the variation of the `placement` property.<br />
	   * It can be one either `-end` or `-start`.
	   * @memberof modifiers
	   * @inner
	   */
	  shift: {
		/** @prop {number} order=100 - Index used to define the order of execution */
		order: 100,
		/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
		enabled: true,
		/** @prop {ModifierFn} */
		fn: shift
	  },

	  /**
	   * The `offset` modifier can shift your popper on both its axis.
	   *
	   * It accepts the following units:
	   * - `px` or unit-less, interpreted as pixels
	   * - `%` or `%r`, percentage relative to the length of the reference element
	   * - `%p`, percentage relative to the length of the popper element
	   * - `vw`, CSS viewport width unit
	   * - `vh`, CSS viewport height unit
	   *
	   * For length is intended the main axis relative to the placement of the popper.<br />
	   * This means that if the placement is `top` or `bottom`, the length will be the
	   * `width`. In case of `left` or `right`, it will be the `height`.
	   *
	   * You can provide a single value (as `Number` or `String`), or a pair of values
	   * as `String` divided by a comma or one (or more) white spaces.<br />
	   * The latter is a deprecated method because it leads to confusion and will be
	   * removed in v2.<br />
	   * Additionally, it accepts additions and subtractions between different units.
	   * Note that multiplications and divisions aren't supported.
	   *
	   * Valid examples are:
	   * ```
	   * 10
	   * '10%'
	   * '10, 10'
	   * '10%, 10'
	   * '10 + 10%'
	   * '10 - 5vh + 3%'
	   * '-10px + 5vh, 5px - 6%'
	   * ```
	   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
	   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
	   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  offset: {
		/** @prop {number} order=200 - Index used to define the order of execution */
		order: 200,
		/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
		enabled: true,
		/** @prop {ModifierFn} */
		fn: offset,
		/** @prop {Number|String} offset=0
		 * The offset value as described in the modifier description
		 */
		offset: 0
	  },

	  /**
	   * Modifier used to prevent the popper from being positioned outside the boundary.
	   *
	   * A scenario exists where the reference itself is not within the boundaries.<br />
	   * We can say it has "escaped the boundaries"  or just "escaped".<br />
	   * In this case we need to decide whether the popper should either:
	   *
	   * - detach from the reference and remain "trapped" in the boundaries, or
	   * - if it should ignore the boundary and "escape with its reference"
	   *
	   * When `escapeWithReference` is set to`true` and reference is completely
	   * outside its boundaries, the popper will overflow (or completely leave)
	   * the boundaries in order to remain attached to the edge of the reference.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  preventOverflow: {
		/** @prop {number} order=300 - Index used to define the order of execution */
		order: 300,
		/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
		enabled: true,
		/** @prop {ModifierFn} */
		fn: preventOverflow,
		/**
		 * @prop {Array} [priority=['left','right','top','bottom']]
		 * Popper will try to prevent overflow following these priorities by default,
		 * then, it could overflow on the left and on top of the `boundariesElement`
		 */
		priority: ['left', 'right', 'top', 'bottom'],
		/**
		 * @prop {number} padding=5
		 * Amount of pixel used to define a minimum distance between the boundaries
		 * and the popper. This makes sure the popper always has a little padding
		 * between the edges of its container
		 */
		padding: 5,
		/**
		 * @prop {String|HTMLElement} boundariesElement='scrollParent'
		 * Boundaries used by the modifier. Can be `scrollParent`, `window`,
		 * `viewport` or any DOM element.
		 */
		boundariesElement: 'scrollParent'
	  },

	  /**
	   * Modifier used to make sure the reference and its popper stay near each other
	   * without leaving any gap between the two. Especially useful when the arrow is
	   * enabled and you want to ensure that it points to its reference element.
	   * It cares only about the first axis. You can still have poppers with margin
	   * between the popper and its reference element.
	   * @memberof modifiers
	   * @inner
	   */
	  keepTogether: {
		/** @prop {number} order=400 - Index used to define the order of execution */
		order: 400,
		/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
		enabled: true,
		/** @prop {ModifierFn} */
		fn: keepTogether
	  },

	  /**
	   * This modifier is used to move the `arrowElement` of the popper to make
	   * sure it is positioned between the reference element and its popper element.
	   * It will read the outer size of the `arrowElement` node to detect how many
	   * pixels of conjunction are needed.
	   *
	   * It has no effect if no `arrowElement` is provided.
	   * @memberof modifiers
	   * @inner
	   */
	  arrow: {
		/** @prop {number} order=500 - Index used to define the order of execution */
		order: 500,
		/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
		enabled: true,
		/** @prop {ModifierFn} */
		fn: arrow,
		/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
		element: '[x-arrow]'
	  },

	  /**
	   * Modifier used to flip the popper's placement when it starts to overlap its
	   * reference element.
	   *
	   * Requires the `preventOverflow` modifier before it in order to work.
	   *
	   * **NOTE:** this modifier will interrupt the current update cycle and will
	   * restart it if it detects the need to flip the placement.
	   * @memberof modifiers
	   * @inner
	   */
	  flip: {
		/** @prop {number} order=600 - Index used to define the order of execution */
		order: 600,
		/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
		enabled: true,
		/** @prop {ModifierFn} */
		fn: flip,
		/**
		 * @prop {String|Array} behavior='flip'
		 * The behavior used to change the popper's placement. It can be one of
		 * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
		 * placements (with optional variations)
		 */
		behavior: 'flip',
		/**
		 * @prop {number} padding=5
		 * The popper will flip if it hits the edges of the `boundariesElement`
		 */
		padding: 5,
		/**
		 * @prop {String|HTMLElement} boundariesElement='viewport'
		 * The element which will define the boundaries of the popper position.
		 * The popper will never be placed outside of the defined boundaries
		 * (except if `keepTogether` is enabled)
		 */
		boundariesElement: 'viewport'
	  },

	  /**
	   * Modifier used to make the popper flow toward the inner of the reference element.
	   * By default, when this modifier is disabled, the popper will be placed outside
	   * the reference element.
	   * @memberof modifiers
	   * @inner
	   */
	  inner: {
		/** @prop {number} order=700 - Index used to define the order of execution */
		order: 700,
		/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
		enabled: false,
		/** @prop {ModifierFn} */
		fn: inner
	  },

	  /**
	   * Modifier used to hide the popper when its reference element is outside of the
	   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
	   * be used to hide with a CSS selector the popper when its reference is
	   * out of boundaries.
	   *
	   * Requires the `preventOverflow` modifier before it in order to work.
	   * @memberof modifiers
	   * @inner
	   */
	  hide: {
		/** @prop {number} order=800 - Index used to define the order of execution */
		order: 800,
		/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
		enabled: true,
		/** @prop {ModifierFn} */
		fn: hide
	  },

	  /**
	   * Computes the style that will be applied to the popper element to gets
	   * properly positioned.
	   *
	   * Note that this modifier will not touch the DOM, it just prepares the styles
	   * so that `applyStyle` modifier can apply it. This separation is useful
	   * in case you need to replace `applyStyle` with a custom implementation.
	   *
	   * This modifier has `850` as `order` value to maintain backward compatibility
	   * with previous versions of Popper.js. Expect the modifiers ordering method
	   * to change in future major versions of the library.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  computeStyle: {
		/** @prop {number} order=850 - Index used to define the order of execution */
		order: 850,
		/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
		enabled: true,
		/** @prop {ModifierFn} */
		fn: computeStyle,
		/**
		 * @prop {Boolean} gpuAcceleration=true
		 * If true, it uses the CSS 3D transformation to position the popper.
		 * Otherwise, it will use the `top` and `left` properties
		 */
		gpuAcceleration: true,
		/**
		 * @prop {string} [x='bottom']
		 * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
		 * Change this if your popper should grow in a direction different from `bottom`
		 */
		x: 'bottom',
		/**
		 * @prop {string} [x='left']
		 * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
		 * Change this if your popper should grow in a direction different from `right`
		 */
		y: 'right'
	  },

	  /**
	   * Applies the computed styles to the popper element.
	   *
	   * All the DOM manipulations are limited to this modifier. This is useful in case
	   * you want to integrate Popper.js inside a framework or view library and you
	   * want to delegate all the DOM manipulations to it.
	   *
	   * Note that if you disable this modifier, you must make sure the popper element
	   * has its position set to `absolute` before Popper.js can do its work!
	   *
	   * Just disable this modifier and define your own to achieve the desired effect.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  applyStyle: {
		/** @prop {number} order=900 - Index used to define the order of execution */
		order: 900,
		/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
		enabled: true,
		/** @prop {ModifierFn} */
		fn: applyStyle,
		/** @prop {Function} */
		onLoad: applyStyleOnLoad,
		/**
		 * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
		 * @prop {Boolean} gpuAcceleration=true
		 * If true, it uses the CSS 3D transformation to position the popper.
		 * Otherwise, it will use the `top` and `left` properties
		 */
		gpuAcceleration: undefined
	  }
	};

	/**
	 * The `dataObject` is an object containing all the information used by Popper.js.
	 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
	 * @name dataObject
	 * @property {Object} data.instance The Popper.js instance
	 * @property {String} data.placement Placement applied to popper
	 * @property {String} data.originalPlacement Placement originally defined on init
	 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
	 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
	 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
	 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
	 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
	 * @property {Object} data.boundaries Offsets of the popper boundaries
	 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
	 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
	 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
	 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
	 */

	/**
	 * Default options provided to Popper.js constructor.<br />
	 * These can be overridden using the `options` argument of Popper.js.<br />
	 * To override an option, simply pass an object with the same
	 * structure of the `options` object, as the 3rd argument. For example:
	 * ```
	 * new Popper(ref, pop, {
	 *   modifiers: {
	 *     preventOverflow: { enabled: false }
	 *   }
	 * })
	 * ```
	 * @type {Object}
	 * @static
	 * @memberof Popper
	 */
	var Defaults = {
	  /**
	   * Popper's placement.
	   * @prop {Popper.placements} placement='bottom'
	   */
	  placement: 'bottom',

	  /**
	   * Set this to true if you want popper to position it self in 'fixed' mode
	   * @prop {Boolean} positionFixed=false
	   */
	  positionFixed: false,

	  /**
	   * Whether events (resize, scroll) are initially enabled.
	   * @prop {Boolean} eventsEnabled=true
	   */
	  eventsEnabled: true,

	  /**
	   * Set to true if you want to automatically remove the popper when
	   * you call the `destroy` method.
	   * @prop {Boolean} removeOnDestroy=false
	   */
	  removeOnDestroy: false,

	  /**
	   * Callback called when the popper is created.<br />
	   * By default, it is set to no-op.<br />
	   * Access Popper.js instance with `data.instance`.
	   * @prop {onCreate}
	   */
	  onCreate: function onCreate() {},

	  /**
	   * Callback called when the popper is updated. This callback is not called
	   * on the initialization/creation of the popper, but only on subsequent
	   * updates.<br />
	   * By default, it is set to no-op.<br />
	   * Access Popper.js instance with `data.instance`.
	   * @prop {onUpdate}
	   */
	  onUpdate: function onUpdate() {},

	  /**
	   * List of modifiers used to modify the offsets before they are applied to the popper.
	   * They provide most of the functionalities of Popper.js.
	   * @prop {modifiers}
	   */
	  modifiers: modifiers
	};

	/**
	 * @callback onCreate
	 * @param {dataObject} data
	 */

	/**
	 * @callback onUpdate
	 * @param {dataObject} data
	 */

	// Utils
	// Methods
	var Popper = function () {
	  /**
	   * Creates a new Popper.js instance.
	   * @class Popper
	   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
	   * @param {HTMLElement} popper - The HTML element used as the popper
	   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
	   * @return {Object} instance - The generated Popper.js instance
	   */
	  function Popper(reference, popper) {
		var _this = this;

		var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
		classCallCheck(this, Popper);

		this.scheduleUpdate = function () {
		  return requestAnimationFrame(_this.update);
		};

		// make update() debounced, so that it only runs at most once-per-tick
		this.update = debounce(this.update.bind(this));

		// with {} we create a new object with the options inside it
		this.options = _extends({}, Popper.Defaults, options);

		// init state
		this.state = {
		  isDestroyed: false,
		  isCreated: false,
		  scrollParents: []
		};

		// get reference and popper elements (allow jQuery wrappers)
		this.reference = reference && reference.jquery ? reference[0] : reference;
		this.popper = popper && popper.jquery ? popper[0] : popper;

		// Deep merge modifiers options
		this.options.modifiers = {};
		Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
		  _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
		});

		// Refactoring modifiers' list (Object => Array)
		this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
		  return _extends({
			name: name
		  }, _this.options.modifiers[name]);
		})
		// sort the modifiers by order
		.sort(function (a, b) {
		  return a.order - b.order;
		});

		// modifiers have the ability to execute arbitrary code when Popper.js get inited
		// such code is executed in the same order of its modifier
		// they could add new properties to their options configuration
		// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
		this.modifiers.forEach(function (modifierOptions) {
		  if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
			modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
		  }
		});

		// fire the first update to position the popper in the right place
		this.update();

		var eventsEnabled = this.options.eventsEnabled;
		if (eventsEnabled) {
		  // setup event listeners, they will take care of update the position in specific situations
		  this.enableEventListeners();
		}

		this.state.eventsEnabled = eventsEnabled;
	  }

	  // We can't use class properties because they don't get listed in the
	  // class prototype and break stuff like Sinon stubs


	  createClass(Popper, [{
		key: 'update',
		value: function update$$1() {
		  return update.call(this);
		}
	  }, {
		key: 'destroy',
		value: function destroy$$1() {
		  return destroy.call(this);
		}
	  }, {
		key: 'enableEventListeners',
		value: function enableEventListeners$$1() {
		  return enableEventListeners.call(this);
		}
	  }, {
		key: 'disableEventListeners',
		value: function disableEventListeners$$1() {
		  return disableEventListeners.call(this);
		}

		/**
		 * Schedules an update. It will run on the next UI update available.
		 * @method scheduleUpdate
		 * @memberof Popper
		 */


		/**
		 * Collection of utilities useful when writing custom modifiers.
		 * Starting from version 1.7, this method is available only if you
		 * include `popper-utils.js` before `popper.js`.
		 *
		 * **DEPRECATION**: This way to access PopperUtils is deprecated
		 * and will be removed in v2! Use the PopperUtils module directly instead.
		 * Due to the high instability of the methods contained in Utils, we can't
		 * guarantee them to follow semver. Use them at your own risk!
		 * @static
		 * @private
		 * @type {Object}
		 * @deprecated since version 1.8
		 * @member Utils
		 * @memberof Popper
		 */

	  }]);
	  return Popper;
	}();

	/**
	 * The `referenceObject` is an object that provides an interface compatible with Popper.js
	 * and lets you use it as replacement of a real DOM node.<br />
	 * You can use this method to position a popper relatively to a set of coordinates
	 * in case you don't have a DOM node to use as reference.
	 *
	 * ```
	 * new Popper(referenceObject, popperNode);
	 * ```
	 *
	 * NB: This feature isn't supported in Internet Explorer 10.
	 * @name referenceObject
	 * @property {Function} data.getBoundingClientRect
	 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
	 * @property {number} data.clientWidth
	 * An ES6 getter that will return the width of the virtual reference element.
	 * @property {number} data.clientHeight
	 * An ES6 getter that will return the height of the virtual reference element.
	 */


	Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
	Popper.placements = placements;
	Popper.Defaults = Defaults;

	/**
	 * ------------------------------------------------------------------------
	 * Constants
	 * ------------------------------------------------------------------------
	 */

	var NAME$4 = 'dropdown';
	var VERSION$4 = '4.3.1';
	var DATA_KEY$4 = 'bs.dropdown';
	var EVENT_KEY$4 = "." + DATA_KEY$4;
	var DATA_API_KEY$4 = '.data-api';
	var JQUERY_NO_CONFLICT$4 = $.fn[NAME$4];
	var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

	var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key

	var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key

	var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key

	var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key

	var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

	var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE);
	var Event$4 = {
	  HIDE: "hide" + EVENT_KEY$4,
	  HIDDEN: "hidden" + EVENT_KEY$4,
	  SHOW: "show" + EVENT_KEY$4,
	  SHOWN: "shown" + EVENT_KEY$4,
	  CLICK: "click" + EVENT_KEY$4,
	  CLICK_DATA_API: "click" + EVENT_KEY$4 + DATA_API_KEY$4,
	  KEYDOWN_DATA_API: "keydown" + EVENT_KEY$4 + DATA_API_KEY$4,
	  KEYUP_DATA_API: "keyup" + EVENT_KEY$4 + DATA_API_KEY$4
	};
	var ClassName$4 = {
	  DISABLED: 'disabled',
	  SHOW: 'show',
	  DROPUP: 'dropup',
	  DROPRIGHT: 'dropright',
	  DROPLEFT: 'dropleft',
	  MENURIGHT: 'dropdown-menu-right',
	  MENULEFT: 'dropdown-menu-left',
	  POSITION_STATIC: 'position-static'
	};
	var Selector$4 = {
	  DATA_TOGGLE: '[data-toggle="dropdown"]',
	  FORM_CHILD: '.dropdown form',
	  MENU: '.dropdown-menu',
	  NAVBAR_NAV: '.navbar-nav',
	  VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'
	};
	var AttachmentMap = {
	  TOP: 'top-start',
	  TOPEND: 'top-end',
	  BOTTOM: 'bottom-start',
	  BOTTOMEND: 'bottom-end',
	  RIGHT: 'right-start',
	  RIGHTEND: 'right-end',
	  LEFT: 'left-start',
	  LEFTEND: 'left-end'
	};
	var Default$2 = {
	  offset: 0,
	  flip: true,
	  boundary: 'scrollParent',
	  reference: 'toggle',
	  display: 'dynamic'
	};
	var DefaultType$2 = {
	  offset: '(number|string|function)',
	  flip: 'boolean',
	  boundary: '(string|element)',
	  reference: '(string|element)',
	  display: 'string'
	  /**
	   * ------------------------------------------------------------------------
	   * Class Definition
	   * ------------------------------------------------------------------------
	   */

	};

	var Dropdown =
	/*#__PURE__*/
	function () {
	  function Dropdown(element, config) {
		this._element = element;
		this._popper = null;
		this._config = this._getConfig(config);
		this._menu = this._getMenuElement();
		this._inNavbar = this._detectNavbar();

		this._addEventListeners();
	  } // Getters


	  var _proto = Dropdown.prototype;

	  // Public
	  _proto.toggle = function toggle() {
		if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED)) {
		  return;
		}

		var parent = Dropdown._getParentFromElement(this._element);

		var isActive = $(this._menu).hasClass(ClassName$4.SHOW);

		Dropdown._clearMenus();

		if (isActive) {
		  return;
		}

		var relatedTarget = {
		  relatedTarget: this._element
		};
		var showEvent = $.Event(Event$4.SHOW, relatedTarget);
		$(parent).trigger(showEvent);

		if (showEvent.isDefaultPrevented()) {
		  return;
		} // Disable totally Popper.js for Dropdown in Navbar


		if (!this._inNavbar) {
		  /**
		   * Check for Popper dependency
		   * Popper - https://popper.js.org
		   */
		  if (typeof Popper === 'undefined') {
			throw new TypeError('Bootstrap\'s dropdowns require Popper.js (https://popper.js.org/)');
		  }

		  var referenceElement = this._element;

		  if (this._config.reference === 'parent') {
			referenceElement = parent;
		  } else if (Util.isElement(this._config.reference)) {
			referenceElement = this._config.reference; // Check if it's jQuery element

			if (typeof this._config.reference.jquery !== 'undefined') {
			  referenceElement = this._config.reference[0];
			}
		  } // If boundary is not `scrollParent`, then set position to `static`
		  // to allow the menu to "escape" the scroll parent's boundaries
		  // https://github.com/twbs/bootstrap/issues/24251


		  if (this._config.boundary !== 'scrollParent') {
			$(parent).addClass(ClassName$4.POSITION_STATIC);
		  }

		  this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());
		} // If this is a touch-enabled device we add extra
		// empty mouseover listeners to the body's immediate children;
		// only needed because of broken event delegation on iOS
		// https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


		if ('ontouchstart' in document.documentElement && $(parent).closest(Selector$4.NAVBAR_NAV).length === 0) {
		  $(document.body).children().on('mouseover', null, $.noop);
		}

		this._element.focus();

		this._element.setAttribute('aria-expanded', true);

		$(this._menu).toggleClass(ClassName$4.SHOW);
		$(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget));
	  };

	  _proto.show = function show() {
		if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || $(this._menu).hasClass(ClassName$4.SHOW)) {
		  return;
		}

		var relatedTarget = {
		  relatedTarget: this._element
		};
		var showEvent = $.Event(Event$4.SHOW, relatedTarget);

		var parent = Dropdown._getParentFromElement(this._element);

		$(parent).trigger(showEvent);

		if (showEvent.isDefaultPrevented()) {
		  return;
		}

		$(this._menu).toggleClass(ClassName$4.SHOW);
		$(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget));
	  };

	  _proto.hide = function hide() {
		if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || !$(this._menu).hasClass(ClassName$4.SHOW)) {
		  return;
		}

		var relatedTarget = {
		  relatedTarget: this._element
		};
		var hideEvent = $.Event(Event$4.HIDE, relatedTarget);

		var parent = Dropdown._getParentFromElement(this._element);

		$(parent).trigger(hideEvent);

		if (hideEvent.isDefaultPrevented()) {
		  return;
		}

		$(this._menu).toggleClass(ClassName$4.SHOW);
		$(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));
	  };

	  _proto.dispose = function dispose() {
		$.removeData(this._element, DATA_KEY$4);
		$(this._element).off(EVENT_KEY$4);
		this._element = null;
		this._menu = null;

		if (this._popper !== null) {
		  this._popper.destroy();

		  this._popper = null;
		}
	  };

	  _proto.update = function update() {
		this._inNavbar = this._detectNavbar();

		if (this._popper !== null) {
		  this._popper.scheduleUpdate();
		}
	  } // Private
	  ;

	  _proto._addEventListeners = function _addEventListeners() {
		var _this = this;

		$(this._element).on(Event$4.CLICK, function (event) {
		  event.preventDefault();
		  event.stopPropagation();

		  _this.toggle();
		});
	  };

	  _proto._getConfig = function _getConfig(config) {
		config = _objectSpread({}, this.constructor.Default, $(this._element).data(), config);
		Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
		return config;
	  };

	  _proto._getMenuElement = function _getMenuElement() {
		if (!this._menu) {
		  var parent = Dropdown._getParentFromElement(this._element);

		  if (parent) {
			this._menu = parent.querySelector(Selector$4.MENU);
		  }
		}

		return this._menu;
	  };

	  _proto._getPlacement = function _getPlacement() {
		var $parentDropdown = $(this._element.parentNode);
		var placement = AttachmentMap.BOTTOM; // Handle dropup

		if ($parentDropdown.hasClass(ClassName$4.DROPUP)) {
		  placement = AttachmentMap.TOP;

		  if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {
			placement = AttachmentMap.TOPEND;
		  }
		} else if ($parentDropdown.hasClass(ClassName$4.DROPRIGHT)) {
		  placement = AttachmentMap.RIGHT;
		} else if ($parentDropdown.hasClass(ClassName$4.DROPLEFT)) {
		  placement = AttachmentMap.LEFT;
		} else if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {
		  placement = AttachmentMap.BOTTOMEND;
		}

		return placement;
	  };

	  _proto._detectNavbar = function _detectNavbar() {
		return $(this._element).closest('.navbar').length > 0;
	  };

	  _proto._getOffset = function _getOffset() {
		var _this2 = this;

		var offset = {};

		if (typeof this._config.offset === 'function') {
		  offset.fn = function (data) {
			data.offsets = _objectSpread({}, data.offsets, _this2._config.offset(data.offsets, _this2._element) || {});
			return data;
		  };
		} else {
		  offset.offset = this._config.offset;
		}

		return offset;
	  };

	  _proto._getPopperConfig = function _getPopperConfig() {
		var popperConfig = {
		  placement: this._getPlacement(),
		  modifiers: {
			offset: this._getOffset(),
			flip: {
			  enabled: this._config.flip
			},
			preventOverflow: {
			  boundariesElement: this._config.boundary
			}
		  } // Disable Popper.js if we have a static display

		};

		if (this._config.display === 'static') {
		  popperConfig.modifiers.applyStyle = {
			enabled: false
		  };
		}

		return popperConfig;
	  } // Static
	  ;

	  Dropdown._jQueryInterface = function _jQueryInterface(config) {
		return this.each(function () {
		  var data = $(this).data(DATA_KEY$4);

		  var _config = typeof config === 'object' ? config : null;

		  if (!data) {
			data = new Dropdown(this, _config);
			$(this).data(DATA_KEY$4, data);
		  }

		  if (typeof config === 'string') {
			if (typeof data[config] === 'undefined') {
			  throw new TypeError("No method named \"" + config + "\"");
			}

			data[config]();
		  }
		});
	  };

	  Dropdown._clearMenus = function _clearMenus(event) {
		if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
		  return;
		}

		var toggles = [].slice.call(document.querySelectorAll(Selector$4.DATA_TOGGLE));

		for (var i = 0, len = toggles.length; i < len; i++) {
		  var parent = Dropdown._getParentFromElement(toggles[i]);

		  var context = $(toggles[i]).data(DATA_KEY$4);
		  var relatedTarget = {
			relatedTarget: toggles[i]
		  };

		  if (event && event.type === 'click') {
			relatedTarget.clickEvent = event;
		  }

		  if (!context) {
			continue;
		  }

		  var dropdownMenu = context._menu;

		  if (!$(parent).hasClass(ClassName$4.SHOW)) {
			continue;
		  }

		  if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {
			continue;
		  }

		  var hideEvent = $.Event(Event$4.HIDE, relatedTarget);
		  $(parent).trigger(hideEvent);

		  if (hideEvent.isDefaultPrevented()) {
			continue;
		  } // If this is a touch-enabled device we remove the extra
		  // empty mouseover listeners we added for iOS support


		  if ('ontouchstart' in document.documentElement) {
			$(document.body).children().off('mouseover', null, $.noop);
		  }

		  toggles[i].setAttribute('aria-expanded', 'false');
		  $(dropdownMenu).removeClass(ClassName$4.SHOW);
		  $(parent).removeClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));
		}
	  };

	  Dropdown._getParentFromElement = function _getParentFromElement(element) {
		var parent;
		var selector = Util.getSelectorFromElement(element);

		if (selector) {
		  parent = document.querySelector(selector);
		}

		return parent || element.parentNode;
	  } // eslint-disable-next-line complexity
	  ;

	  Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
		// If not input/textarea:
		//  - And not a key in REGEXP_KEYDOWN => not a dropdown command
		// If input/textarea:
		//  - If space key => not a dropdown command
		//  - If key is other than escape
		//    - If key is not up or down => not a dropdown command
		//    - If trigger inside the menu => not a dropdown command
		if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $(event.target).closest(Selector$4.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
		  return;
		}

		event.preventDefault();
		event.stopPropagation();

		if (this.disabled || $(this).hasClass(ClassName$4.DISABLED)) {
		  return;
		}

		var parent = Dropdown._getParentFromElement(this);

		var isActive = $(parent).hasClass(ClassName$4.SHOW);

		if (!isActive || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
		  if (event.which === ESCAPE_KEYCODE) {
			var toggle = parent.querySelector(Selector$4.DATA_TOGGLE);
			$(toggle).trigger('focus');
		  }

		  $(this).trigger('click');
		  return;
		}

		var items = [].slice.call(parent.querySelectorAll(Selector$4.VISIBLE_ITEMS));

		if (items.length === 0) {
		  return;
		}

		var index = items.indexOf(event.target);

		if (event.which === ARROW_UP_KEYCODE && index > 0) {
		  // Up
		  index--;
		}

		if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
		  // Down
		  index++;
		}

		if (index < 0) {
		  index = 0;
		}

		items[index].focus();
	  };

	  _createClass(Dropdown, null, [{
		key: "VERSION",
		get: function get() {
		  return VERSION$4;
		}
	  }, {
		key: "Default",
		get: function get() {
		  return Default$2;
		}
	  }, {
		key: "DefaultType",
		get: function get() {
		  return DefaultType$2;
		}
	  }]);

	  return Dropdown;
	}();
	/**
	 * ------------------------------------------------------------------------
	 * Data Api implementation
	 * ------------------------------------------------------------------------
	 */


	$(document).on(Event$4.KEYDOWN_DATA_API, Selector$4.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event$4.KEYDOWN_DATA_API, Selector$4.MENU, Dropdown._dataApiKeydownHandler).on(Event$4.CLICK_DATA_API + " " + Event$4.KEYUP_DATA_API, Dropdown._clearMenus).on(Event$4.CLICK_DATA_API, Selector$4.DATA_TOGGLE, function (event) {
	  event.preventDefault();
	  event.stopPropagation();

	  Dropdown._jQueryInterface.call($(this), 'toggle');
	}).on(Event$4.CLICK_DATA_API, Selector$4.FORM_CHILD, function (e) {
	  e.stopPropagation();
	});
	/**
	 * ------------------------------------------------------------------------
	 * jQuery
	 * ------------------------------------------------------------------------
	 */

	$.fn[NAME$4] = Dropdown._jQueryInterface;
	$.fn[NAME$4].Constructor = Dropdown;

	$.fn[NAME$4].noConflict = function () {
	  $.fn[NAME$4] = JQUERY_NO_CONFLICT$4;
	  return Dropdown._jQueryInterface;
	};

	/**
	 * ------------------------------------------------------------------------
	 * Constants
	 * ------------------------------------------------------------------------
	 */

	var NAME$5 = 'modal';
	var VERSION$5 = '4.3.1';
	var DATA_KEY$5 = 'bs.modal';
	var EVENT_KEY$5 = "." + DATA_KEY$5;
	var DATA_API_KEY$5 = '.data-api';
	var JQUERY_NO_CONFLICT$5 = $.fn[NAME$5];
	var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key

	var Default$3 = {
	  backdrop: true,
	  keyboard: true,
	  focus: true,
	  show: true
	};
	var DefaultType$3 = {
	  backdrop: '(boolean|string)',
	  keyboard: 'boolean',
	  focus: 'boolean',
	  show: 'boolean'
	};
	var Event$5 = {
	  HIDE: "hide" + EVENT_KEY$5,
	  HIDDEN: "hidden" + EVENT_KEY$5,
	  SHOW: "show" + EVENT_KEY$5,
	  SHOWN: "shown" + EVENT_KEY$5,
	  FOCUSIN: "focusin" + EVENT_KEY$5,
	  RESIZE: "resize" + EVENT_KEY$5,
	  CLICK_DISMISS: "click.dismiss" + EVENT_KEY$5,
	  KEYDOWN_DISMISS: "keydown.dismiss" + EVENT_KEY$5,
	  MOUSEUP_DISMISS: "mouseup.dismiss" + EVENT_KEY$5,
	  MOUSEDOWN_DISMISS: "mousedown.dismiss" + EVENT_KEY$5,
	  CLICK_DATA_API: "click" + EVENT_KEY$5 + DATA_API_KEY$5
	};
	var ClassName$5 = {
	  SCROLLABLE: 'modal-dialog-scrollable',
	  SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
	  BACKDROP: 'modal-backdrop',
	  OPEN: 'modal-open',
	  FADE: 'fade',
	  SHOW: 'show'
	};
	var Selector$5 = {
	  DIALOG: '.modal-dialog',
	  MODAL_BODY: '.modal-body',
	  DATA_TOGGLE: '[data-toggle="modal"]',
	  DATA_DISMISS: '[data-dismiss="modal"]',
	  FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
	  STICKY_CONTENT: '.sticky-top'
	  /**
	   * ------------------------------------------------------------------------
	   * Class Definition
	   * ------------------------------------------------------------------------
	   */

	};

	var Modal =
	/*#__PURE__*/
	function () {
	  function Modal(element, config) {
		this._config = this._getConfig(config);
		this._element = element;
		this._dialog = element.querySelector(Selector$5.DIALOG);
		this._backdrop = null;
		this._isShown = false;
		this._isBodyOverflowing = false;
		this._ignoreBackdropClick = false;
		this._isTransitioning = false;
		this._scrollbarWidth = 0;
	  } // Getters


	  var _proto = Modal.prototype;

	  // Public
	  _proto.toggle = function toggle(relatedTarget) {
		return this._isShown ? this.hide() : this.show(relatedTarget);
	  };

	  _proto.show = function show(relatedTarget) {
		var _this = this;

		if (this._isShown || this._isTransitioning) {
		  return;
		}

		if ($(this._element).hasClass(ClassName$5.FADE)) {
		  this._isTransitioning = true;
		}

		var showEvent = $.Event(Event$5.SHOW, {
		  relatedTarget: relatedTarget
		});
		$(this._element).trigger(showEvent);

		if (this._isShown || showEvent.isDefaultPrevented()) {
		  return;
		}

		this._isShown = true;

		this._checkScrollbar();

		this._setScrollbar();

		this._adjustDialog();

		this._setEscapeEvent();

		this._setResizeEvent();

		$(this._element).on(Event$5.CLICK_DISMISS, Selector$5.DATA_DISMISS, function (event) {
		  return _this.hide(event);
		});
		$(this._dialog).on(Event$5.MOUSEDOWN_DISMISS, function () {
		  $(_this._element).one(Event$5.MOUSEUP_DISMISS, function (event) {
			if ($(event.target).is(_this._element)) {
			  _this._ignoreBackdropClick = true;
			}
		  });
		});

		this._showBackdrop(function () {
		  return _this._showElement(relatedTarget);
		});
	  };

	  _proto.hide = function hide(event) {
		var _this2 = this;

		if (event) {
		  event.preventDefault();
		}

		if (!this._isShown || this._isTransitioning) {
		  return;
		}

		var hideEvent = $.Event(Event$5.HIDE);
		$(this._element).trigger(hideEvent);

		if (!this._isShown || hideEvent.isDefaultPrevented()) {
		  return;
		}

		this._isShown = false;
		var transition = $(this._element).hasClass(ClassName$5.FADE);

		if (transition) {
		  this._isTransitioning = true;
		}

		this._setEscapeEvent();

		this._setResizeEvent();

		$(document).off(Event$5.FOCUSIN);
		$(this._element).removeClass(ClassName$5.SHOW);
		$(this._element).off(Event$5.CLICK_DISMISS);
		$(this._dialog).off(Event$5.MOUSEDOWN_DISMISS);

		if (transition) {
		  var transitionDuration = Util.getTransitionDurationFromElement(this._element);
		  $(this._element).one(Util.TRANSITION_END, function (event) {
			return _this2._hideModal(event);
		  }).emulateTransitionEnd(transitionDuration);
		} else {
		  this._hideModal();
		}
	  };

	  _proto.dispose = function dispose() {
		[window, this._element, this._dialog].forEach(function (htmlElement) {
		  return $(htmlElement).off(EVENT_KEY$5);
		});
		/**
		 * `document` has 2 events `Event.FOCUSIN` and `Event.CLICK_DATA_API`
		 * Do not move `document` in `htmlElements` array
		 * It will remove `Event.CLICK_DATA_API` event that should remain
		 */

		$(document).off(Event$5.FOCUSIN);
		$.removeData(this._element, DATA_KEY$5);
		this._config = null;
		this._element = null;
		this._dialog = null;
		this._backdrop = null;
		this._isShown = null;
		this._isBodyOverflowing = null;
		this._ignoreBackdropClick = null;
		this._isTransitioning = null;
		this._scrollbarWidth = null;
	  };

	  _proto.handleUpdate = function handleUpdate() {
		this._adjustDialog();
	  } // Private
	  ;

	  _proto._getConfig = function _getConfig(config) {
		config = _objectSpread({}, Default$3, config);
		Util.typeCheckConfig(NAME$5, config, DefaultType$3);
		return config;
	  };

	  _proto._showElement = function _showElement(relatedTarget) {
		var _this3 = this;

		var transition = $(this._element).hasClass(ClassName$5.FADE);

		if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
		  // Don't move modal's DOM position
		  document.body.appendChild(this._element);
		}

		this._element.style.display = 'block';

		this._element.removeAttribute('aria-hidden');

		this._element.setAttribute('aria-modal', true);

		if ($(this._dialog).hasClass(ClassName$5.SCROLLABLE)) {
		  this._dialog.querySelector(Selector$5.MODAL_BODY).scrollTop = 0;
		} else {
		  this._element.scrollTop = 0;
		}

		if (transition) {
		  Util.reflow(this._element);
		}

		$(this._element).addClass(ClassName$5.SHOW);

		if (this._config.focus) {
		  this._enforceFocus();
		}

		var shownEvent = $.Event(Event$5.SHOWN, {
		  relatedTarget: relatedTarget
		});

		var transitionComplete = function transitionComplete() {
		  if (_this3._config.focus) {
			_this3._element.focus();
		  }

		  _this3._isTransitioning = false;
		  $(_this3._element).trigger(shownEvent);
		};

		if (transition) {
		  var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);
		  $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
		} else {
		  transitionComplete();
		}
	  };

	  _proto._enforceFocus = function _enforceFocus() {
		var _this4 = this;

		$(document).off(Event$5.FOCUSIN) // Guard against infinite focus loop
		.on(Event$5.FOCUSIN, function (event) {
		  if (document !== event.target && _this4._element !== event.target && $(_this4._element).has(event.target).length === 0) {
			_this4._element.focus();
		  }
		});
	  };

	  _proto._setEscapeEvent = function _setEscapeEvent() {
		var _this5 = this;

		if (this._isShown && this._config.keyboard) {
		  $(this._element).on(Event$5.KEYDOWN_DISMISS, function (event) {
			if (event.which === ESCAPE_KEYCODE$1) {
			  event.preventDefault();

			  _this5.hide();
			}
		  });
		} else if (!this._isShown) {
		  $(this._element).off(Event$5.KEYDOWN_DISMISS);
		}
	  };

	  _proto._setResizeEvent = function _setResizeEvent() {
		var _this6 = this;

		if (this._isShown) {
		  $(window).on(Event$5.RESIZE, function (event) {
			return _this6.handleUpdate(event);
		  });
		} else {
		  $(window).off(Event$5.RESIZE);
		}
	  };

	  _proto._hideModal = function _hideModal() {
		var _this7 = this;

		this._element.style.display = 'none';

		this._element.setAttribute('aria-hidden', true);

		this._element.removeAttribute('aria-modal');

		this._isTransitioning = false;

		this._showBackdrop(function () {
		  $(document.body).removeClass(ClassName$5.OPEN);

		  _this7._resetAdjustments();

		  _this7._resetScrollbar();

		  $(_this7._element).trigger(Event$5.HIDDEN);
		});
	  };

	  _proto._removeBackdrop = function _removeBackdrop() {
		if (this._backdrop) {
		  $(this._backdrop).remove();
		  this._backdrop = null;
		}
	  };

	  _proto._showBackdrop = function _showBackdrop(callback) {
		var _this8 = this;

		var animate = $(this._element).hasClass(ClassName$5.FADE) ? ClassName$5.FADE : '';

		if (this._isShown && this._config.backdrop) {
		  this._backdrop = document.createElement('div');
		  this._backdrop.className = ClassName$5.BACKDROP;

		  if (animate) {
			this._backdrop.classList.add(animate);
		  }

		  $(this._backdrop).appendTo(document.body);
		  $(this._element).on(Event$5.CLICK_DISMISS, function (event) {
			if (_this8._ignoreBackdropClick) {
			  _this8._ignoreBackdropClick = false;
			  return;
			}

			if (event.target !== event.currentTarget) {
			  return;
			}

			if (_this8._config.backdrop === 'static') {
			  _this8._element.focus();
			} else {
			  _this8.hide();
			}
		  });

		  if (animate) {
			Util.reflow(this._backdrop);
		  }

		  $(this._backdrop).addClass(ClassName$5.SHOW);

		  if (!callback) {
			return;
		  }

		  if (!animate) {
			callback();
			return;
		  }

		  var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
		  $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
		} else if (!this._isShown && this._backdrop) {
		  $(this._backdrop).removeClass(ClassName$5.SHOW);

		  var callbackRemove = function callbackRemove() {
			_this8._removeBackdrop();

			if (callback) {
			  callback();
			}
		  };

		  if ($(this._element).hasClass(ClassName$5.FADE)) {
			var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);

			$(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
		  } else {
			callbackRemove();
		  }
		} else if (callback) {
		  callback();
		}
	  } // ----------------------------------------------------------------------
	  // the following methods are used to handle overflowing modals
	  // todo (fat): these should probably be refactored out of modal.js
	  // ----------------------------------------------------------------------
	  ;

	  _proto._adjustDialog = function _adjustDialog() {
		var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

		if (!this._isBodyOverflowing && isModalOverflowing) {
		  this._element.style.paddingLeft = this._scrollbarWidth + "px";
		}

		if (this._isBodyOverflowing && !isModalOverflowing) {
		  this._element.style.paddingRight = this._scrollbarWidth + "px";
		}
	  };

	  _proto._resetAdjustments = function _resetAdjustments() {
		this._element.style.paddingLeft = '';
		this._element.style.paddingRight = '';
	  };

	  _proto._checkScrollbar = function _checkScrollbar() {
		var rect = document.body.getBoundingClientRect();
		this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;
		this._scrollbarWidth = this._getScrollbarWidth();
	  };

	  _proto._setScrollbar = function _setScrollbar() {
		var _this9 = this;

		if (this._isBodyOverflowing) {
		  // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
		  //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
		  var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
		  var stickyContent = [].slice.call(document.querySelectorAll(Selector$5.STICKY_CONTENT)); // Adjust fixed content padding

		  $(fixedContent).each(function (index, element) {
			var actualPadding = element.style.paddingRight;
			var calculatedPadding = $(element).css('padding-right');
			$(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + "px");
		  }); // Adjust sticky content margin

		  $(stickyContent).each(function (index, element) {
			var actualMargin = element.style.marginRight;
			var calculatedMargin = $(element).css('margin-right');
			$(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + "px");
		  }); // Adjust body padding

		  var actualPadding = document.body.style.paddingRight;
		  var calculatedPadding = $(document.body).css('padding-right');
		  $(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
		}

		$(document.body).addClass(ClassName$5.OPEN);
	  };

	  _proto._resetScrollbar = function _resetScrollbar() {
		// Restore fixed content padding
		var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
		$(fixedContent).each(function (index, element) {
		  var padding = $(element).data('padding-right');
		  $(element).removeData('padding-right');
		  element.style.paddingRight = padding ? padding : '';
		}); // Restore sticky content

		var elements = [].slice.call(document.querySelectorAll("" + Selector$5.STICKY_CONTENT));
		$(elements).each(function (index, element) {
		  var margin = $(element).data('margin-right');

		  if (typeof margin !== 'undefined') {
			$(element).css('margin-right', margin).removeData('margin-right');
		  }
		}); // Restore body padding

		var padding = $(document.body).data('padding-right');
		$(document.body).removeData('padding-right');
		document.body.style.paddingRight = padding ? padding : '';
	  };

	  _proto._getScrollbarWidth = function _getScrollbarWidth() {
		// thx d.walsh
		var scrollDiv = document.createElement('div');
		scrollDiv.className = ClassName$5.SCROLLBAR_MEASURER;
		document.body.appendChild(scrollDiv);
		var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
		document.body.removeChild(scrollDiv);
		return scrollbarWidth;
	  } // Static
	  ;

	  Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
		return this.each(function () {
		  var data = $(this).data(DATA_KEY$5);

		  var _config = _objectSpread({}, Default$3, $(this).data(), typeof config === 'object' && config ? config : {});

		  if (!data) {
			data = new Modal(this, _config);
			$(this).data(DATA_KEY$5, data);
		  }

		  if (typeof config === 'string') {
			if (typeof data[config] === 'undefined') {
			  throw new TypeError("No method named \"" + config + "\"");
			}

			data[config](relatedTarget);
		  } else if (_config.show) {
			data.show(relatedTarget);
		  }
		});
	  };

	  _createClass(Modal, null, [{
		key: "VERSION",
		get: function get() {
		  return VERSION$5;
		}
	  }, {
		key: "Default",
		get: function get() {
		  return Default$3;
		}
	  }]);

	  return Modal;
	}();
	/**
	 * ------------------------------------------------------------------------
	 * Data Api implementation
	 * ------------------------------------------------------------------------
	 */


	$(document).on(Event$5.CLICK_DATA_API, Selector$5.DATA_TOGGLE, function (event) {
	  var _this10 = this;

	  var target;
	  var selector = Util.getSelectorFromElement(this);

	  if (selector) {
		target = document.querySelector(selector);
	  }

	  var config = $(target).data(DATA_KEY$5) ? 'toggle' : _objectSpread({}, $(target).data(), $(this).data());

	  if (this.tagName === 'A' || this.tagName === 'AREA') {
		event.preventDefault();
	  }

	  var $target = $(target).one(Event$5.SHOW, function (showEvent) {
		if (showEvent.isDefaultPrevented()) {
		  // Only register focus restorer if modal will actually get shown
		  return;
		}

		$target.one(Event$5.HIDDEN, function () {
		  if ($(_this10).is(':visible')) {
			_this10.focus();
		  }
		});
	  });

	  Modal._jQueryInterface.call($(target), config, this);
	});
	/**
	 * ------------------------------------------------------------------------
	 * jQuery
	 * ------------------------------------------------------------------------
	 */

	$.fn[NAME$5] = Modal._jQueryInterface;
	$.fn[NAME$5].Constructor = Modal;

	$.fn[NAME$5].noConflict = function () {
	  $.fn[NAME$5] = JQUERY_NO_CONFLICT$5;
	  return Modal._jQueryInterface;
	};

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.3.1): tools/sanitizer.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */
	var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];
	var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
	var DefaultWhitelist = {
	  // Global attributes allowed on any supplied element below.
	  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
	  a: ['target', 'href', 'title', 'rel'],
	  area: [],
	  b: [],
	  br: [],
	  col: [],
	  code: [],
	  div: [],
	  em: [],
	  hr: [],
	  h1: [],
	  h2: [],
	  h3: [],
	  h4: [],
	  h5: [],
	  h6: [],
	  i: [],
	  img: ['src', 'alt', 'title', 'width', 'height'],
	  li: [],
	  ol: [],
	  p: [],
	  pre: [],
	  s: [],
	  small: [],
	  span: [],
	  sub: [],
	  sup: [],
	  strong: [],
	  u: [],
	  ul: []
	  /**
	   * A pattern that recognizes a commonly useful subset of URLs that are safe.
	   *
	   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
	   */

	};
	var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
	/**
	 * A pattern that matches safe data URLs. Only matches image, video and audio types.
	 *
	 * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
	 */

	var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;

	function allowedAttribute(attr, allowedAttributeList) {
	  var attrName = attr.nodeName.toLowerCase();

	  if (allowedAttributeList.indexOf(attrName) !== -1) {
		if (uriAttrs.indexOf(attrName) !== -1) {
		  return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
		}

		return true;
	  }

	  var regExp = allowedAttributeList.filter(function (attrRegex) {
		return attrRegex instanceof RegExp;
	  }); // Check if a regular expression validates the attribute.

	  for (var i = 0, l = regExp.length; i < l; i++) {
		if (attrName.match(regExp[i])) {
		  return true;
		}
	  }

	  return false;
	}

	function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
	  if (unsafeHtml.length === 0) {
		return unsafeHtml;
	  }

	  if (sanitizeFn && typeof sanitizeFn === 'function') {
		return sanitizeFn(unsafeHtml);
	  }

	  var domParser = new window.DOMParser();
	  var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
	  var whitelistKeys = Object.keys(whiteList);
	  var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));

	  var _loop = function _loop(i, len) {
		var el = elements[i];
		var elName = el.nodeName.toLowerCase();

		if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {
		  el.parentNode.removeChild(el);
		  return "continue";
		}

		var attributeList = [].slice.call(el.attributes);
		var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);
		attributeList.forEach(function (attr) {
		  if (!allowedAttribute(attr, whitelistedAttributes)) {
			el.removeAttribute(attr.nodeName);
		  }
		});
	  };

	  for (var i = 0, len = elements.length; i < len; i++) {
		var _ret = _loop(i, len);

		if (_ret === "continue") continue;
	  }

	  return createdDocument.body.innerHTML;
	}

	/**
	 * ------------------------------------------------------------------------
	 * Constants
	 * ------------------------------------------------------------------------
	 */

	var NAME$6 = 'tooltip';
	var VERSION$6 = '4.3.1';
	var DATA_KEY$6 = 'bs.tooltip';
	var EVENT_KEY$6 = "." + DATA_KEY$6;
	var JQUERY_NO_CONFLICT$6 = $.fn[NAME$6];
	var CLASS_PREFIX = 'bs-tooltip';
	var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
	var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
	var DefaultType$4 = {
	  animation: 'boolean',
	  template: 'string',
	  title: '(string|element|function)',
	  trigger: 'string',
	  delay: '(number|object)',
	  html: 'boolean',
	  selector: '(string|boolean)',
	  placement: '(string|function)',
	  offset: '(number|string|function)',
	  container: '(string|element|boolean)',
	  fallbackPlacement: '(string|array)',
	  boundary: '(string|element)',
	  sanitize: 'boolean',
	  sanitizeFn: '(null|function)',
	  whiteList: 'object'
	};
	var AttachmentMap$1 = {
	  AUTO: 'auto',
	  TOP: 'top',
	  RIGHT: 'right',
	  BOTTOM: 'bottom',
	  LEFT: 'left'
	};
	var Default$4 = {
	  animation: true,
	  template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
	  trigger: 'hover focus',
	  title: '',
	  delay: 0,
	  html: false,
	  selector: false,
	  placement: 'top',
	  offset: 0,
	  container: false,
	  fallbackPlacement: 'flip',
	  boundary: 'scrollParent',
	  sanitize: true,
	  sanitizeFn: null,
	  whiteList: DefaultWhitelist
	};
	var HoverState = {
	  SHOW: 'show',
	  OUT: 'out'
	};
	var Event$6 = {
	  HIDE: "hide" + EVENT_KEY$6,
	  HIDDEN: "hidden" + EVENT_KEY$6,
	  SHOW: "show" + EVENT_KEY$6,
	  SHOWN: "shown" + EVENT_KEY$6,
	  INSERTED: "inserted" + EVENT_KEY$6,
	  CLICK: "click" + EVENT_KEY$6,
	  FOCUSIN: "focusin" + EVENT_KEY$6,
	  FOCUSOUT: "focusout" + EVENT_KEY$6,
	  MOUSEENTER: "mouseenter" + EVENT_KEY$6,
	  MOUSELEAVE: "mouseleave" + EVENT_KEY$6
	};
	var ClassName$6 = {
	  FADE: 'fade',
	  SHOW: 'show'
	};
	var Selector$6 = {
	  TOOLTIP: '.tooltip',
	  TOOLTIP_INNER: '.tooltip-inner',
	  ARROW: '.arrow'
	};
	var Trigger = {
	  HOVER: 'hover',
	  FOCUS: 'focus',
	  CLICK: 'click',
	  MANUAL: 'manual'
	  /**
	   * ------------------------------------------------------------------------
	   * Class Definition
	   * ------------------------------------------------------------------------
	   */

	};

	var Tooltip =
	/*#__PURE__*/
	function () {
	  function Tooltip(element, config) {
		/**
		 * Check for Popper dependency
		 * Popper - https://popper.js.org
		 */
		if (typeof Popper === 'undefined') {
		  throw new TypeError('Bootstrap\'s tooltips require Popper.js (https://popper.js.org/)');
		} // private


		this._isEnabled = true;
		this._timeout = 0;
		this._hoverState = '';
		this._activeTrigger = {};
		this._popper = null; // Protected

		this.element = element;
		this.config = this._getConfig(config);
		this.tip = null;

		this._setListeners();
	  } // Getters


	  var _proto = Tooltip.prototype;

	  // Public
	  _proto.enable = function enable() {
		this._isEnabled = true;
	  };

	  _proto.disable = function disable() {
		this._isEnabled = false;
	  };

	  _proto.toggleEnabled = function toggleEnabled() {
		this._isEnabled = !this._isEnabled;
	  };

	  _proto.toggle = function toggle(event) {
		if (!this._isEnabled) {
		  return;
		}

		if (event) {
		  var dataKey = this.constructor.DATA_KEY;
		  var context = $(event.currentTarget).data(dataKey);

		  if (!context) {
			context = new this.constructor(event.currentTarget, this._getDelegateConfig());
			$(event.currentTarget).data(dataKey, context);
		  }

		  context._activeTrigger.click = !context._activeTrigger.click;

		  if (context._isWithActiveTrigger()) {
			context._enter(null, context);
		  } else {
			context._leave(null, context);
		  }
		} else {
		  if ($(this.getTipElement()).hasClass(ClassName$6.SHOW)) {
			this._leave(null, this);

			return;
		  }

		  this._enter(null, this);
		}
	  };

	  _proto.dispose = function dispose() {
		clearTimeout(this._timeout);
		$.removeData(this.element, this.constructor.DATA_KEY);
		$(this.element).off(this.constructor.EVENT_KEY);
		$(this.element).closest('.modal').off('hide.bs.modal');

		if (this.tip) {
		  $(this.tip).remove();
		}

		this._isEnabled = null;
		this._timeout = null;
		this._hoverState = null;
		this._activeTrigger = null;

		if (this._popper !== null) {
		  this._popper.destroy();
		}

		this._popper = null;
		this.element = null;
		this.config = null;
		this.tip = null;
	  };

	  _proto.show = function show() {
		var _this = this;

		if ($(this.element).css('display') === 'none') {
		  throw new Error('Please use show on visible elements');
		}

		var showEvent = $.Event(this.constructor.Event.SHOW);

		if (this.isWithContent() && this._isEnabled) {
		  $(this.element).trigger(showEvent);
		  var shadowRoot = Util.findShadowRoot(this.element);
		  var isInTheDom = $.contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);

		  if (showEvent.isDefaultPrevented() || !isInTheDom) {
			return;
		  }

		  var tip = this.getTipElement();
		  var tipId = Util.getUID(this.constructor.NAME);
		  tip.setAttribute('id', tipId);
		  this.element.setAttribute('aria-describedby', tipId);
		  this.setContent();

		  if (this.config.animation) {
			$(tip).addClass(ClassName$6.FADE);
		  }

		  var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

		  var attachment = this._getAttachment(placement);

		  this.addAttachmentClass(attachment);

		  var container = this._getContainer();

		  $(tip).data(this.constructor.DATA_KEY, this);

		  if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
			$(tip).appendTo(container);
		  }

		  $(this.element).trigger(this.constructor.Event.INSERTED);
		  this._popper = new Popper(this.element, tip, {
			placement: attachment,
			modifiers: {
			  offset: this._getOffset(),
			  flip: {
				behavior: this.config.fallbackPlacement
			  },
			  arrow: {
				element: Selector$6.ARROW
			  },
			  preventOverflow: {
				boundariesElement: this.config.boundary
			  }
			},
			onCreate: function onCreate(data) {
			  if (data.originalPlacement !== data.placement) {
				_this._handlePopperPlacementChange(data);
			  }
			},
			onUpdate: function onUpdate(data) {
			  return _this._handlePopperPlacementChange(data);
			}
		  });
		  $(tip).addClass(ClassName$6.SHOW); // If this is a touch-enabled device we add extra
		  // empty mouseover listeners to the body's immediate children;
		  // only needed because of broken event delegation on iOS
		  // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

		  if ('ontouchstart' in document.documentElement) {
			$(document.body).children().on('mouseover', null, $.noop);
		  }

		  var complete = function complete() {
			if (_this.config.animation) {
			  _this._fixTransition();
			}

			var prevHoverState = _this._hoverState;
			_this._hoverState = null;
			$(_this.element).trigger(_this.constructor.Event.SHOWN);

			if (prevHoverState === HoverState.OUT) {
			  _this._leave(null, _this);
			}
		  };

		  if ($(this.tip).hasClass(ClassName$6.FADE)) {
			var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
			$(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
		  } else {
			complete();
		  }
		}
	  };

	  _proto.hide = function hide(callback) {
		var _this2 = this;

		var tip = this.getTipElement();
		var hideEvent = $.Event(this.constructor.Event.HIDE);

		var complete = function complete() {
		  if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
			tip.parentNode.removeChild(tip);
		  }

		  _this2._cleanTipClass();

		  _this2.element.removeAttribute('aria-describedby');

		  $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

		  if (_this2._popper !== null) {
			_this2._popper.destroy();
		  }

		  if (callback) {
			callback();
		  }
		};

		$(this.element).trigger(hideEvent);

		if (hideEvent.isDefaultPrevented()) {
		  return;
		}

		$(tip).removeClass(ClassName$6.SHOW); // If this is a touch-enabled device we remove the extra
		// empty mouseover listeners we added for iOS support

		if ('ontouchstart' in document.documentElement) {
		  $(document.body).children().off('mouseover', null, $.noop);
		}

		this._activeTrigger[Trigger.CLICK] = false;
		this._activeTrigger[Trigger.FOCUS] = false;
		this._activeTrigger[Trigger.HOVER] = false;

		if ($(this.tip).hasClass(ClassName$6.FADE)) {
		  var transitionDuration = Util.getTransitionDurationFromElement(tip);
		  $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
		} else {
		  complete();
		}

		this._hoverState = '';
	  };

	  _proto.update = function update() {
		if (this._popper !== null) {
		  this._popper.scheduleUpdate();
		}
	  } // Protected
	  ;

	  _proto.isWithContent = function isWithContent() {
		return Boolean(this.getTitle());
	  };

	  _proto.addAttachmentClass = function addAttachmentClass(attachment) {
		$(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
	  };

	  _proto.getTipElement = function getTipElement() {
		this.tip = this.tip || $(this.config.template)[0];
		return this.tip;
	  };

	  _proto.setContent = function setContent() {
		var tip = this.getTipElement();
		this.setElementContent($(tip.querySelectorAll(Selector$6.TOOLTIP_INNER)), this.getTitle());
		$(tip).removeClass(ClassName$6.FADE + " " + ClassName$6.SHOW);
	  };

	  _proto.setElementContent = function setElementContent($element, content) {
		if (typeof content === 'object' && (content.nodeType || content.jquery)) {
		  // Content is a DOM node or a jQuery
		  if (this.config.html) {
			if (!$(content).parent().is($element)) {
			  $element.empty().append(content);
			}
		  } else {
			$element.text($(content).text());
		  }

		  return;
		}

		if (this.config.html) {
		  if (this.config.sanitize) {
			content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);
		  }

		  $element.html(content);
		} else {
		  $element.text(content);
		}
	  };

	  _proto.getTitle = function getTitle() {
		var title = this.element.getAttribute('data-original-title');

		if (!title) {
		  title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
		}

		return title;
	  } // Private
	  ;

	  _proto._getOffset = function _getOffset() {
		var _this3 = this;

		var offset = {};

		if (typeof this.config.offset === 'function') {
		  offset.fn = function (data) {
			data.offsets = _objectSpread({}, data.offsets, _this3.config.offset(data.offsets, _this3.element) || {});
			return data;
		  };
		} else {
		  offset.offset = this.config.offset;
		}

		return offset;
	  };

	  _proto._getContainer = function _getContainer() {
		if (this.config.container === false) {
		  return document.body;
		}

		if (Util.isElement(this.config.container)) {
		  return $(this.config.container);
		}

		return $(document).find(this.config.container);
	  };

	  _proto._getAttachment = function _getAttachment(placement) {
		return AttachmentMap$1[placement.toUpperCase()];
	  };

	  _proto._setListeners = function _setListeners() {
		var _this4 = this;

		var triggers = this.config.trigger.split(' ');
		triggers.forEach(function (trigger) {
		  if (trigger === 'click') {
			$(_this4.element).on(_this4.constructor.Event.CLICK, _this4.config.selector, function (event) {
			  return _this4.toggle(event);
			});
		  } else if (trigger !== Trigger.MANUAL) {
			var eventIn = trigger === Trigger.HOVER ? _this4.constructor.Event.MOUSEENTER : _this4.constructor.Event.FOCUSIN;
			var eventOut = trigger === Trigger.HOVER ? _this4.constructor.Event.MOUSELEAVE : _this4.constructor.Event.FOCUSOUT;
			$(_this4.element).on(eventIn, _this4.config.selector, function (event) {
			  return _this4._enter(event);
			}).on(eventOut, _this4.config.selector, function (event) {
			  return _this4._leave(event);
			});
		  }
		});
		$(this.element).closest('.modal').on('hide.bs.modal', function () {
		  if (_this4.element) {
			_this4.hide();
		  }
		});

		if (this.config.selector) {
		  this.config = _objectSpread({}, this.config, {
			trigger: 'manual',
			selector: ''
		  });
		} else {
		  this._fixTitle();
		}
	  };

	  _proto._fixTitle = function _fixTitle() {
		var titleType = typeof this.element.getAttribute('data-original-title');

		if (this.element.getAttribute('title') || titleType !== 'string') {
		  this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
		  this.element.setAttribute('title', '');
		}
	  };

	  _proto._enter = function _enter(event, context) {
		var dataKey = this.constructor.DATA_KEY;
		context = context || $(event.currentTarget).data(dataKey);

		if (!context) {
		  context = new this.constructor(event.currentTarget, this._getDelegateConfig());
		  $(event.currentTarget).data(dataKey, context);
		}

		if (event) {
		  context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
		}

		if ($(context.getTipElement()).hasClass(ClassName$6.SHOW) || context._hoverState === HoverState.SHOW) {
		  context._hoverState = HoverState.SHOW;
		  return;
		}

		clearTimeout(context._timeout);
		context._hoverState = HoverState.SHOW;

		if (!context.config.delay || !context.config.delay.show) {
		  context.show();
		  return;
		}

		context._timeout = setTimeout(function () {
		  if (context._hoverState === HoverState.SHOW) {
			context.show();
		  }
		}, context.config.delay.show);
	  };

	  _proto._leave = function _leave(event, context) {
		var dataKey = this.constructor.DATA_KEY;
		context = context || $(event.currentTarget).data(dataKey);

		if (!context) {
		  context = new this.constructor(event.currentTarget, this._getDelegateConfig());
		  $(event.currentTarget).data(dataKey, context);
		}

		if (event) {
		  context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
		}

		if (context._isWithActiveTrigger()) {
		  return;
		}

		clearTimeout(context._timeout);
		context._hoverState = HoverState.OUT;

		if (!context.config.delay || !context.config.delay.hide) {
		  context.hide();
		  return;
		}

		context._timeout = setTimeout(function () {
		  if (context._hoverState === HoverState.OUT) {
			context.hide();
		  }
		}, context.config.delay.hide);
	  };

	  _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
		for (var trigger in this._activeTrigger) {
		  if (this._activeTrigger[trigger]) {
			return true;
		  }
		}

		return false;
	  };

	  _proto._getConfig = function _getConfig(config) {
		var dataAttributes = $(this.element).data();
		Object.keys(dataAttributes).forEach(function (dataAttr) {
		  if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {
			delete dataAttributes[dataAttr];
		  }
		});
		config = _objectSpread({}, this.constructor.Default, dataAttributes, typeof config === 'object' && config ? config : {});

		if (typeof config.delay === 'number') {
		  config.delay = {
			show: config.delay,
			hide: config.delay
		  };
		}

		if (typeof config.title === 'number') {
		  config.title = config.title.toString();
		}

		if (typeof config.content === 'number') {
		  config.content = config.content.toString();
		}

		Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);

		if (config.sanitize) {
		  config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);
		}

		return config;
	  };

	  _proto._getDelegateConfig = function _getDelegateConfig() {
		var config = {};

		if (this.config) {
		  for (var key in this.config) {
			if (this.constructor.Default[key] !== this.config[key]) {
			  config[key] = this.config[key];
			}
		  }
		}

		return config;
	  };

	  _proto._cleanTipClass = function _cleanTipClass() {
		var $tip = $(this.getTipElement());
		var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

		if (tabClass !== null && tabClass.length) {
		  $tip.removeClass(tabClass.join(''));
		}
	  };

	  _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {
		var popperInstance = popperData.instance;
		this.tip = popperInstance.popper;

		this._cleanTipClass();

		this.addAttachmentClass(this._getAttachment(popperData.placement));
	  };

	  _proto._fixTransition = function _fixTransition() {
		var tip = this.getTipElement();
		var initConfigAnimation = this.config.animation;

		if (tip.getAttribute('x-placement') !== null) {
		  return;
		}

		$(tip).removeClass(ClassName$6.FADE);
		this.config.animation = false;
		this.hide();
		this.show();
		this.config.animation = initConfigAnimation;
	  } // Static
	  ;

	  Tooltip._jQueryInterface = function _jQueryInterface(config) {
		return this.each(function () {
		  var data = $(this).data(DATA_KEY$6);

		  var _config = typeof config === 'object' && config;

		  if (!data && /dispose|hide/.test(config)) {
			return;
		  }

		  if (!data) {
			data = new Tooltip(this, _config);
			$(this).data(DATA_KEY$6, data);
		  }

		  if (typeof config === 'string') {
			if (typeof data[config] === 'undefined') {
			  throw new TypeError("No method named \"" + config + "\"");
			}

			data[config]();
		  }
		});
	  };

	  _createClass(Tooltip, null, [{
		key: "VERSION",
		get: function get() {
		  return VERSION$6;
		}
	  }, {
		key: "Default",
		get: function get() {
		  return Default$4;
		}
	  }, {
		key: "NAME",
		get: function get() {
		  return NAME$6;
		}
	  }, {
		key: "DATA_KEY",
		get: function get() {
		  return DATA_KEY$6;
		}
	  }, {
		key: "Event",
		get: function get() {
		  return Event$6;
		}
	  }, {
		key: "EVENT_KEY",
		get: function get() {
		  return EVENT_KEY$6;
		}
	  }, {
		key: "DefaultType",
		get: function get() {
		  return DefaultType$4;
		}
	  }]);

	  return Tooltip;
	}();
	/**
	 * ------------------------------------------------------------------------
	 * jQuery
	 * ------------------------------------------------------------------------
	 */


	$.fn[NAME$6] = Tooltip._jQueryInterface;
	$.fn[NAME$6].Constructor = Tooltip;

	$.fn[NAME$6].noConflict = function () {
	  $.fn[NAME$6] = JQUERY_NO_CONFLICT$6;
	  return Tooltip._jQueryInterface;
	};

	/**
	 * ------------------------------------------------------------------------
	 * Constants
	 * ------------------------------------------------------------------------
	 */

	var NAME$7 = 'popover';
	var VERSION$7 = '4.3.1';
	var DATA_KEY$7 = 'bs.popover';
	var EVENT_KEY$7 = "." + DATA_KEY$7;
	var JQUERY_NO_CONFLICT$7 = $.fn[NAME$7];
	var CLASS_PREFIX$1 = 'bs-popover';
	var BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\s)" + CLASS_PREFIX$1 + "\\S+", 'g');

	var Default$5 = _objectSpread({}, Tooltip.Default, {
	  placement: 'right',
	  trigger: 'click',
	  content: '',
	  template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
	});

	var DefaultType$5 = _objectSpread({}, Tooltip.DefaultType, {
	  content: '(string|element|function)'
	});

	var ClassName$7 = {
	  FADE: 'fade',
	  SHOW: 'show'
	};
	var Selector$7 = {
	  TITLE: '.popover-header',
	  CONTENT: '.popover-body'
	};
	var Event$7 = {
	  HIDE: "hide" + EVENT_KEY$7,
	  HIDDEN: "hidden" + EVENT_KEY$7,
	  SHOW: "show" + EVENT_KEY$7,
	  SHOWN: "shown" + EVENT_KEY$7,
	  INSERTED: "inserted" + EVENT_KEY$7,
	  CLICK: "click" + EVENT_KEY$7,
	  FOCUSIN: "focusin" + EVENT_KEY$7,
	  FOCUSOUT: "focusout" + EVENT_KEY$7,
	  MOUSEENTER: "mouseenter" + EVENT_KEY$7,
	  MOUSELEAVE: "mouseleave" + EVENT_KEY$7
	  /**
	   * ------------------------------------------------------------------------
	   * Class Definition
	   * ------------------------------------------------------------------------
	   */

	};

	var Popover =
	/*#__PURE__*/
	function (_Tooltip) {
	  _inheritsLoose(Popover, _Tooltip);

	  function Popover() {
		return _Tooltip.apply(this, arguments) || this;
	  }

	  var _proto = Popover.prototype;

	  // Overrides
	  _proto.isWithContent = function isWithContent() {
		return this.getTitle() || this._getContent();
	  };

	  _proto.addAttachmentClass = function addAttachmentClass(attachment) {
		$(this.getTipElement()).addClass(CLASS_PREFIX$1 + "-" + attachment);
	  };

	  _proto.getTipElement = function getTipElement() {
		this.tip = this.tip || $(this.config.template)[0];
		return this.tip;
	  };

	  _proto.setContent = function setContent() {
		var $tip = $(this.getTipElement()); // We use append for html objects to maintain js events

		this.setElementContent($tip.find(Selector$7.TITLE), this.getTitle());

		var content = this._getContent();

		if (typeof content === 'function') {
		  content = content.call(this.element);
		}

		this.setElementContent($tip.find(Selector$7.CONTENT), content);
		$tip.removeClass(ClassName$7.FADE + " " + ClassName$7.SHOW);
	  } // Private
	  ;

	  _proto._getContent = function _getContent() {
		return this.element.getAttribute('data-content') || this.config.content;
	  };

	  _proto._cleanTipClass = function _cleanTipClass() {
		var $tip = $(this.getTipElement());
		var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX$1);

		if (tabClass !== null && tabClass.length > 0) {
		  $tip.removeClass(tabClass.join(''));
		}
	  } // Static
	  ;

	  Popover._jQueryInterface = function _jQueryInterface(config) {
		return this.each(function () {
		  var data = $(this).data(DATA_KEY$7);

		  var _config = typeof config === 'object' ? config : null;

		  if (!data && /dispose|hide/.test(config)) {
			return;
		  }

		  if (!data) {
			data = new Popover(this, _config);
			$(this).data(DATA_KEY$7, data);
		  }

		  if (typeof config === 'string') {
			if (typeof data[config] === 'undefined') {
			  throw new TypeError("No method named \"" + config + "\"");
			}

			data[config]();
		  }
		});
	  };

	  _createClass(Popover, null, [{
		key: "VERSION",
		// Getters
		get: function get() {
		  return VERSION$7;
		}
	  }, {
		key: "Default",
		get: function get() {
		  return Default$5;
		}
	  }, {
		key: "NAME",
		get: function get() {
		  return NAME$7;
		}
	  }, {
		key: "DATA_KEY",
		get: function get() {
		  return DATA_KEY$7;
		}
	  }, {
		key: "Event",
		get: function get() {
		  return Event$7;
		}
	  }, {
		key: "EVENT_KEY",
		get: function get() {
		  return EVENT_KEY$7;
		}
	  }, {
		key: "DefaultType",
		get: function get() {
		  return DefaultType$5;
		}
	  }]);

	  return Popover;
	}(Tooltip);
	/**
	 * ------------------------------------------------------------------------
	 * jQuery
	 * ------------------------------------------------------------------------
	 */


	$.fn[NAME$7] = Popover._jQueryInterface;
	$.fn[NAME$7].Constructor = Popover;

	$.fn[NAME$7].noConflict = function () {
	  $.fn[NAME$7] = JQUERY_NO_CONFLICT$7;
	  return Popover._jQueryInterface;
	};

	/**
	 * ------------------------------------------------------------------------
	 * Constants
	 * ------------------------------------------------------------------------
	 */

	var NAME$8 = 'scrollspy';
	var VERSION$8 = '4.3.1';
	var DATA_KEY$8 = 'bs.scrollspy';
	var EVENT_KEY$8 = "." + DATA_KEY$8;
	var DATA_API_KEY$6 = '.data-api';
	var JQUERY_NO_CONFLICT$8 = $.fn[NAME$8];
	var Default$6 = {
	  offset: 10,
	  method: 'auto',
	  target: ''
	};
	var DefaultType$6 = {
	  offset: 'number',
	  method: 'string',
	  target: '(string|element)'
	};
	var Event$8 = {
	  ACTIVATE: "activate" + EVENT_KEY$8,
	  SCROLL: "scroll" + EVENT_KEY$8,
	  LOAD_DATA_API: "load" + EVENT_KEY$8 + DATA_API_KEY$6
	};
	var ClassName$8 = {
	  DROPDOWN_ITEM: 'dropdown-item',
	  DROPDOWN_MENU: 'dropdown-menu',
	  ACTIVE: 'active'
	};
	var Selector$8 = {
	  DATA_SPY: '[data-spy="scroll"]',
	  ACTIVE: '.active',
	  NAV_LIST_GROUP: '.nav, .list-group',
	  NAV_LINKS: '.nav-link',
	  NAV_ITEMS: '.nav-item',
	  LIST_ITEMS: '.list-group-item',
	  DROPDOWN: '.dropdown',
	  DROPDOWN_ITEMS: '.dropdown-item',
	  DROPDOWN_TOGGLE: '.dropdown-toggle'
	};
	var OffsetMethod = {
	  OFFSET: 'offset',
	  POSITION: 'position'
	  /**
	   * ------------------------------------------------------------------------
	   * Class Definition
	   * ------------------------------------------------------------------------
	   */

	};

	var ScrollSpy =
	/*#__PURE__*/
	function () {
	  function ScrollSpy(element, config) {
		var _this = this;

		this._element = element;
		this._scrollElement = element.tagName === 'BODY' ? window : element;
		this._config = this._getConfig(config);
		this._selector = this._config.target + " " + Selector$8.NAV_LINKS + "," + (this._config.target + " " + Selector$8.LIST_ITEMS + ",") + (this._config.target + " " + Selector$8.DROPDOWN_ITEMS);
		this._offsets = [];
		this._targets = [];
		this._activeTarget = null;
		this._scrollHeight = 0;
		$(this._scrollElement).on(Event$8.SCROLL, function (event) {
		  return _this._process(event);
		});
		this.refresh();

		this._process();
	  } // Getters


	  var _proto = ScrollSpy.prototype;

	  // Public
	  _proto.refresh = function refresh() {
		var _this2 = this;

		var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
		var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
		var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
		this._offsets = [];
		this._targets = [];
		this._scrollHeight = this._getScrollHeight();
		var targets = [].slice.call(document.querySelectorAll(this._selector));
		targets.map(function (element) {
		  var target;
		  var targetSelector = Util.getSelectorFromElement(element);

		  if (targetSelector) {
			target = document.querySelector(targetSelector);
		  }

		  if (target) {
			var targetBCR = target.getBoundingClientRect();

			if (targetBCR.width || targetBCR.height) {
			  // TODO (fat): remove sketch reliance on jQuery position/offset
			  return [$(target)[offsetMethod]().top + offsetBase, targetSelector];
			}
		  }

		  return null;
		}).filter(function (item) {
		  return item;
		}).sort(function (a, b) {
		  return a[0] - b[0];
		}).forEach(function (item) {
		  _this2._offsets.push(item[0]);

		  _this2._targets.push(item[1]);
		});
	  };

	  _proto.dispose = function dispose() {
		$.removeData(this._element, DATA_KEY$8);
		$(this._scrollElement).off(EVENT_KEY$8);
		this._element = null;
		this._scrollElement = null;
		this._config = null;
		this._selector = null;
		this._offsets = null;
		this._targets = null;
		this._activeTarget = null;
		this._scrollHeight = null;
	  } // Private
	  ;

	  _proto._getConfig = function _getConfig(config) {
		config = _objectSpread({}, Default$6, typeof config === 'object' && config ? config : {});

		if (typeof config.target !== 'string') {
		  var id = $(config.target).attr('id');

		  if (!id) {
			id = Util.getUID(NAME$8);
			$(config.target).attr('id', id);
		  }

		  config.target = "#" + id;
		}

		Util.typeCheckConfig(NAME$8, config, DefaultType$6);
		return config;
	  };

	  _proto._getScrollTop = function _getScrollTop() {
		return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
	  };

	  _proto._getScrollHeight = function _getScrollHeight() {
		return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
	  };

	  _proto._getOffsetHeight = function _getOffsetHeight() {
		return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
	  };

	  _proto._process = function _process() {
		var scrollTop = this._getScrollTop() + this._config.offset;

		var scrollHeight = this._getScrollHeight();

		var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

		if (this._scrollHeight !== scrollHeight) {
		  this.refresh();
		}

		if (scrollTop >= maxScroll) {
		  var target = this._targets[this._targets.length - 1];

		  if (this._activeTarget !== target) {
			this._activate(target);
		  }

		  return;
		}

		if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
		  this._activeTarget = null;

		  this._clear();

		  return;
		}

		var offsetLength = this._offsets.length;

		for (var i = offsetLength; i--;) {
		  var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

		  if (isActiveTarget) {
			this._activate(this._targets[i]);
		  }
		}
	  };

	  _proto._activate = function _activate(target) {
		this._activeTarget = target;

		this._clear();

		var queries = this._selector.split(',').map(function (selector) {
		  return selector + "[data-target=\"" + target + "\"]," + selector + "[href=\"" + target + "\"]";
		});

		var $link = $([].slice.call(document.querySelectorAll(queries.join(','))));

		if ($link.hasClass(ClassName$8.DROPDOWN_ITEM)) {
		  $link.closest(Selector$8.DROPDOWN).find(Selector$8.DROPDOWN_TOGGLE).addClass(ClassName$8.ACTIVE);
		  $link.addClass(ClassName$8.ACTIVE);
		} else {
		  // Set triggered link as active
		  $link.addClass(ClassName$8.ACTIVE); // Set triggered links parents as active
		  // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor

		  $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_LINKS + ", " + Selector$8.LIST_ITEMS).addClass(ClassName$8.ACTIVE); // Handle special case when .nav-link is inside .nav-item

		  $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_ITEMS).children(Selector$8.NAV_LINKS).addClass(ClassName$8.ACTIVE);
		}

		$(this._scrollElement).trigger(Event$8.ACTIVATE, {
		  relatedTarget: target
		});
	  };

	  _proto._clear = function _clear() {
		[].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {
		  return node.classList.contains(ClassName$8.ACTIVE);
		}).forEach(function (node) {
		  return node.classList.remove(ClassName$8.ACTIVE);
		});
	  } // Static
	  ;

	  ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
		return this.each(function () {
		  var data = $(this).data(DATA_KEY$8);

		  var _config = typeof config === 'object' && config;

		  if (!data) {
			data = new ScrollSpy(this, _config);
			$(this).data(DATA_KEY$8, data);
		  }

		  if (typeof config === 'string') {
			if (typeof data[config] === 'undefined') {
			  throw new TypeError("No method named \"" + config + "\"");
			}

			data[config]();
		  }
		});
	  };

	  _createClass(ScrollSpy, null, [{
		key: "VERSION",
		get: function get() {
		  return VERSION$8;
		}
	  }, {
		key: "Default",
		get: function get() {
		  return Default$6;
		}
	  }]);

	  return ScrollSpy;
	}();
	/**
	 * ------------------------------------------------------------------------
	 * Data Api implementation
	 * ------------------------------------------------------------------------
	 */


	$(window).on(Event$8.LOAD_DATA_API, function () {
	  var scrollSpys = [].slice.call(document.querySelectorAll(Selector$8.DATA_SPY));
	  var scrollSpysLength = scrollSpys.length;

	  for (var i = scrollSpysLength; i--;) {
		var $spy = $(scrollSpys[i]);

		ScrollSpy._jQueryInterface.call($spy, $spy.data());
	  }
	});
	/**
	 * ------------------------------------------------------------------------
	 * jQuery
	 * ------------------------------------------------------------------------
	 */

	$.fn[NAME$8] = ScrollSpy._jQueryInterface;
	$.fn[NAME$8].Constructor = ScrollSpy;

	$.fn[NAME$8].noConflict = function () {
	  $.fn[NAME$8] = JQUERY_NO_CONFLICT$8;
	  return ScrollSpy._jQueryInterface;
	};

	/**
	 * ------------------------------------------------------------------------
	 * Constants
	 * ------------------------------------------------------------------------
	 */

	var NAME$9 = 'tab';
	var VERSION$9 = '4.3.1';
	var DATA_KEY$9 = 'bs.tab';
	var EVENT_KEY$9 = "." + DATA_KEY$9;
	var DATA_API_KEY$7 = '.data-api';
	var JQUERY_NO_CONFLICT$9 = $.fn[NAME$9];
	var Event$9 = {
	  HIDE: "hide" + EVENT_KEY$9,
	  HIDDEN: "hidden" + EVENT_KEY$9,
	  SHOW: "show" + EVENT_KEY$9,
	  SHOWN: "shown" + EVENT_KEY$9,
	  CLICK_DATA_API: "click" + EVENT_KEY$9 + DATA_API_KEY$7
	};
	var ClassName$9 = {
	  DROPDOWN_MENU: 'dropdown-menu',
	  ACTIVE: 'active',
	  DISABLED: 'disabled',
	  FADE: 'fade',
	  SHOW: 'show'
	};
	var Selector$9 = {
	  DROPDOWN: '.dropdown',
	  NAV_LIST_GROUP: '.nav, .list-group',
	  ACTIVE: '.active',
	  ACTIVE_UL: '> li > .active',
	  DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
	  DROPDOWN_TOGGLE: '.dropdown-toggle',
	  DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'
	  /**
	   * ------------------------------------------------------------------------
	   * Class Definition
	   * ------------------------------------------------------------------------
	   */

	};

	var Tab =
	/*#__PURE__*/
	function () {
	  function Tab(element) {
		this._element = element;
	  } // Getters


	  var _proto = Tab.prototype;

	  // Public
	  _proto.show = function show() {
		var _this = this;

		if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName$9.ACTIVE) || $(this._element).hasClass(ClassName$9.DISABLED)) {
		  return;
		}

		var target;
		var previous;
		var listElement = $(this._element).closest(Selector$9.NAV_LIST_GROUP)[0];
		var selector = Util.getSelectorFromElement(this._element);

		if (listElement) {
		  var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? Selector$9.ACTIVE_UL : Selector$9.ACTIVE;
		  previous = $.makeArray($(listElement).find(itemSelector));
		  previous = previous[previous.length - 1];
		}

		var hideEvent = $.Event(Event$9.HIDE, {
		  relatedTarget: this._element
		});
		var showEvent = $.Event(Event$9.SHOW, {
		  relatedTarget: previous
		});

		if (previous) {
		  $(previous).trigger(hideEvent);
		}

		$(this._element).trigger(showEvent);

		if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
		  return;
		}

		if (selector) {
		  target = document.querySelector(selector);
		}

		this._activate(this._element, listElement);

		var complete = function complete() {
		  var hiddenEvent = $.Event(Event$9.HIDDEN, {
			relatedTarget: _this._element
		  });
		  var shownEvent = $.Event(Event$9.SHOWN, {
			relatedTarget: previous
		  });
		  $(previous).trigger(hiddenEvent);
		  $(_this._element).trigger(shownEvent);
		};

		if (target) {
		  this._activate(target, target.parentNode, complete);
		} else {
		  complete();
		}
	  };

	  _proto.dispose = function dispose() {
		$.removeData(this._element, DATA_KEY$9);
		this._element = null;
	  } // Private
	  ;

	  _proto._activate = function _activate(element, container, callback) {
		var _this2 = this;

		var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? $(container).find(Selector$9.ACTIVE_UL) : $(container).children(Selector$9.ACTIVE);
		var active = activeElements[0];
		var isTransitioning = callback && active && $(active).hasClass(ClassName$9.FADE);

		var complete = function complete() {
		  return _this2._transitionComplete(element, active, callback);
		};

		if (active && isTransitioning) {
		  var transitionDuration = Util.getTransitionDurationFromElement(active);
		  $(active).removeClass(ClassName$9.SHOW).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
		} else {
		  complete();
		}
	  };

	  _proto._transitionComplete = function _transitionComplete(element, active, callback) {
		if (active) {
		  $(active).removeClass(ClassName$9.ACTIVE);
		  var dropdownChild = $(active.parentNode).find(Selector$9.DROPDOWN_ACTIVE_CHILD)[0];

		  if (dropdownChild) {
			$(dropdownChild).removeClass(ClassName$9.ACTIVE);
		  }

		  if (active.getAttribute('role') === 'tab') {
			active.setAttribute('aria-selected', false);
		  }
		}

		$(element).addClass(ClassName$9.ACTIVE);

		if (element.getAttribute('role') === 'tab') {
		  element.setAttribute('aria-selected', true);
		}

		Util.reflow(element);

		if (element.classList.contains(ClassName$9.FADE)) {
		  element.classList.add(ClassName$9.SHOW);
		}

		if (element.parentNode && $(element.parentNode).hasClass(ClassName$9.DROPDOWN_MENU)) {
		  var dropdownElement = $(element).closest(Selector$9.DROPDOWN)[0];

		  if (dropdownElement) {
			var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(Selector$9.DROPDOWN_TOGGLE));
			$(dropdownToggleList).addClass(ClassName$9.ACTIVE);
		  }

		  element.setAttribute('aria-expanded', true);
		}

		if (callback) {
		  callback();
		}
	  } // Static
	  ;

	  Tab._jQueryInterface = function _jQueryInterface(config) {
		return this.each(function () {
		  var $this = $(this);
		  var data = $this.data(DATA_KEY$9);

		  if (!data) {
			data = new Tab(this);
			$this.data(DATA_KEY$9, data);
		  }

		  if (typeof config === 'string') {
			if (typeof data[config] === 'undefined') {
			  throw new TypeError("No method named \"" + config + "\"");
			}

			data[config]();
		  }
		});
	  };

	  _createClass(Tab, null, [{
		key: "VERSION",
		get: function get() {
		  return VERSION$9;
		}
	  }]);

	  return Tab;
	}();
	/**
	 * ------------------------------------------------------------------------
	 * Data Api implementation
	 * ------------------------------------------------------------------------
	 */


	$(document).on(Event$9.CLICK_DATA_API, Selector$9.DATA_TOGGLE, function (event) {
	  event.preventDefault();

	  Tab._jQueryInterface.call($(this), 'show');
	});
	/**
	 * ------------------------------------------------------------------------
	 * jQuery
	 * ------------------------------------------------------------------------
	 */

	$.fn[NAME$9] = Tab._jQueryInterface;
	$.fn[NAME$9].Constructor = Tab;

	$.fn[NAME$9].noConflict = function () {
	  $.fn[NAME$9] = JQUERY_NO_CONFLICT$9;
	  return Tab._jQueryInterface;
	};

	/**
	 * ------------------------------------------------------------------------
	 * Constants
	 * ------------------------------------------------------------------------
	 */

	var NAME$a = 'toast';
	var VERSION$a = '4.3.1';
	var DATA_KEY$a = 'bs.toast';
	var EVENT_KEY$a = "." + DATA_KEY$a;
	var JQUERY_NO_CONFLICT$a = $.fn[NAME$a];
	var Event$a = {
	  CLICK_DISMISS: "click.dismiss" + EVENT_KEY$a,
	  HIDE: "hide" + EVENT_KEY$a,
	  HIDDEN: "hidden" + EVENT_KEY$a,
	  SHOW: "show" + EVENT_KEY$a,
	  SHOWN: "shown" + EVENT_KEY$a
	};
	var ClassName$a = {
	  FADE: 'fade',
	  HIDE: 'hide',
	  SHOW: 'show',
	  SHOWING: 'showing'
	};
	var DefaultType$7 = {
	  animation: 'boolean',
	  autohide: 'boolean',
	  delay: 'number'
	};
	var Default$7 = {
	  animation: true,
	  autohide: true,
	  delay: 500
	};
	var Selector$a = {
	  DATA_DISMISS: '[data-dismiss="toast"]'
	  /**
	   * ------------------------------------------------------------------------
	   * Class Definition
	   * ------------------------------------------------------------------------
	   */

	};

	var Toast =
	/*#__PURE__*/
	function () {
	  function Toast(element, config) {
		this._element = element;
		this._config = this._getConfig(config);
		this._timeout = null;

		this._setListeners();
	  } // Getters


	  var _proto = Toast.prototype;

	  // Public
	  _proto.show = function show() {
		var _this = this;

		$(this._element).trigger(Event$a.SHOW);

		if (this._config.animation) {
		  this._element.classList.add(ClassName$a.FADE);
		}

		var complete = function complete() {
		  _this._element.classList.remove(ClassName$a.SHOWING);

		  _this._element.classList.add(ClassName$a.SHOW);

		  $(_this._element).trigger(Event$a.SHOWN);

		  if (_this._config.autohide) {
			_this.hide();
		  }
		};

		this._element.classList.remove(ClassName$a.HIDE);

		this._element.classList.add(ClassName$a.SHOWING);

		if (this._config.animation) {
		  var transitionDuration = Util.getTransitionDurationFromElement(this._element);
		  $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
		} else {
		  complete();
		}
	  };

	  _proto.hide = function hide(withoutTimeout) {
		var _this2 = this;

		if (!this._element.classList.contains(ClassName$a.SHOW)) {
		  return;
		}

		$(this._element).trigger(Event$a.HIDE);

		if (withoutTimeout) {
		  this._close();
		} else {
		  this._timeout = setTimeout(function () {
			_this2._close();
		  }, this._config.delay);
		}
	  };

	  _proto.dispose = function dispose() {
		clearTimeout(this._timeout);
		this._timeout = null;

		if (this._element.classList.contains(ClassName$a.SHOW)) {
		  this._element.classList.remove(ClassName$a.SHOW);
		}

		$(this._element).off(Event$a.CLICK_DISMISS);
		$.removeData(this._element, DATA_KEY$a);
		this._element = null;
		this._config = null;
	  } // Private
	  ;

	  _proto._getConfig = function _getConfig(config) {
		config = _objectSpread({}, Default$7, $(this._element).data(), typeof config === 'object' && config ? config : {});
		Util.typeCheckConfig(NAME$a, config, this.constructor.DefaultType);
		return config;
	  };

	  _proto._setListeners = function _setListeners() {
		var _this3 = this;

		$(this._element).on(Event$a.CLICK_DISMISS, Selector$a.DATA_DISMISS, function () {
		  return _this3.hide(true);
		});
	  };

	  _proto._close = function _close() {
		var _this4 = this;

		var complete = function complete() {
		  _this4._element.classList.add(ClassName$a.HIDE);

		  $(_this4._element).trigger(Event$a.HIDDEN);
		};

		this._element.classList.remove(ClassName$a.SHOW);

		if (this._config.animation) {
		  var transitionDuration = Util.getTransitionDurationFromElement(this._element);
		  $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
		} else {
		  complete();
		}
	  } // Static
	  ;

	  Toast._jQueryInterface = function _jQueryInterface(config) {
		return this.each(function () {
		  var $element = $(this);
		  var data = $element.data(DATA_KEY$a);

		  var _config = typeof config === 'object' && config;

		  if (!data) {
			data = new Toast(this, _config);
			$element.data(DATA_KEY$a, data);
		  }

		  if (typeof config === 'string') {
			if (typeof data[config] === 'undefined') {
			  throw new TypeError("No method named \"" + config + "\"");
			}

			data[config](this);
		  }
		});
	  };

	  _createClass(Toast, null, [{
		key: "VERSION",
		get: function get() {
		  return VERSION$a;
		}
	  }, {
		key: "DefaultType",
		get: function get() {
		  return DefaultType$7;
		}
	  }, {
		key: "Default",
		get: function get() {
		  return Default$7;
		}
	  }]);

	  return Toast;
	}();
	/**
	 * ------------------------------------------------------------------------
	 * jQuery
	 * ------------------------------------------------------------------------
	 */


	$.fn[NAME$a] = Toast._jQueryInterface;
	$.fn[NAME$a].Constructor = Toast;

	$.fn[NAME$a].noConflict = function () {
	  $.fn[NAME$a] = JQUERY_NO_CONFLICT$a;
	  return Toast._jQueryInterface;
	};

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.3.1): index.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	(function () {
	  if (typeof $ === 'undefined') {
		throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
	  }

	  var version = $.fn.jquery.split(' ')[0].split('.');
	  var minMajor = 1;
	  var ltMajor = 2;
	  var minMinor = 9;
	  var minPatch = 1;
	  var maxMajor = 4;

	  if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
		throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
	  }
	})();

	exports.Util = Util;
	exports.Alert = Alert;
	exports.Button = Button;
	exports.Carousel = Carousel;
	exports.Collapse = Collapse;
	exports.Dropdown = Dropdown;
	exports.Modal = Modal;
	exports.Popover = Popover;
	exports.Scrollspy = ScrollSpy;
	exports.Tab = Tab;
	exports.Toast = Toast;
	exports.Tooltip = Tooltip;

	Object.defineProperty(exports, '__esModule', { value: true });

  }));
  //# sourceMappingURL=bootstrap.bundle.js.map

  /*
	   _ _      _       _
   ___| (_) ___| | __  (_)___
  / __| | |/ __| |/ /  | / __|
  \__ \ | | (__|   < _ | \__ \
  |___/_|_|\___|_|\_(_)/ |___/
					 |__/

   Version: 1.8.1
	Author: Ken Wheeler
   Website: http://kenwheeler.github.io
	  Docs: http://kenwheeler.github.io/slick
	  Repo: http://github.com/kenwheeler/slick
	Issues: http://github.com/kenwheeler/slick/issues

   */
  /* global window, document, define, jQuery, setInterval, clearInterval */
  ;(function(factory) {
	  'use strict';
	  if (typeof define === 'function' && define.amd) {
		  define(['jquery'], factory);
	  } else if (typeof exports !== 'undefined') {
		  module.exports = factory(require('jquery'));
	  } else {
		  factory(jQuery);
	  }

  }(function($) {
	  'use strict';
	  var Slick = window.Slick || {};

	  Slick = (function() {

		  var instanceUid = 0;

		  function Slick(element, settings) {

			  var _ = this, dataSettings;

			  _.defaults = {
				  accessibility: true,
				  adaptiveHeight: false,
				  appendArrows: $(element),
				  appendDots: $(element),
				  arrows: true,
				  asNavFor: null,
				  prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
				  nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
				  autoplay: false,
				  autoplaySpeed: 3000,
				  centerMode: false,
				  centerPadding: '50px',
				  cssEase: 'ease',
				  customPaging: function(slider, i) {
					  return $('<button type="button" />').text(i + 1);
				  },
				  dots: false,
				  dotsClass: 'slick-dots',
				  draggable: true,
				  easing: 'linear',
				  edgeFriction: 0.35,
				  fade: false,
				  focusOnSelect: false,
				  focusOnChange: false,
				  infinite: true,
				  initialSlide: 0,
				  lazyLoad: 'ondemand',
				  mobileFirst: false,
				  pauseOnHover: true,
				  pauseOnFocus: true,
				  pauseOnDotsHover: false,
				  respondTo: 'window',
				  responsive: null,
				  rows: 1,
				  rtl: false,
				  slide: '',
				  slidesPerRow: 1,
				  slidesToShow: 1,
				  slidesToScroll: 1,
				  speed: 500,
				  swipe: true,
				  swipeToSlide: false,
				  touchMove: true,
				  touchThreshold: 5,
				  useCSS: true,
				  useTransform: true,
				  variableWidth: false,
				  vertical: false,
				  verticalSwiping: false,
				  waitForAnimate: true,
				  zIndex: 1000
			  };

			  _.initials = {
				  animating: false,
				  dragging: false,
				  autoPlayTimer: null,
				  currentDirection: 0,
				  currentLeft: null,
				  currentSlide: 0,
				  direction: 1,
				  $dots: null,
				  listWidth: null,
				  listHeight: null,
				  loadIndex: 0,
				  $nextArrow: null,
				  $prevArrow: null,
				  scrolling: false,
				  slideCount: null,
				  slideWidth: null,
				  $slideTrack: null,
				  $slides: null,
				  sliding: false,
				  slideOffset: 0,
				  swipeLeft: null,
				  swiping: false,
				  $list: null,
				  touchObject: {},
				  transformsEnabled: false,
				  unslicked: false
			  };

			  $.extend(_, _.initials);

			  _.activeBreakpoint = null;
			  _.animType = null;
			  _.animProp = null;
			  _.breakpoints = [];
			  _.breakpointSettings = [];
			  _.cssTransitions = false;
			  _.focussed = false;
			  _.interrupted = false;
			  _.hidden = 'hidden';
			  _.paused = true;
			  _.positionProp = null;
			  _.respondTo = null;
			  _.rowCount = 1;
			  _.shouldClick = true;
			  _.$slider = $(element);
			  _.$slidesCache = null;
			  _.transformType = null;
			  _.transitionType = null;
			  _.visibilityChange = 'visibilitychange';
			  _.windowWidth = 0;
			  _.windowTimer = null;

			  dataSettings = $(element).data('slick') || {};

			  _.options = $.extend({}, _.defaults, settings, dataSettings);

			  _.currentSlide = _.options.initialSlide;

			  _.originalSettings = _.options;

			  if (typeof document.mozHidden !== 'undefined') {
				  _.hidden = 'mozHidden';
				  _.visibilityChange = 'mozvisibilitychange';
			  } else if (typeof document.webkitHidden !== 'undefined') {
				  _.hidden = 'webkitHidden';
				  _.visibilityChange = 'webkitvisibilitychange';
			  }

			  _.autoPlay = $.proxy(_.autoPlay, _);
			  _.autoPlayClear = $.proxy(_.autoPlayClear, _);
			  _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
			  _.changeSlide = $.proxy(_.changeSlide, _);
			  _.clickHandler = $.proxy(_.clickHandler, _);
			  _.selectHandler = $.proxy(_.selectHandler, _);
			  _.setPosition = $.proxy(_.setPosition, _);
			  _.swipeHandler = $.proxy(_.swipeHandler, _);
			  _.dragHandler = $.proxy(_.dragHandler, _);
			  _.keyHandler = $.proxy(_.keyHandler, _);

			  _.instanceUid = instanceUid++;

			  // A simple way to check for HTML strings
			  // Strict HTML recognition (must start with <)
			  // Extracted from jQuery v1.11 source
			  _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;


			  _.registerBreakpoints();
			  _.init(true);

		  }

		  return Slick;

	  }());

	  Slick.prototype.activateADA = function() {
		  var _ = this;

		  _.$slideTrack.find('.slick-active').attr({
			  'aria-hidden': 'false'
		  }).find('a, input, button, select').attr({
			  'tabindex': '0'
		  });

	  };

	  Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {

		  var _ = this;

		  if (typeof(index) === 'boolean') {
			  addBefore = index;
			  index = null;
		  } else if (index < 0 || (index >= _.slideCount)) {
			  return false;
		  }

		  _.unload();

		  if (typeof(index) === 'number') {
			  if (index === 0 && _.$slides.length === 0) {
				  $(markup).appendTo(_.$slideTrack);
			  } else if (addBefore) {
				  $(markup).insertBefore(_.$slides.eq(index));
			  } else {
				  $(markup).insertAfter(_.$slides.eq(index));
			  }
		  } else {
			  if (addBefore === true) {
				  $(markup).prependTo(_.$slideTrack);
			  } else {
				  $(markup).appendTo(_.$slideTrack);
			  }
		  }

		  _.$slides = _.$slideTrack.children(this.options.slide);

		  _.$slideTrack.children(this.options.slide).detach();

		  _.$slideTrack.append(_.$slides);

		  _.$slides.each(function(index, element) {
			  $(element).attr('data-slick-index', index);
		  });

		  _.$slidesCache = _.$slides;

		  _.reinit();

	  };

	  Slick.prototype.animateHeight = function() {
		  var _ = this;
		  if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
			  var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
			  _.$list.animate({
				  height: targetHeight
			  }, _.options.speed);
		  }
	  };

	  Slick.prototype.animateSlide = function(targetLeft, callback) {

		  var animProps = {},
			  _ = this;

		  _.animateHeight();

		  if (_.options.rtl === true && _.options.vertical === false) {
			  targetLeft = -targetLeft;
		  }
		  if (_.transformsEnabled === false) {
			  if (_.options.vertical === false) {
				  _.$slideTrack.animate({
					  left: targetLeft
				  }, _.options.speed, _.options.easing, callback);
			  } else {
				  _.$slideTrack.animate({
					  top: targetLeft
				  }, _.options.speed, _.options.easing, callback);
			  }

		  } else {

			  if (_.cssTransitions === false) {
				  if (_.options.rtl === true) {
					  _.currentLeft = -(_.currentLeft);
				  }
				  $({
					  animStart: _.currentLeft
				  }).animate({
					  animStart: targetLeft
				  }, {
					  duration: _.options.speed,
					  easing: _.options.easing,
					  step: function(now) {
						  now = Math.ceil(now);
						  if (_.options.vertical === false) {
							  animProps[_.animType] = 'translate(' +
								  now + 'px, 0px)';
							  _.$slideTrack.css(animProps);
						  } else {
							  animProps[_.animType] = 'translate(0px,' +
								  now + 'px)';
							  _.$slideTrack.css(animProps);
						  }
					  },
					  complete: function() {
						  if (callback) {
							  callback.call();
						  }
					  }
				  });

			  } else {

				  _.applyTransition();
				  targetLeft = Math.ceil(targetLeft);

				  if (_.options.vertical === false) {
					  animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
				  } else {
					  animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
				  }
				  _.$slideTrack.css(animProps);

				  if (callback) {
					  setTimeout(function() {

						  _.disableTransition();

						  callback.call();
					  }, _.options.speed);
				  }

			  }

		  }

	  };

	  Slick.prototype.getNavTarget = function() {

		  var _ = this,
			  asNavFor = _.options.asNavFor;

		  if ( asNavFor && asNavFor !== null ) {
			  asNavFor = $(asNavFor).not(_.$slider);
		  }

		  return asNavFor;

	  };

	  Slick.prototype.asNavFor = function(index) {

		  var _ = this,
			  asNavFor = _.getNavTarget();

		  if ( asNavFor !== null && typeof asNavFor === 'object' ) {
			  asNavFor.each(function() {
				  var target = $(this).slick('getSlick');
				  if(!target.unslicked) {
					  target.slideHandler(index, true);
				  }
			  });
		  }

	  };

	  Slick.prototype.applyTransition = function(slide) {

		  var _ = this,
			  transition = {};

		  if (_.options.fade === false) {
			  transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
		  } else {
			  transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
		  }

		  if (_.options.fade === false) {
			  _.$slideTrack.css(transition);
		  } else {
			  _.$slides.eq(slide).css(transition);
		  }

	  };

	  Slick.prototype.autoPlay = function() {

		  var _ = this;

		  _.autoPlayClear();

		  if ( _.slideCount > _.options.slidesToShow ) {
			  _.autoPlayTimer = setInterval( _.autoPlayIterator, _.options.autoplaySpeed );
		  }

	  };

	  Slick.prototype.autoPlayClear = function() {

		  var _ = this;

		  if (_.autoPlayTimer) {
			  clearInterval(_.autoPlayTimer);
		  }

	  };

	  Slick.prototype.autoPlayIterator = function() {

		  var _ = this,
			  slideTo = _.currentSlide + _.options.slidesToScroll;

		  if ( !_.paused && !_.interrupted && !_.focussed ) {

			  if ( _.options.infinite === false ) {

				  if ( _.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {
					  _.direction = 0;
				  }

				  else if ( _.direction === 0 ) {

					  slideTo = _.currentSlide - _.options.slidesToScroll;

					  if ( _.currentSlide - 1 === 0 ) {
						  _.direction = 1;
					  }

				  }

			  }

			  _.slideHandler( slideTo );

		  }

	  };

	  Slick.prototype.buildArrows = function() {

		  var _ = this;

		  if (_.options.arrows === true ) {

			  _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
			  _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

			  if( _.slideCount > _.options.slidesToShow ) {

				  _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
				  _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

				  if (_.htmlExpr.test(_.options.prevArrow)) {
					  _.$prevArrow.prependTo(_.options.appendArrows);
				  }

				  if (_.htmlExpr.test(_.options.nextArrow)) {
					  _.$nextArrow.appendTo(_.options.appendArrows);
				  }

				  if (_.options.infinite !== true) {
					  _.$prevArrow
						  .addClass('slick-disabled')
						  .attr('aria-disabled', 'true');
				  }

			  } else {

				  _.$prevArrow.add( _.$nextArrow )

					  .addClass('slick-hidden')
					  .attr({
						  'aria-disabled': 'true',
						  'tabindex': '-1'
					  });

			  }

		  }

	  };

	  Slick.prototype.buildDots = function() {

		  var _ = this,
			  i, dot;

		  if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

			  _.$slider.addClass('slick-dotted');

			  dot = $('<ul />').addClass(_.options.dotsClass);

			  for (i = 0; i <= _.getDotCount(); i += 1) {
				  dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
			  }

			  _.$dots = dot.appendTo(_.options.appendDots);

			  _.$dots.find('li').first().addClass('slick-active');

		  }

	  };

	  Slick.prototype.buildOut = function() {

		  var _ = this;

		  _.$slides =
			  _.$slider
				  .children( _.options.slide + ':not(.slick-cloned)')
				  .addClass('slick-slide');

		  _.slideCount = _.$slides.length;

		  _.$slides.each(function(index, element) {
			  $(element)
				  .attr('data-slick-index', index)
				  .data('originalStyling', $(element).attr('style') || '');
		  });

		  _.$slider.addClass('slick-slider');

		  _.$slideTrack = (_.slideCount === 0) ?
			  $('<div class="slick-track"/>').appendTo(_.$slider) :
			  _.$slides.wrapAll('<div class="slick-track"/>').parent();

		  _.$list = _.$slideTrack.wrap(
			  '<div class="slick-list"/>').parent();
		  _.$slideTrack.css('opacity', 0);

		  if (_.options.centerMode === true || _.options.swipeToSlide === true) {
			  _.options.slidesToScroll = 1;
		  }

		  $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

		  _.setupInfinite();

		  _.buildArrows();

		  _.buildDots();

		  _.updateDots();


		  _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

		  if (_.options.draggable === true) {
			  _.$list.addClass('draggable');
		  }

	  };

	  Slick.prototype.buildRows = function() {

		  var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;

		  newSlides = document.createDocumentFragment();
		  originalSlides = _.$slider.children();

		  if(_.options.rows > 0) {

			  slidesPerSection = _.options.slidesPerRow * _.options.rows;
			  numOfSlides = Math.ceil(
				  originalSlides.length / slidesPerSection
			  );

			  for(a = 0; a < numOfSlides; a++){
				  var slide = document.createElement('div');
				  for(b = 0; b < _.options.rows; b++) {
					  var row = document.createElement('div');
					  for(c = 0; c < _.options.slidesPerRow; c++) {
						  var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
						  if (originalSlides.get(target)) {
							  row.appendChild(originalSlides.get(target));
						  }
					  }
					  slide.appendChild(row);
				  }
				  newSlides.appendChild(slide);
			  }

			  _.$slider.empty().append(newSlides);
			  _.$slider.children().children().children()
				  .css({
					  'width':(100 / _.options.slidesPerRow) + '%',
					  'display': 'inline-block'
				  });

		  }

	  };

	  Slick.prototype.checkResponsive = function(initial, forceUpdate) {

		  var _ = this,
			  breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
		  var sliderWidth = _.$slider.width();
		  var windowWidth = window.innerWidth || $(window).width();

		  if (_.respondTo === 'window') {
			  respondToWidth = windowWidth;
		  } else if (_.respondTo === 'slider') {
			  respondToWidth = sliderWidth;
		  } else if (_.respondTo === 'min') {
			  respondToWidth = Math.min(windowWidth, sliderWidth);
		  }

		  if ( _.options.responsive &&
			  _.options.responsive.length &&
			  _.options.responsive !== null) {

			  targetBreakpoint = null;

			  for (breakpoint in _.breakpoints) {
				  if (_.breakpoints.hasOwnProperty(breakpoint)) {
					  if (_.originalSettings.mobileFirst === false) {
						  if (respondToWidth < _.breakpoints[breakpoint]) {
							  targetBreakpoint = _.breakpoints[breakpoint];
						  }
					  } else {
						  if (respondToWidth > _.breakpoints[breakpoint]) {
							  targetBreakpoint = _.breakpoints[breakpoint];
						  }
					  }
				  }
			  }

			  if (targetBreakpoint !== null) {
				  if (_.activeBreakpoint !== null) {
					  if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
						  _.activeBreakpoint =
							  targetBreakpoint;
						  if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
							  _.unslick(targetBreakpoint);
						  } else {
							  _.options = $.extend({}, _.originalSettings,
								  _.breakpointSettings[
									  targetBreakpoint]);
							  if (initial === true) {
								  _.currentSlide = _.options.initialSlide;
							  }
							  _.refresh(initial);
						  }
						  triggerBreakpoint = targetBreakpoint;
					  }
				  } else {
					  _.activeBreakpoint = targetBreakpoint;
					  if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
						  _.unslick(targetBreakpoint);
					  } else {
						  _.options = $.extend({}, _.originalSettings,
							  _.breakpointSettings[
								  targetBreakpoint]);
						  if (initial === true) {
							  _.currentSlide = _.options.initialSlide;
						  }
						  _.refresh(initial);
					  }
					  triggerBreakpoint = targetBreakpoint;
				  }
			  } else {
				  if (_.activeBreakpoint !== null) {
					  _.activeBreakpoint = null;
					  _.options = _.originalSettings;
					  if (initial === true) {
						  _.currentSlide = _.options.initialSlide;
					  }
					  _.refresh(initial);
					  triggerBreakpoint = targetBreakpoint;
				  }
			  }

			  // only trigger breakpoints during an actual break. not on initialize.
			  if( !initial && triggerBreakpoint !== false ) {
				  _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
			  }
		  }

	  };

	  Slick.prototype.changeSlide = function(event, dontAnimate) {

		  var _ = this,
			  $target = $(event.currentTarget),
			  indexOffset, slideOffset, unevenOffset;

		  // If target is a link, prevent default action.
		  if($target.is('a')) {
			  event.preventDefault();
		  }

		  // If target is not the <li> element (ie: a child), find the <li>.
		  if(!$target.is('li')) {
			  $target = $target.closest('li');
		  }

		  unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
		  indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

		  switch (event.data.message) {

			  case 'previous':
				  slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
				  if (_.slideCount > _.options.slidesToShow) {
					  _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
				  }
				  break;

			  case 'next':
				  slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
				  if (_.slideCount > _.options.slidesToShow) {
					  _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
				  }
				  break;

			  case 'index':
				  var index = event.data.index === 0 ? 0 :
					  event.data.index || $target.index() * _.options.slidesToScroll;

				  _.slideHandler(_.checkNavigable(index), false, dontAnimate);
				  $target.children().trigger('focus');
				  break;

			  default:
				  return;
		  }

	  };

	  Slick.prototype.checkNavigable = function(index) {

		  var _ = this,
			  navigables, prevNavigable;

		  navigables = _.getNavigableIndexes();
		  prevNavigable = 0;
		  if (index > navigables[navigables.length - 1]) {
			  index = navigables[navigables.length - 1];
		  } else {
			  for (var n in navigables) {
				  if (index < navigables[n]) {
					  index = prevNavigable;
					  break;
				  }
				  prevNavigable = navigables[n];
			  }
		  }

		  return index;
	  };

	  Slick.prototype.cleanUpEvents = function() {

		  var _ = this;

		  if (_.options.dots && _.$dots !== null) {

			  $('li', _.$dots)
				  .off('click.slick', _.changeSlide)
				  .off('mouseenter.slick', $.proxy(_.interrupt, _, true))
				  .off('mouseleave.slick', $.proxy(_.interrupt, _, false));

			  if (_.options.accessibility === true) {
				  _.$dots.off('keydown.slick', _.keyHandler);
			  }
		  }

		  _.$slider.off('focus.slick blur.slick');

		  if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
			  _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
			  _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);

			  if (_.options.accessibility === true) {
				  _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
				  _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
			  }
		  }

		  _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
		  _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
		  _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
		  _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

		  _.$list.off('click.slick', _.clickHandler);

		  $(document).off(_.visibilityChange, _.visibility);

		  _.cleanUpSlideEvents();

		  if (_.options.accessibility === true) {
			  _.$list.off('keydown.slick', _.keyHandler);
		  }

		  if (_.options.focusOnSelect === true) {
			  $(_.$slideTrack).children().off('click.slick', _.selectHandler);
		  }

		  $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

		  $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

		  $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

		  $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);

	  };

	  Slick.prototype.cleanUpSlideEvents = function() {

		  var _ = this;

		  _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
		  _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

	  };

	  Slick.prototype.cleanUpRows = function() {

		  var _ = this, originalSlides;

		  if(_.options.rows > 0) {
			  originalSlides = _.$slides.children().children();
			  originalSlides.removeAttr('style');
			  _.$slider.empty().append(originalSlides);
		  }

	  };

	  Slick.prototype.clickHandler = function(event) {

		  var _ = this;

		  if (_.shouldClick === false) {
			  event.stopImmediatePropagation();
			  event.stopPropagation();
			  event.preventDefault();
		  }

	  };

	  Slick.prototype.destroy = function(refresh) {

		  var _ = this;

		  _.autoPlayClear();

		  _.touchObject = {};

		  _.cleanUpEvents();

		  $('.slick-cloned', _.$slider).detach();

		  if (_.$dots) {
			  _.$dots.remove();
		  }

		  if ( _.$prevArrow && _.$prevArrow.length ) {

			  _.$prevArrow
				  .removeClass('slick-disabled slick-arrow slick-hidden')
				  .removeAttr('aria-hidden aria-disabled tabindex')
				  .css('display','');

			  if ( _.htmlExpr.test( _.options.prevArrow )) {
				  _.$prevArrow.remove();
			  }
		  }

		  if ( _.$nextArrow && _.$nextArrow.length ) {

			  _.$nextArrow
				  .removeClass('slick-disabled slick-arrow slick-hidden')
				  .removeAttr('aria-hidden aria-disabled tabindex')
				  .css('display','');

			  if ( _.htmlExpr.test( _.options.nextArrow )) {
				  _.$nextArrow.remove();
			  }
		  }


		  if (_.$slides) {

			  _.$slides
				  .removeClass('slick-slide slick-active slick-center slick-visible slick-current')
				  .removeAttr('aria-hidden')
				  .removeAttr('data-slick-index')
				  .each(function(){
					  $(this).attr('style', $(this).data('originalStyling'));
				  });

			  _.$slideTrack.children(this.options.slide).detach();

			  _.$slideTrack.detach();

			  _.$list.detach();

			  _.$slider.append(_.$slides);
		  }

		  _.cleanUpRows();

		  _.$slider.removeClass('slick-slider');
		  _.$slider.removeClass('slick-initialized');
		  _.$slider.removeClass('slick-dotted');

		  _.unslicked = true;

		  if(!refresh) {
			  _.$slider.trigger('destroy', [_]);
		  }

	  };

	  Slick.prototype.disableTransition = function(slide) {

		  var _ = this,
			  transition = {};

		  transition[_.transitionType] = '';

		  if (_.options.fade === false) {
			  _.$slideTrack.css(transition);
		  } else {
			  _.$slides.eq(slide).css(transition);
		  }

	  };

	  Slick.prototype.fadeSlide = function(slideIndex, callback) {

		  var _ = this;

		  if (_.cssTransitions === false) {

			  _.$slides.eq(slideIndex).css({
				  zIndex: _.options.zIndex
			  });

			  _.$slides.eq(slideIndex).animate({
				  opacity: 1
			  }, _.options.speed, _.options.easing, callback);

		  } else {

			  _.applyTransition(slideIndex);

			  _.$slides.eq(slideIndex).css({
				  opacity: 1,
				  zIndex: _.options.zIndex
			  });

			  if (callback) {
				  setTimeout(function() {

					  _.disableTransition(slideIndex);

					  callback.call();
				  }, _.options.speed);
			  }

		  }

	  };

	  Slick.prototype.fadeSlideOut = function(slideIndex) {

		  var _ = this;

		  if (_.cssTransitions === false) {

			  _.$slides.eq(slideIndex).animate({
				  opacity: 0,
				  zIndex: _.options.zIndex - 2
			  }, _.options.speed, _.options.easing);

		  } else {

			  _.applyTransition(slideIndex);

			  _.$slides.eq(slideIndex).css({
				  opacity: 0,
				  zIndex: _.options.zIndex - 2
			  });

		  }

	  };

	  Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

		  var _ = this;

		  if (filter !== null) {

			  _.$slidesCache = _.$slides;

			  _.unload();

			  _.$slideTrack.children(this.options.slide).detach();

			  _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

			  _.reinit();

		  }

	  };

	  Slick.prototype.focusHandler = function() {

		  var _ = this;

		  _.$slider
			  .off('focus.slick blur.slick')
			  .on('focus.slick blur.slick', '*', function(event) {

			  event.stopImmediatePropagation();
			  var $sf = $(this);

			  setTimeout(function() {

				  if( _.options.pauseOnFocus ) {
					  _.focussed = $sf.is(':focus');
					  _.autoPlay();
				  }

			  }, 0);

		  });
	  };

	  Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

		  var _ = this;
		  return _.currentSlide;

	  };

	  Slick.prototype.getDotCount = function() {

		  var _ = this;

		  var breakPoint = 0;
		  var counter = 0;
		  var pagerQty = 0;

		  if (_.options.infinite === true) {
			  if (_.slideCount <= _.options.slidesToShow) {
				   ++pagerQty;
			  } else {
				  while (breakPoint < _.slideCount) {
					  ++pagerQty;
					  breakPoint = counter + _.options.slidesToScroll;
					  counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
				  }
			  }
		  } else if (_.options.centerMode === true) {
			  pagerQty = _.slideCount;
		  } else if(!_.options.asNavFor) {
			  pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
		  }else {
			  while (breakPoint < _.slideCount) {
				  ++pagerQty;
				  breakPoint = counter + _.options.slidesToScroll;
				  counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
			  }
		  }

		  return pagerQty - 1;

	  };

	  Slick.prototype.getLeft = function(slideIndex) {

		  var _ = this,
			  targetLeft,
			  verticalHeight,
			  verticalOffset = 0,
			  targetSlide,
			  coef;

		  _.slideOffset = 0;
		  verticalHeight = _.$slides.first().outerHeight(true);

		  if (_.options.infinite === true) {
			  if (_.slideCount > _.options.slidesToShow) {
				  _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
				  coef = -1

				  if (_.options.vertical === true && _.options.centerMode === true) {
					  if (_.options.slidesToShow === 2) {
						  coef = -1.5;
					  } else if (_.options.slidesToShow === 1) {
						  coef = -2
					  }
				  }
				  verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;
			  }
			  if (_.slideCount % _.options.slidesToScroll !== 0) {
				  if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
					  if (slideIndex > _.slideCount) {
						  _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
						  verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
					  } else {
						  _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
						  verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
					  }
				  }
			  }
		  } else {
			  if (slideIndex + _.options.slidesToShow > _.slideCount) {
				  _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
				  verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
			  }
		  }

		  if (_.slideCount <= _.options.slidesToShow) {
			  _.slideOffset = 0;
			  verticalOffset = 0;
		  }

		  if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {
			  _.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) / 2) - ((_.slideWidth * _.slideCount) / 2);
		  } else if (_.options.centerMode === true && _.options.infinite === true) {
			  _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
		  } else if (_.options.centerMode === true) {
			  _.slideOffset = 0;
			  _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
		  }

		  if (_.options.vertical === false) {
			  targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
		  } else {
			  targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
		  }

		  if (_.options.variableWidth === true) {

			  if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
				  targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
			  } else {
				  targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
			  }

			  if (_.options.rtl === true) {
				  if (targetSlide[0]) {
					  targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
				  } else {
					  targetLeft =  0;
				  }
			  } else {
				  targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
			  }

			  if (_.options.centerMode === true) {
				  if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
					  targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
				  } else {
					  targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
				  }

				  if (_.options.rtl === true) {
					  if (targetSlide[0]) {
						  targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
					  } else {
						  targetLeft =  0;
					  }
				  } else {
					  targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
				  }

				  targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
			  }
		  }

		  return targetLeft;

	  };

	  Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

		  var _ = this;

		  return _.options[option];

	  };

	  Slick.prototype.getNavigableIndexes = function() {

		  var _ = this,
			  breakPoint = 0,
			  counter = 0,
			  indexes = [],
			  max;

		  if (_.options.infinite === false) {
			  max = _.slideCount;
		  } else {
			  breakPoint = _.options.slidesToScroll * -1;
			  counter = _.options.slidesToScroll * -1;
			  max = _.slideCount * 2;
		  }

		  while (breakPoint < max) {
			  indexes.push(breakPoint);
			  breakPoint = counter + _.options.slidesToScroll;
			  counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
		  }

		  return indexes;

	  };

	  Slick.prototype.getSlick = function() {

		  return this;

	  };

	  Slick.prototype.getSlideCount = function() {

		  var _ = this,
			  slidesTraversed, swipedSlide, centerOffset;

		  centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

		  if (_.options.swipeToSlide === true) {
			  _.$slideTrack.find('.slick-slide').each(function(index, slide) {
				  if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
					  swipedSlide = slide;
					  return false;
				  }
			  });

			  slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

			  return slidesTraversed;

		  } else {
			  return _.options.slidesToScroll;
		  }

	  };

	  Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {

		  var _ = this;

		  _.changeSlide({
			  data: {
				  message: 'index',
				  index: parseInt(slide)
			  }
		  }, dontAnimate);

	  };

	  Slick.prototype.init = function(creation) {

		  var _ = this;

		  if (!$(_.$slider).hasClass('slick-initialized')) {

			  $(_.$slider).addClass('slick-initialized');

			  _.buildRows();
			  _.buildOut();
			  _.setProps();
			  _.startLoad();
			  _.loadSlider();
			  _.initializeEvents();
			  _.updateArrows();
			  _.updateDots();
			  _.checkResponsive(true);
			  _.focusHandler();

		  }

		  if (creation) {
			  _.$slider.trigger('init', [_]);
		  }

		  if (_.options.accessibility === true) {
			  _.initADA();
		  }

		  if ( _.options.autoplay ) {

			  _.paused = false;
			  _.autoPlay();

		  }

	  };

	  Slick.prototype.initADA = function() {
		  var _ = this,
				  numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
				  tabControlIndexes = _.getNavigableIndexes().filter(function(val) {
					  return (val >= 0) && (val < _.slideCount);
				  });

		  _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
			  'aria-hidden': 'true',
			  'tabindex': '-1'
		  }).find('a, input, button, select').attr({
			  'tabindex': '-1'
		  });

		  if (_.$dots !== null) {
			  _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {
				  var slideControlIndex = tabControlIndexes.indexOf(i);

				  $(this).attr({
					  'role': 'tabpanel',
					  'id': 'slick-slide' + _.instanceUid + i,
					  'tabindex': -1
				  });

				  if (slideControlIndex !== -1) {
					 var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex
					 if ($('#' + ariaButtonControl).length) {
					   $(this).attr({
						   'aria-describedby': ariaButtonControl
					   });
					 }
				  }
			  });

			  _.$dots.attr('role', 'tablist').find('li').each(function(i) {
				  var mappedSlideIndex = tabControlIndexes[i];

				  $(this).attr({
					  'role': 'presentation'
				  });

				  $(this).find('button').first().attr({
					  'role': 'tab',
					  'id': 'slick-slide-control' + _.instanceUid + i,
					  'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
					  'aria-label': (i + 1) + ' of ' + numDotGroups,
					  'aria-selected': null,
					  'tabindex': '-1'
				  });

			  }).eq(_.currentSlide).find('button').attr({
				  'aria-selected': 'true',
				  'tabindex': '0'
			  }).end();
		  }

		  for (var i=_.currentSlide, max=i+_.options.slidesToShow; i < max; i++) {
			if (_.options.focusOnChange) {
			  _.$slides.eq(i).attr({'tabindex': '0'});
			} else {
			  _.$slides.eq(i).removeAttr('tabindex');
			}
		  }

		  _.activateADA();

	  };

	  Slick.prototype.initArrowEvents = function() {

		  var _ = this;

		  if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
			  _.$prevArrow
				 .off('click.slick')
				 .on('click.slick', {
					  message: 'previous'
				 }, _.changeSlide);
			  _.$nextArrow
				 .off('click.slick')
				 .on('click.slick', {
					  message: 'next'
				 }, _.changeSlide);

			  if (_.options.accessibility === true) {
				  _.$prevArrow.on('keydown.slick', _.keyHandler);
				  _.$nextArrow.on('keydown.slick', _.keyHandler);
			  }
		  }

	  };

	  Slick.prototype.initDotEvents = function() {

		  var _ = this;

		  if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
			  $('li', _.$dots).on('click.slick', {
				  message: 'index'
			  }, _.changeSlide);

			  if (_.options.accessibility === true) {
				  _.$dots.on('keydown.slick', _.keyHandler);
			  }
		  }

		  if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {

			  $('li', _.$dots)
				  .on('mouseenter.slick', $.proxy(_.interrupt, _, true))
				  .on('mouseleave.slick', $.proxy(_.interrupt, _, false));

		  }

	  };

	  Slick.prototype.initSlideEvents = function() {

		  var _ = this;

		  if ( _.options.pauseOnHover ) {

			  _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
			  _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

		  }

	  };

	  Slick.prototype.initializeEvents = function() {

		  var _ = this;

		  _.initArrowEvents();

		  _.initDotEvents();
		  _.initSlideEvents();

		  _.$list.on('touchstart.slick mousedown.slick', {
			  action: 'start'
		  }, _.swipeHandler);
		  _.$list.on('touchmove.slick mousemove.slick', {
			  action: 'move'
		  }, _.swipeHandler);
		  _.$list.on('touchend.slick mouseup.slick', {
			  action: 'end'
		  }, _.swipeHandler);
		  _.$list.on('touchcancel.slick mouseleave.slick', {
			  action: 'end'
		  }, _.swipeHandler);

		  _.$list.on('click.slick', _.clickHandler);

		  $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

		  if (_.options.accessibility === true) {
			  _.$list.on('keydown.slick', _.keyHandler);
		  }

		  if (_.options.focusOnSelect === true) {
			  $(_.$slideTrack).children().on('click.slick', _.selectHandler);
		  }

		  $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

		  $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

		  $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

		  $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
		  $(_.setPosition);

	  };

	  Slick.prototype.initUI = function() {

		  var _ = this;

		  if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

			  _.$prevArrow.show();
			  _.$nextArrow.show();

		  }

		  if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

			  _.$dots.show();

		  }

	  };

	  Slick.prototype.keyHandler = function(event) {

		  var _ = this;
		   //Dont slide if the cursor is inside the form fields and arrow keys are pressed
		  if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
			  if (event.keyCode === 37 && _.options.accessibility === true) {
				  _.changeSlide({
					  data: {
						  message: _.options.rtl === true ? 'next' :  'previous'
					  }
				  });
			  } else if (event.keyCode === 39 && _.options.accessibility === true) {
				  _.changeSlide({
					  data: {
						  message: _.options.rtl === true ? 'previous' : 'next'
					  }
				  });
			  }
		  }

	  };

	  Slick.prototype.lazyLoad = function() {

		  var _ = this,
			  loadRange, cloneRange, rangeStart, rangeEnd;

		  function loadImages(imagesScope) {

			  $('img[data-lazy]', imagesScope).each(function() {

				  var image = $(this),
					  imageSource = $(this).attr('data-lazy'),
					  imageSrcSet = $(this).attr('data-srcset'),
					  imageSizes  = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),
					  imageToLoad = document.createElement('img');

				  imageToLoad.onload = function() {

					  image
						  .animate({ opacity: 0 }, 100, function() {

							  if (imageSrcSet) {
								  image
									  .attr('srcset', imageSrcSet );

								  if (imageSizes) {
									  image
										  .attr('sizes', imageSizes );
								  }
							  }

							  image
								  .attr('src', imageSource)
								  .animate({ opacity: 1 }, 200, function() {
									  image
										  .removeAttr('data-lazy data-srcset data-sizes')
										  .removeClass('slick-loading');
								  });
							  _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
						  });

				  };

				  imageToLoad.onerror = function() {

					  image
						  .removeAttr( 'data-lazy' )
						  .removeClass( 'slick-loading' )
						  .addClass( 'slick-lazyload-error' );

					  _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

				  };

				  imageToLoad.src = imageSource;

			  });

		  }

		  if (_.options.centerMode === true) {
			  if (_.options.infinite === true) {
				  rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
				  rangeEnd = rangeStart + _.options.slidesToShow + 2;
			  } else {
				  rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
				  rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
			  }
		  } else {
			  rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
			  rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
			  if (_.options.fade === true) {
				  if (rangeStart > 0) rangeStart--;
				  if (rangeEnd <= _.slideCount) rangeEnd++;
			  }
		  }

		  loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);

		  if (_.options.lazyLoad === 'anticipated') {
			  var prevSlide = rangeStart - 1,
				  nextSlide = rangeEnd,
				  $slides = _.$slider.find('.slick-slide');

			  for (var i = 0; i < _.options.slidesToScroll; i++) {
				  if (prevSlide < 0) prevSlide = _.slideCount - 1;
				  loadRange = loadRange.add($slides.eq(prevSlide));
				  loadRange = loadRange.add($slides.eq(nextSlide));
				  prevSlide--;
				  nextSlide++;
			  }
		  }

		  loadImages(loadRange);

		  if (_.slideCount <= _.options.slidesToShow) {
			  cloneRange = _.$slider.find('.slick-slide');
			  loadImages(cloneRange);
		  } else
		  if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
			  cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
			  loadImages(cloneRange);
		  } else if (_.currentSlide === 0) {
			  cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
			  loadImages(cloneRange);
		  }

	  };

	  Slick.prototype.loadSlider = function() {

		  var _ = this;

		  _.setPosition();

		  _.$slideTrack.css({
			  opacity: 1
		  });

		  _.$slider.removeClass('slick-loading');

		  _.initUI();

		  if (_.options.lazyLoad === 'progressive') {
			  _.progressiveLazyLoad();
		  }

	  };

	  Slick.prototype.next = Slick.prototype.slickNext = function() {

		  var _ = this;

		  _.changeSlide({
			  data: {
				  message: 'next'
			  }
		  });

	  };

	  Slick.prototype.orientationChange = function() {

		  var _ = this;

		  _.checkResponsive();
		  _.setPosition();

	  };

	  Slick.prototype.pause = Slick.prototype.slickPause = function() {

		  var _ = this;

		  _.autoPlayClear();
		  _.paused = true;

	  };

	  Slick.prototype.play = Slick.prototype.slickPlay = function() {

		  var _ = this;

		  _.autoPlay();
		  _.options.autoplay = true;
		  _.paused = false;
		  _.focussed = false;
		  _.interrupted = false;

	  };

	  Slick.prototype.postSlide = function(index) {

		  var _ = this;

		  if( !_.unslicked ) {

			  _.$slider.trigger('afterChange', [_, index]);

			  _.animating = false;

			  if (_.slideCount > _.options.slidesToShow) {
				  _.setPosition();
			  }

			  _.swipeLeft = null;

			  if ( _.options.autoplay ) {
				  _.autoPlay();
			  }

			  if (_.options.accessibility === true) {
				  _.initADA();

				  if (_.options.focusOnChange) {
					  var $currentSlide = $(_.$slides.get(_.currentSlide));
					  $currentSlide.attr('tabindex', 0).focus();
				  }
			  }

		  }

	  };

	  Slick.prototype.prev = Slick.prototype.slickPrev = function() {

		  var _ = this;

		  _.changeSlide({
			  data: {
				  message: 'previous'
			  }
		  });

	  };

	  Slick.prototype.preventDefault = function(event) {

		  event.preventDefault();

	  };

	  Slick.prototype.progressiveLazyLoad = function( tryCount ) {

		  tryCount = tryCount || 1;

		  var _ = this,
			  $imgsToLoad = $( 'img[data-lazy]', _.$slider ),
			  image,
			  imageSource,
			  imageSrcSet,
			  imageSizes,
			  imageToLoad;

		  if ( $imgsToLoad.length ) {

			  image = $imgsToLoad.first();
			  imageSource = image.attr('data-lazy');
			  imageSrcSet = image.attr('data-srcset');
			  imageSizes  = image.attr('data-sizes') || _.$slider.attr('data-sizes');
			  imageToLoad = document.createElement('img');

			  imageToLoad.onload = function() {

				  if (imageSrcSet) {
					  image
						  .attr('srcset', imageSrcSet );

					  if (imageSizes) {
						  image
							  .attr('sizes', imageSizes );
					  }
				  }

				  image
					  .attr( 'src', imageSource )
					  .removeAttr('data-lazy data-srcset data-sizes')
					  .removeClass('slick-loading');

				  if ( _.options.adaptiveHeight === true ) {
					  _.setPosition();
				  }

				  _.$slider.trigger('lazyLoaded', [ _, image, imageSource ]);
				  _.progressiveLazyLoad();

			  };

			  imageToLoad.onerror = function() {

				  if ( tryCount < 3 ) {

					  /**
					   * try to load the image 3 times,
					   * leave a slight delay so we don't get
					   * servers blocking the request.
					   */
					  setTimeout( function() {
						  _.progressiveLazyLoad( tryCount + 1 );
					  }, 500 );

				  } else {

					  image
						  .removeAttr( 'data-lazy' )
						  .removeClass( 'slick-loading' )
						  .addClass( 'slick-lazyload-error' );

					  _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

					  _.progressiveLazyLoad();

				  }

			  };

			  imageToLoad.src = imageSource;

		  } else {

			  _.$slider.trigger('allImagesLoaded', [ _ ]);

		  }

	  };

	  Slick.prototype.refresh = function( initializing ) {

		  var _ = this, currentSlide, lastVisibleIndex;

		  lastVisibleIndex = _.slideCount - _.options.slidesToShow;

		  // in non-infinite sliders, we don't want to go past the
		  // last visible index.
		  if( !_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {
			  _.currentSlide = lastVisibleIndex;
		  }

		  // if less slides than to show, go to start.
		  if ( _.slideCount <= _.options.slidesToShow ) {
			  _.currentSlide = 0;

		  }

		  currentSlide = _.currentSlide;

		  _.destroy(true);

		  $.extend(_, _.initials, { currentSlide: currentSlide });

		  _.init();

		  if( !initializing ) {

			  _.changeSlide({
				  data: {
					  message: 'index',
					  index: currentSlide
				  }
			  }, false);

		  }

	  };

	  Slick.prototype.registerBreakpoints = function() {

		  var _ = this, breakpoint, currentBreakpoint, l,
			  responsiveSettings = _.options.responsive || null;

		  if ( $.type(responsiveSettings) === 'array' && responsiveSettings.length ) {

			  _.respondTo = _.options.respondTo || 'window';

			  for ( breakpoint in responsiveSettings ) {

				  l = _.breakpoints.length-1;

				  if (responsiveSettings.hasOwnProperty(breakpoint)) {
					  currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

					  // loop through the breakpoints and cut out any existing
					  // ones with the same breakpoint number, we don't want dupes.
					  while( l >= 0 ) {
						  if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {
							  _.breakpoints.splice(l,1);
						  }
						  l--;
					  }

					  _.breakpoints.push(currentBreakpoint);
					  _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

				  }

			  }

			  _.breakpoints.sort(function(a, b) {
				  return ( _.options.mobileFirst ) ? a-b : b-a;
			  });

		  }

	  };

	  Slick.prototype.reinit = function() {

		  var _ = this;

		  _.$slides =
			  _.$slideTrack
				  .children(_.options.slide)
				  .addClass('slick-slide');

		  _.slideCount = _.$slides.length;

		  if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
			  _.currentSlide = _.currentSlide - _.options.slidesToScroll;
		  }

		  if (_.slideCount <= _.options.slidesToShow) {
			  _.currentSlide = 0;
		  }

		  _.registerBreakpoints();

		  _.setProps();
		  _.setupInfinite();
		  _.buildArrows();
		  _.updateArrows();
		  _.initArrowEvents();
		  _.buildDots();
		  _.updateDots();
		  _.initDotEvents();
		  _.cleanUpSlideEvents();
		  _.initSlideEvents();

		  _.checkResponsive(false, true);

		  if (_.options.focusOnSelect === true) {
			  $(_.$slideTrack).children().on('click.slick', _.selectHandler);
		  }

		  _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

		  _.setPosition();
		  _.focusHandler();

		  _.paused = !_.options.autoplay;
		  _.autoPlay();

		  _.$slider.trigger('reInit', [_]);

	  };

	  Slick.prototype.resize = function() {

		  var _ = this;

		  if ($(window).width() !== _.windowWidth) {
			  clearTimeout(_.windowDelay);
			  _.windowDelay = window.setTimeout(function() {
				  _.windowWidth = $(window).width();
				  _.checkResponsive();
				  if( !_.unslicked ) { _.setPosition(); }
			  }, 50);
		  }
	  };

	  Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {

		  var _ = this;

		  if (typeof(index) === 'boolean') {
			  removeBefore = index;
			  index = removeBefore === true ? 0 : _.slideCount - 1;
		  } else {
			  index = removeBefore === true ? --index : index;
		  }

		  if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
			  return false;
		  }

		  _.unload();

		  if (removeAll === true) {
			  _.$slideTrack.children().remove();
		  } else {
			  _.$slideTrack.children(this.options.slide).eq(index).remove();
		  }

		  _.$slides = _.$slideTrack.children(this.options.slide);

		  _.$slideTrack.children(this.options.slide).detach();

		  _.$slideTrack.append(_.$slides);

		  _.$slidesCache = _.$slides;

		  _.reinit();

	  };

	  Slick.prototype.setCSS = function(position) {

		  var _ = this,
			  positionProps = {},
			  x, y;

		  if (_.options.rtl === true) {
			  position = -position;
		  }
		  x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
		  y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

		  positionProps[_.positionProp] = position;

		  if (_.transformsEnabled === false) {
			  _.$slideTrack.css(positionProps);
		  } else {
			  positionProps = {};
			  if (_.cssTransitions === false) {
				  positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
				  _.$slideTrack.css(positionProps);
			  } else {
				  positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
				  _.$slideTrack.css(positionProps);
			  }
		  }

	  };

	  Slick.prototype.setDimensions = function() {

		  var _ = this;

		  if (_.options.vertical === false) {
			  if (_.options.centerMode === true) {
				  _.$list.css({
					  padding: ('0px ' + _.options.centerPadding)
				  });
			  }
		  } else {
			  _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
			  if (_.options.centerMode === true) {
				  _.$list.css({
					  padding: (_.options.centerPadding + ' 0px')
				  });
			  }
		  }

		  _.listWidth = _.$list.width();
		  _.listHeight = _.$list.height();


		  if (_.options.vertical === false && _.options.variableWidth === false) {
			  _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
			  _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

		  } else if (_.options.variableWidth === true) {
			  _.$slideTrack.width(5000 * _.slideCount);
		  } else {
			  _.slideWidth = Math.ceil(_.listWidth);
			  _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
		  }

		  var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
		  if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

	  };

	  Slick.prototype.setFade = function() {

		  var _ = this,
			  targetLeft;

		  _.$slides.each(function(index, element) {
			  targetLeft = (_.slideWidth * index) * -1;
			  if (_.options.rtl === true) {
				  $(element).css({
					  position: 'relative',
					  right: targetLeft,
					  top: 0,
					  zIndex: _.options.zIndex - 2,
					  opacity: 0
				  });
			  } else {
				  $(element).css({
					  position: 'relative',
					  left: targetLeft,
					  top: 0,
					  zIndex: _.options.zIndex - 2,
					  opacity: 0
				  });
			  }
		  });

		  _.$slides.eq(_.currentSlide).css({
			  zIndex: _.options.zIndex - 1,
			  opacity: 1
		  });

	  };

	  Slick.prototype.setHeight = function() {

		  var _ = this;

		  if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
			  var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
			  _.$list.css('height', targetHeight);
		  }

	  };

	  Slick.prototype.setOption =
	  Slick.prototype.slickSetOption = function() {

		  /**
		   * accepts arguments in format of:
		   *
		   *  - for changing a single option's value:
		   *     .slick("setOption", option, value, refresh )
		   *
		   *  - for changing a set of responsive options:
		   *     .slick("setOption", 'responsive', [{}, ...], refresh )
		   *
		   *  - for updating multiple values at once (not responsive)
		   *     .slick("setOption", { 'option': value, ... }, refresh )
		   */

		  var _ = this, l, item, option, value, refresh = false, type;

		  if( $.type( arguments[0] ) === 'object' ) {

			  option =  arguments[0];
			  refresh = arguments[1];
			  type = 'multiple';

		  } else if ( $.type( arguments[0] ) === 'string' ) {

			  option =  arguments[0];
			  value = arguments[1];
			  refresh = arguments[2];

			  if ( arguments[0] === 'responsive' && $.type( arguments[1] ) === 'array' ) {

				  type = 'responsive';

			  } else if ( typeof arguments[1] !== 'undefined' ) {

				  type = 'single';

			  }

		  }

		  if ( type === 'single' ) {

			  _.options[option] = value;


		  } else if ( type === 'multiple' ) {

			  $.each( option , function( opt, val ) {

				  _.options[opt] = val;

			  });


		  } else if ( type === 'responsive' ) {

			  for ( item in value ) {

				  if( $.type( _.options.responsive ) !== 'array' ) {

					  _.options.responsive = [ value[item] ];

				  } else {

					  l = _.options.responsive.length-1;

					  // loop through the responsive object and splice out duplicates.
					  while( l >= 0 ) {

						  if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {

							  _.options.responsive.splice(l,1);

						  }

						  l--;

					  }

					  _.options.responsive.push( value[item] );

				  }

			  }

		  }

		  if ( refresh ) {

			  _.unload();
			  _.reinit();

		  }

	  };

	  Slick.prototype.setPosition = function() {

		  var _ = this;

		  _.setDimensions();

		  _.setHeight();

		  if (_.options.fade === false) {
			  _.setCSS(_.getLeft(_.currentSlide));
		  } else {
			  _.setFade();
		  }

		  _.$slider.trigger('setPosition', [_]);

	  };

	  Slick.prototype.setProps = function() {

		  var _ = this,
			  bodyStyle = document.body.style;

		  _.positionProp = _.options.vertical === true ? 'top' : 'left';

		  if (_.positionProp === 'top') {
			  _.$slider.addClass('slick-vertical');
		  } else {
			  _.$slider.removeClass('slick-vertical');
		  }

		  if (bodyStyle.WebkitTransition !== undefined ||
			  bodyStyle.MozTransition !== undefined ||
			  bodyStyle.msTransition !== undefined) {
			  if (_.options.useCSS === true) {
				  _.cssTransitions = true;
			  }
		  }

		  if ( _.options.fade ) {
			  if ( typeof _.options.zIndex === 'number' ) {
				  if( _.options.zIndex < 3 ) {
					  _.options.zIndex = 3;
				  }
			  } else {
				  _.options.zIndex = _.defaults.zIndex;
			  }
		  }

		  if (bodyStyle.OTransform !== undefined) {
			  _.animType = 'OTransform';
			  _.transformType = '-o-transform';
			  _.transitionType = 'OTransition';
			  if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
		  }
		  if (bodyStyle.MozTransform !== undefined) {
			  _.animType = 'MozTransform';
			  _.transformType = '-moz-transform';
			  _.transitionType = 'MozTransition';
			  if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
		  }
		  if (bodyStyle.webkitTransform !== undefined) {
			  _.animType = 'webkitTransform';
			  _.transformType = '-webkit-transform';
			  _.transitionType = 'webkitTransition';
			  if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
		  }
		  if (bodyStyle.msTransform !== undefined) {
			  _.animType = 'msTransform';
			  _.transformType = '-ms-transform';
			  _.transitionType = 'msTransition';
			  if (bodyStyle.msTransform === undefined) _.animType = false;
		  }
		  if (bodyStyle.transform !== undefined && _.animType !== false) {
			  _.animType = 'transform';
			  _.transformType = 'transform';
			  _.transitionType = 'transition';
		  }
		  _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);
	  };


	  Slick.prototype.setSlideClasses = function(index) {

		  var _ = this,
			  centerOffset, allSlides, indexOffset, remainder;

		  allSlides = _.$slider
			  .find('.slick-slide')
			  .removeClass('slick-active slick-center slick-current')
			  .attr('aria-hidden', 'true');

		  _.$slides
			  .eq(index)
			  .addClass('slick-current');

		  if (_.options.centerMode === true) {

			  var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;

			  centerOffset = Math.floor(_.options.slidesToShow / 2);

			  if (_.options.infinite === true) {

				  if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {
					  _.$slides
						  .slice(index - centerOffset + evenCoef, index + centerOffset + 1)
						  .addClass('slick-active')
						  .attr('aria-hidden', 'false');

				  } else {

					  indexOffset = _.options.slidesToShow + index;
					  allSlides
						  .slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2)
						  .addClass('slick-active')
						  .attr('aria-hidden', 'false');

				  }

				  if (index === 0) {

					  allSlides
						  .eq(allSlides.length - 1 - _.options.slidesToShow)
						  .addClass('slick-center');

				  } else if (index === _.slideCount - 1) {

					  allSlides
						  .eq(_.options.slidesToShow)
						  .addClass('slick-center');

				  }

			  }

			  _.$slides
				  .eq(index)
				  .addClass('slick-center');

		  } else {

			  if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

				  _.$slides
					  .slice(index, index + _.options.slidesToShow)
					  .addClass('slick-active')
					  .attr('aria-hidden', 'false');

			  } else if (allSlides.length <= _.options.slidesToShow) {

				  allSlides
					  .addClass('slick-active')
					  .attr('aria-hidden', 'false');

			  } else {

				  remainder = _.slideCount % _.options.slidesToShow;
				  indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

				  if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {

					  allSlides
						  .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)
						  .addClass('slick-active')
						  .attr('aria-hidden', 'false');

				  } else {

					  allSlides
						  .slice(indexOffset, indexOffset + _.options.slidesToShow)
						  .addClass('slick-active')
						  .attr('aria-hidden', 'false');

				  }

			  }

		  }

		  if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {
			  _.lazyLoad();
		  }
	  };

	  Slick.prototype.setupInfinite = function() {

		  var _ = this,
			  i, slideIndex, infiniteCount;

		  if (_.options.fade === true) {
			  _.options.centerMode = false;
		  }

		  if (_.options.infinite === true && _.options.fade === false) {

			  slideIndex = null;

			  if (_.slideCount > _.options.slidesToShow) {

				  if (_.options.centerMode === true) {
					  infiniteCount = _.options.slidesToShow + 1;
				  } else {
					  infiniteCount = _.options.slidesToShow;
				  }

				  for (i = _.slideCount; i > (_.slideCount -
						  infiniteCount); i -= 1) {
					  slideIndex = i - 1;
					  $(_.$slides[slideIndex]).clone(true).attr('id', '')
						  .attr('data-slick-index', slideIndex - _.slideCount)
						  .prependTo(_.$slideTrack).addClass('slick-cloned');
				  }
				  for (i = 0; i < infiniteCount  + _.slideCount; i += 1) {
					  slideIndex = i;
					  $(_.$slides[slideIndex]).clone(true).attr('id', '')
						  .attr('data-slick-index', slideIndex + _.slideCount)
						  .appendTo(_.$slideTrack).addClass('slick-cloned');
				  }
				  _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
					  $(this).attr('id', '');
				  });

			  }

		  }

	  };

	  Slick.prototype.interrupt = function( toggle ) {

		  var _ = this;

		  if( !toggle ) {
			  _.autoPlay();
		  }
		  _.interrupted = toggle;

	  };

	  Slick.prototype.selectHandler = function(event) {

		  var _ = this;

		  var targetElement =
			  $(event.target).is('.slick-slide') ?
				  $(event.target) :
				  $(event.target).parents('.slick-slide');

		  var index = parseInt(targetElement.attr('data-slick-index'));

		  if (!index) index = 0;

		  if (_.slideCount <= _.options.slidesToShow) {

			  _.slideHandler(index, false, true);
			  return;

		  }

		  _.slideHandler(index);

	  };

	  Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

		  var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
			  _ = this, navTarget;

		  sync = sync || false;

		  if (_.animating === true && _.options.waitForAnimate === true) {
			  return;
		  }

		  if (_.options.fade === true && _.currentSlide === index) {
			  return;
		  }

		  if (sync === false) {
			  _.asNavFor(index);
		  }

		  targetSlide = index;
		  targetLeft = _.getLeft(targetSlide);
		  slideLeft = _.getLeft(_.currentSlide);

		  _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

		  if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
			  if (_.options.fade === false) {
				  targetSlide = _.currentSlide;
				  if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
					  _.animateSlide(slideLeft, function() {
						  _.postSlide(targetSlide);
					  });
				  } else {
					  _.postSlide(targetSlide);
				  }
			  }
			  return;
		  } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
			  if (_.options.fade === false) {
				  targetSlide = _.currentSlide;
				  if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
					  _.animateSlide(slideLeft, function() {
						  _.postSlide(targetSlide);
					  });
				  } else {
					  _.postSlide(targetSlide);
				  }
			  }
			  return;
		  }

		  if ( _.options.autoplay ) {
			  clearInterval(_.autoPlayTimer);
		  }

		  if (targetSlide < 0) {
			  if (_.slideCount % _.options.slidesToScroll !== 0) {
				  animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
			  } else {
				  animSlide = _.slideCount + targetSlide;
			  }
		  } else if (targetSlide >= _.slideCount) {
			  if (_.slideCount % _.options.slidesToScroll !== 0) {
				  animSlide = 0;
			  } else {
				  animSlide = targetSlide - _.slideCount;
			  }
		  } else {
			  animSlide = targetSlide;
		  }

		  _.animating = true;

		  _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

		  oldSlide = _.currentSlide;
		  _.currentSlide = animSlide;

		  _.setSlideClasses(_.currentSlide);

		  if ( _.options.asNavFor ) {

			  navTarget = _.getNavTarget();
			  navTarget = navTarget.slick('getSlick');

			  if ( navTarget.slideCount <= navTarget.options.slidesToShow ) {
				  navTarget.setSlideClasses(_.currentSlide);
			  }

		  }

		  _.updateDots();
		  _.updateArrows();

		  if (_.options.fade === true) {
			  if (dontAnimate !== true) {

				  _.fadeSlideOut(oldSlide);

				  _.fadeSlide(animSlide, function() {
					  _.postSlide(animSlide);
				  });

			  } else {
				  _.postSlide(animSlide);
			  }
			  _.animateHeight();
			  return;
		  }

		  if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
			  _.animateSlide(targetLeft, function() {
				  _.postSlide(animSlide);
			  });
		  } else {
			  _.postSlide(animSlide);
		  }

	  };

	  Slick.prototype.startLoad = function() {

		  var _ = this;

		  if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

			  _.$prevArrow.hide();
			  _.$nextArrow.hide();

		  }

		  if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

			  _.$dots.hide();

		  }

		  _.$slider.addClass('slick-loading');

	  };

	  Slick.prototype.swipeDirection = function() {

		  var xDist, yDist, r, swipeAngle, _ = this;

		  xDist = _.touchObject.startX - _.touchObject.curX;
		  yDist = _.touchObject.startY - _.touchObject.curY;
		  r = Math.atan2(yDist, xDist);

		  swipeAngle = Math.round(r * 180 / Math.PI);
		  if (swipeAngle < 0) {
			  swipeAngle = 360 - Math.abs(swipeAngle);
		  }

		  if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
			  return (_.options.rtl === false ? 'left' : 'right');
		  }
		  if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
			  return (_.options.rtl === false ? 'left' : 'right');
		  }
		  if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
			  return (_.options.rtl === false ? 'right' : 'left');
		  }
		  if (_.options.verticalSwiping === true) {
			  if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
				  return 'down';
			  } else {
				  return 'up';
			  }
		  }

		  return 'vertical';

	  };

	  Slick.prototype.swipeEnd = function(event) {

		  var _ = this,
			  slideCount,
			  direction;

		  _.dragging = false;
		  _.swiping = false;

		  if (_.scrolling) {
			  _.scrolling = false;
			  return false;
		  }

		  _.interrupted = false;
		  _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;

		  if ( _.touchObject.curX === undefined ) {
			  return false;
		  }

		  if ( _.touchObject.edgeHit === true ) {
			  _.$slider.trigger('edge', [_, _.swipeDirection() ]);
		  }

		  if ( _.touchObject.swipeLength >= _.touchObject.minSwipe ) {

			  direction = _.swipeDirection();

			  switch ( direction ) {

				  case 'left':
				  case 'down':

					  slideCount =
						  _.options.swipeToSlide ?
							  _.checkNavigable( _.currentSlide + _.getSlideCount() ) :
							  _.currentSlide + _.getSlideCount();

					  _.currentDirection = 0;

					  break;

				  case 'right':
				  case 'up':

					  slideCount =
						  _.options.swipeToSlide ?
							  _.checkNavigable( _.currentSlide - _.getSlideCount() ) :
							  _.currentSlide - _.getSlideCount();

					  _.currentDirection = 1;

					  break;

				  default:


			  }

			  if( direction != 'vertical' ) {

				  _.slideHandler( slideCount );
				  _.touchObject = {};
				  _.$slider.trigger('swipe', [_, direction ]);

			  }

		  } else {

			  if ( _.touchObject.startX !== _.touchObject.curX ) {

				  _.slideHandler( _.currentSlide );
				  _.touchObject = {};

			  }

		  }

	  };

	  Slick.prototype.swipeHandler = function(event) {

		  var _ = this;

		  if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
			  return;
		  } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
			  return;
		  }

		  _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
			  event.originalEvent.touches.length : 1;

		  _.touchObject.minSwipe = _.listWidth / _.options
			  .touchThreshold;

		  if (_.options.verticalSwiping === true) {
			  _.touchObject.minSwipe = _.listHeight / _.options
				  .touchThreshold;
		  }

		  switch (event.data.action) {

			  case 'start':
				  _.swipeStart(event);
				  break;

			  case 'move':
				  _.swipeMove(event);
				  break;

			  case 'end':
				  _.swipeEnd(event);
				  break;

		  }

	  };

	  Slick.prototype.swipeMove = function(event) {

		  var _ = this,
			  edgeWasHit = false,
			  curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;

		  touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

		  if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
			  return false;
		  }

		  curLeft = _.getLeft(_.currentSlide);

		  _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
		  _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

		  _.touchObject.swipeLength = Math.round(Math.sqrt(
			  Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

		  verticalSwipeLength = Math.round(Math.sqrt(
			  Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));

		  if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
			  _.scrolling = true;
			  return false;
		  }

		  if (_.options.verticalSwiping === true) {
			  _.touchObject.swipeLength = verticalSwipeLength;
		  }

		  swipeDirection = _.swipeDirection();

		  if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
			  _.swiping = true;
			  event.preventDefault();
		  }

		  positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
		  if (_.options.verticalSwiping === true) {
			  positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
		  }


		  swipeLength = _.touchObject.swipeLength;

		  _.touchObject.edgeHit = false;

		  if (_.options.infinite === false) {
			  if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
				  swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
				  _.touchObject.edgeHit = true;
			  }
		  }

		  if (_.options.vertical === false) {
			  _.swipeLeft = curLeft + swipeLength * positionOffset;
		  } else {
			  _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
		  }
		  if (_.options.verticalSwiping === true) {
			  _.swipeLeft = curLeft + swipeLength * positionOffset;
		  }

		  if (_.options.fade === true || _.options.touchMove === false) {
			  return false;
		  }

		  if (_.animating === true) {
			  _.swipeLeft = null;
			  return false;
		  }

		  _.setCSS(_.swipeLeft);

	  };

	  Slick.prototype.swipeStart = function(event) {

		  var _ = this,
			  touches;

		  _.interrupted = true;

		  if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
			  _.touchObject = {};
			  return false;
		  }

		  if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
			  touches = event.originalEvent.touches[0];
		  }

		  _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
		  _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

		  _.dragging = true;

	  };

	  Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

		  var _ = this;

		  if (_.$slidesCache !== null) {

			  _.unload();

			  _.$slideTrack.children(this.options.slide).detach();

			  _.$slidesCache.appendTo(_.$slideTrack);

			  _.reinit();

		  }

	  };

	  Slick.prototype.unload = function() {

		  var _ = this;

		  $('.slick-cloned', _.$slider).remove();

		  if (_.$dots) {
			  _.$dots.remove();
		  }

		  if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
			  _.$prevArrow.remove();
		  }

		  if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
			  _.$nextArrow.remove();
		  }

		  _.$slides
			  .removeClass('slick-slide slick-active slick-visible slick-current')
			  .attr('aria-hidden', 'true')
			  .css('width', '');

	  };

	  Slick.prototype.unslick = function(fromBreakpoint) {

		  var _ = this;
		  _.$slider.trigger('unslick', [_, fromBreakpoint]);
		  _.destroy();

	  };

	  Slick.prototype.updateArrows = function() {

		  var _ = this,
			  centerOffset;

		  centerOffset = Math.floor(_.options.slidesToShow / 2);

		  if ( _.options.arrows === true &&
			  _.slideCount > _.options.slidesToShow &&
			  !_.options.infinite ) {

			  _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
			  _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

			  if (_.currentSlide === 0) {

				  _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
				  _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

			  } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

				  _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
				  _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

			  } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

				  _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
				  _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

			  }

		  }

	  };

	  Slick.prototype.updateDots = function() {

		  var _ = this;

		  if (_.$dots !== null) {

			  _.$dots
				  .find('li')
					  .removeClass('slick-active')
					  .end();

			  _.$dots
				  .find('li')
				  .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))
				  .addClass('slick-active');

		  }

	  };

	  Slick.prototype.visibility = function() {

		  var _ = this;

		  if ( _.options.autoplay ) {

			  if ( document[_.hidden] ) {

				  _.interrupted = true;

			  } else {

				  _.interrupted = false;

			  }

		  }

	  };

	  $.fn.slick = function() {
		  var _ = this,
			  opt = arguments[0],
			  args = Array.prototype.slice.call(arguments, 1),
			  l = _.length,
			  i,
			  ret;
		  for (i = 0; i < l; i++) {
			  if (typeof opt == 'object' || typeof opt == 'undefined')
				  _[i].slick = new Slick(_[i], opt);
			  else
				  ret = _[i].slick[opt].apply(_[i].slick, args);
			  if (typeof ret != 'undefined') return ret;
		  }
		  return _;
	  };

  }));

  /**
   * File skip-link-focus-fix.js.
   *
   * Helps with accessibility for keyboard only users.
   *
   * Learn more: https://git.io/vWdr2
   */
  ( function() {
	  var isWebkit = navigator.userAgent.toLowerCase().indexOf( 'webkit' ) > -1,
		  isOpera  = navigator.userAgent.toLowerCase().indexOf( 'opera' )  > -1,
		  isIe     = navigator.userAgent.toLowerCase().indexOf( 'msie' )   > -1;

	  if ( ( isWebkit || isOpera || isIe ) && document.getElementById && window.addEventListener ) {
		  window.addEventListener( 'hashchange', function() {
			  var id = location.hash.substring( 1 ),
				  element;

			  if ( ! ( /^[A-z0-9_-]+$/.test( id ) ) ) {
				  return;
			  }

			  element = document.getElementById( id );

			  if ( element ) {
				  if ( ! ( /^(?:a|select|input|button|textarea)$/i.test( element.tagName ) ) ) {
					  element.tabIndex = -1;
				  }

				  element.focus();
			  }
		  }, false );
	  }
  })();

  /** @preserve jQuery.floatThead 2.2.1 - https://mkoryak.github.io/floatThead/ - Copyright (c) 2012 - 2020 Misha Koryak **/
  // @license MIT

  /* @author Misha Koryak
   * @projectDescription position:fixed on steroids. Lock a table header in place while scrolling.
   *
   * Dependencies:
   * jquery 1.9.0+ [required] OR jquery 1.7.0+ jquery UI core
   *
   * https://mkoryak.github.io/floatThead/
   *
   * Tested on FF13+, Chrome 21+, IE9, IE10, IE11, EDGE
   */
  (function( $ ) {
	/**
	 * provides a default config object. You can modify this after including this script if you want to change the init defaults
	 * @type {!Object}
	 */
	$.floatThead = $.floatThead || {};
	$.floatThead.defaults = {
	  headerCellSelector: 'tr:visible:first>*:visible', //thead cells are this.
	  zIndex: 1001, //zindex of the floating thead (actually a container div)
	  position: 'auto', // 'fixed', 'absolute', 'auto'. auto picks the best for your table scrolling type.
	  top: 0, //String or function($table) - offset from top of window where the header should not pass above
	  bottom: 0, //String or function($table) - offset from the bottom of the table where the header should stop scrolling
	  scrollContainer: function($table) { // or boolean 'true' (use offsetParent) | function -> if the table has horizontal scroll bars then this is the container that has overflow:auto and causes those scroll bars
		return $([]);
	  },
	  responsiveContainer: function($table) { // only valid if scrollContainer is not used (ie window scrolling). this is the container which will control y scrolling at some mobile breakpoints
		return $([]);
	  },
	  getSizingRow: function($table, $cols, $fthCells){ // this is only called when using IE,
		// override it if the first row of the table is going to contain colgroups (any cell spans greater than one col)
		// it should return a jquery object containing a wrapped set of table cells comprising a row that contains no col spans and is visible
		return $table.find('tbody tr:visible:first>*:visible');
	  },
	  ariaLabel: function($table, $headerCell, columnIndex) { // This function will run for every header cell that exists in the table when we add aria-labels.
		// Override to customize the aria-label. NOTE: These labels will be added to the 'sizer cells' which get added to the real table and are not visible by the user (only screen readers),
		// The number of sizer columns might not match the header columns in your real table - I insert one sizer header cell per column. This means that if your table uses colspans or multiple header rows,
		// this will not be reflected by sizer cells. This is why I am giving you the `columnIndex`.
		return $headerCell.text();
	  },
	  floatTableClass: 'floatThead-table',
	  floatWrapperClass: 'floatThead-wrapper',
	  floatContainerClass: 'floatThead-container',
	  copyTableClass: true, //copy 'class' attribute from table into the floated table so that the styles match.
	  autoReflow: false, //(undocumented) - use MutationObserver api to reflow automatically when internal table DOM changes
	  debug: false, //print possible issues (that don't prevent script loading) to console, if console exists.
	  support: { //should we bind events that expect these frameworks to be present and/or check for them?
		bootstrap: true,
		datatables: true,
		jqueryUI: true,
		perfectScrollbar: true
	  },
	  floatContainerCss: {"overflow-x": "hidden"} // undocumented - css applied to the floatContainer
	};

	var util = (function underscoreShim(){
	  var that = {};
	  var hasOwnProperty = Object.prototype.hasOwnProperty, isThings = ['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'];
	  that.has = function(obj, key) {
		return hasOwnProperty.call(obj, key);
	  };
	  that.keys = Object.keys || function(obj) {
		if (obj !== Object(obj)) throw new TypeError('Invalid object');
		var keys = [];
		for (var key in obj) if (that.has(obj, key)) keys.push(key);
		return keys;
	  };
	  var idCounter = 0;
	  that.uniqueId = function(prefix) {
		var id = ++idCounter + '';
		return prefix ? prefix + id : id;
	  };
	  $.each(isThings, function(){
		var name = this;
		that['is' + name] = function(obj) {
		  return Object.prototype.toString.call(obj) === '[object ' + name + ']';
		};
	  });
	  that.debounce = function(func, wait, immediate) {
		var timeout, args, context, timestamp, result;
		return function() {
		  context = this;
		  args = arguments;
		  timestamp = new Date();
		  var later = function() {
			var last = (new Date()) - timestamp;
			if (last < wait) {
			  timeout = setTimeout(later, wait - last);
			} else {
			  timeout = null;
			  if (!immediate) result = func.apply(context, args);
			}
		  };
		  var callNow = immediate && !timeout;
		  if (!timeout) {
			timeout = setTimeout(later, wait);
		  }
		  if (callNow) result = func.apply(context, args);
		  return result;
		};
	  };
	  return that;
	})();

	var globalCanObserveMutations = typeof MutationObserver !== 'undefined';


	//browser stuff
	var ieVersion = function(){for(var a=3,b=document.createElement("b"),c=b.all||[];a = 1+a,b.innerHTML="<!--[if gt IE "+ a +"]><i><![endif]-->",c[0];);return 4<a?a:document.documentMode}();
	var isFF = /Gecko\//.test(navigator.userAgent);
	var isWebkit = /WebKit\//.test(navigator.userAgent);
	var isRTL = /rtl/i.test(document.documentElement.dir || '');

	if(!(ieVersion || isFF || isWebkit)){
	  ieVersion = 11; //yey a hack!
	}

	//safari 7 (and perhaps others) reports table width to be parent container's width if max-width is set on table. see: https://github.com/mkoryak/floatThead/issues/108
	var isTableWidthBug = function(){
	  if(isWebkit) {
		var $test = $('<div>').css('width', 0).append(
			$('<table>').css('max-width', '100%').append(
				$('<tr>').append(
					$('<th>').append(
						$('<div>').css('min-width', 100).text('X')
					)
				)
			)
		);
		$("body").append($test);
		var ret = ($test.find("table").width() === 0);
		$test.remove();
		return ret;
	  }
	  return false;
	};

	var createElements = !isFF && !ieVersion; //FF can read width from <col> elements, but webkit cannot

	var $window = $(window);

	var buggyMatchMedia = isFF && window.matchMedia; // TODO remove when fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=774398

	if(!window.matchMedia || buggyMatchMedia) {
	  var _beforePrint = window.onbeforeprint;
	  var _afterPrint = window.onafterprint;
	  window.onbeforeprint = function () {
		_beforePrint && _beforePrint();
		$window.triggerHandler("fth-beforeprint");
	  };
	  window.onafterprint = function () {
		_afterPrint && _afterPrint();
		$window.triggerHandler("fth-afterprint");
	  };
	}

	/**
	 * @param eventName
	 * @param cb
	 */
	function windowResize(eventName, cb){
	  if(ieVersion === 8){ //ie8 is crap: https://github.com/mkoryak/floatThead/issues/65
		var winWidth = $window.width();
		var debouncedCb = util.debounce(function(){
		  var winWidthNew = $window.width();
		  if(winWidth !== winWidthNew){
			winWidth = winWidthNew;
			cb();
		  }
		}, 1);
		$window.on(eventName, debouncedCb);
	  } else {
		$window.on(eventName, util.debounce(cb, 1));
	  }
	}

	function getClosestScrollContainer($elem) {
	  var elem = $elem[0];
	  var parent = elem.parentElement;

	  do {
		var pos = window
			.getComputedStyle(parent)
			.getPropertyValue('overflow');

		if (pos !== 'visible') break;

	  } while (parent = parent.parentElement);

	  if(parent === document.body){
		return $([]);
	  }
	  return $(parent);
	}


	function debug(str){
	  window && window.console && window.console.error && window.console.error("jQuery.floatThead: " + str);
	}

	//returns fractional pixel widths
	function getOffsetWidth(el) {
	  var rect = el.getBoundingClientRect();
	  return rect.width || rect.right - rect.left;
	}

	/**
	 * try to calculate the scrollbar width for your browser/os
	 * @return {Number}
	 */
	function scrollbarWidth() {
	  var d = document.createElement("scrolltester");
	  d.style.cssText = 'width:100px;height:100px;overflow:scroll!important;position:absolute;top:-9999px;display:block';
	  document.body.appendChild(d);
	  var result = d.offsetWidth - d.clientWidth;
	  document.body.removeChild(d);
	  return result;
	}

	/**
	 * Check if a given table has been datatableized (https://datatables.net)
	 * @param $table
	 * @return {Boolean}
	 */
	function isDatatable($table){
	  if($table.dataTableSettings){
		for(var i = 0; i < $table.dataTableSettings.length; i++){
		  var table = $table.dataTableSettings[i].nTable;
		  if($table[0] === table){
			return true;
		  }
		}
	  }
	  return false;
	}

	function tableWidth($table, $fthCells, isOuter){
	  // see: https://github.com/mkoryak/floatThead/issues/108
	  var fn = isOuter ? "outerWidth": "width";
	  if(isTableWidthBug && $table.css("max-width")){
		var w = 0;
		if(isOuter) {
		  w += parseInt($table.css("borderLeft"), 10);
		  w += parseInt($table.css("borderRight"), 10);
		}
		for(var i=0; i < $fthCells.length; i++){
		  w += getOffsetWidth($fthCells.get(i));
		}
		return w;
	  } else {
		return $table[fn]();
	  }
	}
	$.fn.floatThead = function(map){
	  map = map || {};

	  if(ieVersion < 8){
		return this; //no more crappy browser support.
	  }

	  if(util.isFunction(isTableWidthBug)) {
		isTableWidthBug = isTableWidthBug();
	  }

	  if(util.isString(map)){
		var command = map;
		var args = Array.prototype.slice.call(arguments, 1);
		var ret = this;
		this.filter('table').each(function(){
		  var $this = $(this);
		  var opts = $this.data('floatThead-lazy');
		  if(opts){
			$this.floatThead(opts);
		  }
		  var obj = $this.data('floatThead-attached');
		  if(obj && util.isFunction(obj[command])){
			var r = obj[command].apply(this, args);
			if(r !== undefined){
			  ret = r;
			}
		  }
		});
		return ret;
	  }
	  var opts = $.extend({}, $.floatThead.defaults || {}, map);

	  $.each(map, function(key, val){
		if((!(key in $.floatThead.defaults)) && opts.debug){
		  debug("Used ["+key+"] key to init plugin, but that param is not an option for the plugin. Valid options are: "+ (util.keys($.floatThead.defaults)).join(', '));
		}
	  });
	  if(opts.debug){
		var v = $.fn.jquery.split(".");
		if(parseInt(v[0], 10) === 1 && parseInt(v[1], 10) <= 7){
		  debug("jQuery version "+$.fn.jquery+" detected! This plugin supports 1.8 or better, or 1.7.x with jQuery UI 1.8.24 -> http://jqueryui.com/resources/download/jquery-ui-1.8.24.zip")
		}
	  }

	  this.filter(':not(.'+opts.floatTableClass+')').each(function(){
		var floatTheadId = util.uniqueId();
		var $table = $(this);
		if($table.data('floatThead-attached')){
		  return true; //continue the each loop
		}
		if(!$table.is('table')){
		  throw new Error('jQuery.floatThead must be run on a table element. ex: $("table").floatThead();');
		}
		var canObserveMutations = opts.autoReflow && globalCanObserveMutations; //option defaults to false!
		var mObs = null; //mutation observer lives in here if we can use it / make it
		var $header = $table.children('thead:first');
		var $tbody = $table.children('tbody:first');
		if($header.length === 0 || $tbody.length === 0){
		  if(opts.debug) {
			if($header.length === 0){
			  debug('The thead element is missing.');
			} else{
			  debug('The tbody element is missing.');
			}
		  }
		  $table.data('floatThead-lazy', opts);
		  $table.unbind("reflow").one('reflow', function(){
			$table.floatThead(opts);
		  });
		  return;
		}
		if($table.data('floatThead-lazy')){
		  $table.unbind("reflow");
		}
		$table.data('floatThead-lazy', false);

		var headerFloated = true;
		var scrollingTop, scrollingBottom;
		var scrollbarOffset = {vertical: 0, horizontal: 0};
		if(util.isFunction(scrollbarWidth)) {
		  scrollbarWidth = scrollbarWidth();
		}

		var lastColumnCount = 0; //used by columnNum()

		if(opts.scrollContainer === true){
		  opts.scrollContainer = getClosestScrollContainer;
		}

		var $scrollContainer = opts.scrollContainer($table) || $([]); //guard against returned nulls
		var locked = $scrollContainer.length > 0;
		var $responsiveContainer = locked ? $([]) : opts.responsiveContainer($table) || $([]);
		var responsive = isResponsiveContainerActive();

		var useAbsolutePositioning = null;



		if (opts.position === 'auto') {
		  useAbsolutePositioning = null;
		} else if (opts.position === 'fixed') {
		  useAbsolutePositioning = false;
		} else if (opts.position === 'absolute'){
		  useAbsolutePositioning = true;
		} else if (opts.debug) {
		  debug('Invalid value given to "position" option, valid is "fixed", "absolute" and "auto". You passed: ', opts.position);
		}

		if(useAbsolutePositioning == null){ //defaults: locked=true, !locked=false
		  useAbsolutePositioning = locked;
		}
		var $caption = $table.find("caption");
		var haveCaption = $caption.length === 1;
		if(haveCaption){
		  var captionAlignTop = ($caption.css("caption-side") || $caption.attr("align") || "top") === "top";
		}

		var $fthGrp = $('<fthfoot>').css({
		  'display': 'table-footer-group',
		  'border-spacing': 0,
		  'height': 0,
		  'border-collapse': 'collapse',
		  'visibility': 'hidden'
		});

		var wrappedContainer = false; //used with absolute positioning enabled. did we need to wrap the scrollContainer/table with a relative div?
		var $wrapper = $([]); //used when absolute positioning enabled - wraps the table and the float container
		var absoluteToFixedOnScroll = ieVersion <= 9 && !locked && useAbsolutePositioning; //on IE using absolute positioning doesn't look good with window scrolling, so we change position to fixed on scroll, and then change it back to absolute when done.
		var $floatTable = $("<table/>");
		var $floatColGroup = $("<colgroup/>");
		var $tableColGroup = $table.children('colgroup:first');
		var existingColGroup = true;
		if($tableColGroup.length === 0){
		  $tableColGroup = $("<colgroup/>");
		  existingColGroup = false;
		}
		var colSelector = existingColGroup ? "col:visible" : "col";
		var $fthRow = $('<fthtr>').css({ //created unstyled elements (used for sizing the table because chrome can't read <col> width)
		  'display': 'table-row',
		  'border-spacing': 0,
		  'height': 0,
		  'border-collapse': 'collapse'
		});
		var $floatContainer = $('<div>').css(opts.floatContainerCss).attr('aria-hidden', 'true');
		var floatTableHidden = false; //this happens when the table is hidden and we do magic when making it visible
		var $newHeader = $("<thead/>");
		var $sizerRow = $('<tr class="size-row"/>');
		var $sizerCells = $([]);
		var $tableCells = $([]); //used for sizing - either $sizerCells or $tableColGroup cols. $tableColGroup cols are only created in chrome for borderCollapse:collapse because of a chrome bug.
		var $headerCells = $([]);
		var $fthCells = $([]); //created elements

		$newHeader.append($sizerRow);
		$table.prepend($tableColGroup);
		if(createElements){
		  $fthGrp.append($fthRow);
		  $table.append($fthGrp);
		}

		$floatTable.append($floatColGroup);
		$floatContainer.append($floatTable);
		if(opts.copyTableClass){
		  $floatTable.attr('class', $table.attr('class'));
		}
		$floatTable.attr({ //copy over some deprecated table attributes that people still like to use. Good thing people don't use colgroups...
		  'cellpadding': $table.attr('cellpadding'),
		  'cellspacing': $table.attr('cellspacing'),
		  'border': $table.attr('border')
		});
		var tableDisplayCss = $table.css('display');
		$floatTable.css({
		  'borderCollapse': $table.css('borderCollapse'),
		  'border': $table.css('border'),
		  'display': tableDisplayCss
		});
		if(!locked){
		  $floatTable.css('width', 'auto');
		}
		if(tableDisplayCss === 'none'){
		  floatTableHidden = true;
		}

		$floatTable.addClass(opts.floatTableClass).css({'margin': 0, 'border-bottom-width': 0}); //must have no margins or you won't be able to click on things under floating table

		if(useAbsolutePositioning){
		  var makeRelative = function($container, alwaysWrap){
			var positionCss = $container.css('position');
			var relativeToScrollContainer = (positionCss === "relative" || positionCss === "absolute");
			var $containerWrap = $container;
			if(!relativeToScrollContainer || alwaysWrap){
			  var css = {"paddingLeft": $container.css('paddingLeft'), "paddingRight": $container.css('paddingRight')};
			  $floatContainer.css(css);
			  $containerWrap = $container.data('floatThead-containerWrap') || $container.wrap(
				  $('<div>').addClass(opts.floatWrapperClass).css({
					'position': 'relative',
					'clear': 'both'
				  })
			  ).parent();
			  $container.data('floatThead-containerWrap', $containerWrap); //multiple tables inside one scrolling container - #242
			  wrappedContainer = true;
			}
			return $containerWrap;
		  };
		  if(locked){
			$wrapper = makeRelative($scrollContainer, true);
			$wrapper.prepend($floatContainer);
		  } else {
			$wrapper = makeRelative($table);
			$table.before($floatContainer);
		  }
		} else {
		  $table.before($floatContainer);
		}


		$floatContainer.css({
		  position: useAbsolutePositioning ? 'absolute' : 'fixed',
		  marginTop: 0,
		  top:  useAbsolutePositioning ? 0 : 'auto',
		  zIndex: opts.zIndex,
		  willChange: 'transform'
		});
		$floatContainer.addClass(opts.floatContainerClass);
		updateScrollingOffsets();

		var layoutFixed = {'table-layout': 'fixed'};
		var layoutAuto = {'table-layout': $table.css('tableLayout') || 'auto'};
		var originalTableWidth = $table[0].style.width || ""; //setting this to auto is bad: #70
		var originalTableMinWidth = $table.css('minWidth') || "";

		function eventName(name){
		  return name+'.fth-'+floatTheadId+'.floatTHead'
		}

		function setHeaderHeight(){
		  var headerHeight = 0;
		  $header.children("tr:visible").each(function(){
			headerHeight += $(this).outerHeight(true);
		  });
		  if($table.css('border-collapse') === 'collapse') {
			var tableBorderTopHeight = parseInt($table.css('border-top-width'), 10);
			var cellBorderTopHeight = parseInt($table.find("thead tr:first").find(">*:first").css('border-top-width'), 10);
			if(tableBorderTopHeight > cellBorderTopHeight) {
			  headerHeight -= (tableBorderTopHeight / 2); //id love to see some docs where this magic recipe is found..
			}
		  }
		  $sizerRow.outerHeight(headerHeight);
		  $sizerCells.outerHeight(headerHeight);
		}


		function setFloatWidth(){
		  var tw = tableWidth($table, $fthCells, true);
		  var $container = responsive ? $responsiveContainer : $scrollContainer;
		  var width = $container.length ? getOffsetWidth($container[0]) : tw;
		  var floatContainerWidth = $container.css("overflow-y") !== 'hidden' ? width - scrollbarOffset.vertical : width;
		  $floatContainer.width(floatContainerWidth);
		  if(locked){
			var percent = 100 * tw / (floatContainerWidth);
			$floatTable.css('width', percent+'%');
		  } else {
			$floatTable.css('width', tw+'px');
		  }
		}

		function updateScrollingOffsets(){
		  scrollingTop = (util.isFunction(opts.top) ? opts.top($table) : opts.top) || 0;
		  scrollingBottom = (util.isFunction(opts.bottom) ? opts.bottom($table) : opts.bottom) || 0;
		}

		/**
		 * get the number of columns and also rebuild resizer rows if the count is different than the last count
		 */
		function columnNum(){
		  var count;
		  var $headerColumns = $header.find(opts.headerCellSelector);
		  if(existingColGroup){
			count = $tableColGroup.find(colSelector).length;
		  } else {
			count = 0;
			$headerColumns.each(function () {
			  count += parseInt(($(this).attr('colspan') || 1), 10);
			});
		  }
		  if(count !== lastColumnCount){
			lastColumnCount = count;
			var cells = [], cols = [], psuedo = [];
			$sizerRow.empty();
			for(var x = 0; x < count; x++){
			  var cell = document.createElement('th');
			  cell.setAttribute('aria-label', opts.ariaLabel($table, $headerColumns.eq(x), x));
			  cell.className = 'floatThead-col';
			  $sizerRow[0].appendChild(cell);
			  cols.push('<col/>');
			  psuedo.push(
				  $('<fthtd>').css({
					'display': 'table-cell',
					'height': 0,
					'width': 'auto'
				  })
			  );
			}

			if(existingColGroup){
			  cols = $tableColGroup.html();
			} else {
			  cols = cols.join('');
			}

			if(createElements){
			  $fthRow.empty();
			  $fthRow.append(psuedo);
			  $fthCells = $fthRow.find('fthtd');
			}

			$sizerCells = $sizerRow.find("th");
			if(!existingColGroup){
			  $tableColGroup.html(cols);
			}
			$tableCells = $tableColGroup.find(colSelector);
			$floatColGroup.html(cols);
			$headerCells = $floatColGroup.find(colSelector);

		  }
		  return count;
		}

		function refloat(){ //make the thing float
		  if(!headerFloated){
			headerFloated = true;
			if(useAbsolutePositioning){ //#53, #56
			  var tw = tableWidth($table, $fthCells, true);
			  var wrapperWidth = $wrapper.width();
			  if(tw > wrapperWidth){
				$table.css('minWidth', tw);
			  }
			}
			$table.css(layoutFixed);
			$floatTable.css(layoutFixed);
			$floatTable.append($header); //append because colgroup must go first in chrome
			$tbody.before($newHeader);
			setHeaderHeight();
		  }
		}
		function unfloat(){ //put the header back into the table
		  if(headerFloated){
			headerFloated = false;
			if(useAbsolutePositioning){ //#53, #56
			  $table.width(originalTableWidth);
			}
			$newHeader.detach();
			$table.prepend($header);
			$table.css(layoutAuto);
			$floatTable.css(layoutAuto);
			$table.css('minWidth', originalTableMinWidth); //this looks weird, but it's not a bug. Think about it!!
			$table.css('minWidth', tableWidth($table, $fthCells)); //#121
		  }
		}
		var isHeaderFloatingLogical = false; //for the purpose of this event, the header is/isnt floating, even though the element
											 //might be in some other state. this is what the header looks like to the user
		function triggerFloatEvent(isFloating){
		  if(isHeaderFloatingLogical !== isFloating){
			isHeaderFloatingLogical = isFloating;
			$table.triggerHandler("floatThead", [isFloating, $floatContainer])
		  }
		}
		function changePositioning(isAbsolute){
		  if(useAbsolutePositioning !== isAbsolute){
			useAbsolutePositioning = isAbsolute;
			$floatContainer.css({
			  position: useAbsolutePositioning ? 'absolute' : 'fixed'
			});
		  }
		}
		function getSizingRow($table, $cols, $fthCells, ieVersion){
		  if(createElements){
			return $fthCells;
		  } else if(ieVersion) {
			return opts.getSizingRow($table, $cols, $fthCells);
		  } else {
			return $cols;
		  }
		}

		/**
		 * returns a function that updates the floating header's cell widths.
		 * @return {Function}
		 */
		function reflow(){
		  var i;
		  var numCols = columnNum(); //if the tables columns changed dynamically since last time (datatables), rebuild the sizer rows and get a new count

		  return function(){
			//Cache the current scrollLeft value so that it can be reset post reflow
			var scrollLeft = $floatContainer.scrollLeft();
			$tableCells = $tableColGroup.find(colSelector);
			var $rowCells = getSizingRow($table, $tableCells, $fthCells, ieVersion);

			if($rowCells.length === numCols && numCols > 0){
			  if(!existingColGroup){
				for(i=0; i < numCols; i++){
				  $tableCells.eq(i).css('width', '');
				}
			  }
			  unfloat();
			  var widths = [];
			  for(i=0; i < numCols; i++){
				widths[i] = getOffsetWidth($rowCells.get(i));
			  }
			  for(i=0; i < numCols; i++){
				$headerCells.eq(i).width(widths[i]);
				$tableCells.eq(i).width(widths[i]);
			  }
			  refloat();
			} else {
			  $floatTable.append($header);
			  $table.css(layoutAuto);
			  $floatTable.css(layoutAuto);
			  setHeaderHeight();
			}
			//Set back the current scrollLeft value on floatContainer
			$floatContainer.scrollLeft(scrollLeft);
			$table.triggerHandler("reflowed", [$floatContainer]);
		  };
		}

		function floatContainerBorderWidth(side){
		  var border = $scrollContainer.css("border-"+side+"-width");
		  var w = 0;
		  if (border && ~border.indexOf('px')) {
			w = parseInt(border, 10);
		  }
		  return w;
		}

		function isResponsiveContainerActive(){
		  return $responsiveContainer.css("overflow-x") === 'auto';
		}
		/**
		 * first performs initial calculations that we expect to not change when the table, window, or scrolling container are scrolled.
		 * returns a function that calculates the floating container's top and left coords. takes into account if we are using page scrolling or inner scrolling
		 * @return {Function}
		 */
		function calculateFloatContainerPosFn(){
		  var scrollingContainerTop = $scrollContainer.scrollTop();

		  //this floatEnd calc was moved out of the returned function because we assume the table height doesn't change (otherwise we must reinit by calling calculateFloatContainerPosFn)
		  var floatEnd;
		  var tableContainerGap = 0;
		  var captionHeight = haveCaption ? $caption.outerHeight(true) : 0;
		  var captionScrollOffset = captionAlignTop ? captionHeight : -captionHeight;

		  var floatContainerHeight = $floatContainer.height();
		  var tableOffset = $table.offset();
		  var tableLeftGap = 0; //can be caused by border on container (only in locked mode)
		  var tableTopGap = 0;
		  if(locked){
			var containerOffset = $scrollContainer.offset();
			tableContainerGap = tableOffset.top - containerOffset.top + scrollingContainerTop;
			if(haveCaption && captionAlignTop){
			  tableContainerGap += captionHeight;
			}
			tableLeftGap = floatContainerBorderWidth('left');
			tableTopGap = floatContainerBorderWidth('top');
			tableContainerGap -= tableTopGap;
		  } else {
			floatEnd = tableOffset.top - scrollingTop - floatContainerHeight + scrollingBottom + scrollbarOffset.horizontal;
		  }
		  var windowTop = $window.scrollTop();
		  var windowLeft = $window.scrollLeft();
		  var getScrollContainerLeft = function(){
			return (isResponsiveContainerActive() ?  $responsiveContainer : $scrollContainer).scrollLeft() || 0;
		  };
		  var scrollContainerLeft = getScrollContainerLeft();

		  return function(eventType){
			responsive = isResponsiveContainerActive();

			var isTableHidden = $table[0].offsetWidth <= 0 && $table[0].offsetHeight <= 0;
			if(!isTableHidden && floatTableHidden) {
			  floatTableHidden = false;
			  setTimeout(function(){
				$table.triggerHandler("reflow");
			  }, 1);
			  return null;
			}
			if(isTableHidden){ //it's hidden
			  floatTableHidden = true;
			  if(!useAbsolutePositioning){
				return null;
			  }
			}

			if(eventType === 'windowScroll'){
			  windowTop = $window.scrollTop();
			  windowLeft = $window.scrollLeft();
			} else if(eventType === 'containerScroll'){
			  if($responsiveContainer.length){
				if(!responsive){
				  return; //we dont care about the event if we arent responsive right now
				}
				scrollContainerLeft = $responsiveContainer.scrollLeft();
			  } else {
				scrollingContainerTop = $scrollContainer.scrollTop();
				scrollContainerLeft = $scrollContainer.scrollLeft();
			  }
			} else if(eventType !== 'init') {
			  windowTop = $window.scrollTop();
			  windowLeft = $window.scrollLeft();
			  scrollingContainerTop = $scrollContainer.scrollTop();
			  scrollContainerLeft =  getScrollContainerLeft();
			}
			if(isWebkit && (windowTop < 0 || (isRTL && windowLeft > 0 ) || ( !isRTL && windowLeft < 0 )) ){
			  //chrome overscroll effect at the top of the page - breaks fixed positioned floated headers
			  return;
			}

			if(absoluteToFixedOnScroll){
			  if(eventType === 'windowScrollDone'){
				changePositioning(true); //change to absolute
			  } else {
				changePositioning(false); //change to fixed
			  }
			} else if(eventType === 'windowScrollDone'){
			  return null; //event is fired when they stop scrolling. ignore it if not 'absoluteToFixedOnScroll'
			}

			tableOffset = $table.offset();
			if(haveCaption && captionAlignTop){
			  tableOffset.top += captionHeight;
			}
			var top, left;
			var tableHeight = $table.outerHeight();

			if(locked && useAbsolutePositioning){ //inner scrolling, absolute positioning
			  if (tableContainerGap >= scrollingContainerTop) {
				var gap = tableContainerGap - scrollingContainerTop + tableTopGap;
				top = gap > 0 ? gap : 0;
				triggerFloatEvent(false);
			  } else if(scrollingContainerTop - tableContainerGap > tableHeight - floatContainerHeight){
				// scrolled past table but there is space in the container under it..
				top = tableHeight - floatContainerHeight - scrollingContainerTop - tableContainerGap;
			  } else {
				top = wrappedContainer ? tableTopGap : scrollingContainerTop;
				//headers stop at the top of the viewport
				triggerFloatEvent(true);
			  }
			  left = tableLeftGap;
			} else if(!locked && useAbsolutePositioning) { //window scrolling, absolute positioning
			  if(windowTop > floatEnd + tableHeight + captionScrollOffset){
				top = tableHeight - floatContainerHeight + captionScrollOffset + scrollingBottom; //scrolled past table
			  } else if (tableOffset.top >= windowTop + scrollingTop) {
				top = 0; //scrolling to table
				unfloat();
				triggerFloatEvent(false);
			  } else {
				top = scrollingTop + windowTop - tableOffset.top + tableContainerGap + (captionAlignTop ? captionHeight : 0);
				refloat(); //scrolling within table. header floated
				triggerFloatEvent(true);
			  }
			  left =  scrollContainerLeft;
			} else if(locked && !useAbsolutePositioning){ //inner scrolling, fixed positioning
			  if (tableContainerGap > scrollingContainerTop || scrollingContainerTop - tableContainerGap > tableHeight) {
				top = tableOffset.top - windowTop;
				unfloat();
				triggerFloatEvent(false);
			  } else {
				top = tableOffset.top + scrollingContainerTop  - windowTop - tableContainerGap;
				refloat();
				triggerFloatEvent(true);
				//headers stop at the top of the viewport
			  }
			  left = tableOffset.left + scrollContainerLeft - windowLeft;
			} else if(!locked && !useAbsolutePositioning) { //window scrolling, fixed positioning
			  if(windowTop > floatEnd + tableHeight + captionScrollOffset){
				top = tableHeight + scrollingTop - windowTop + floatEnd + captionScrollOffset;
				//scrolled past the bottom of the table
			  } else if (tableOffset.top > windowTop + scrollingTop) {
				top = tableOffset.top - windowTop;
				refloat();
				triggerFloatEvent(false); //this is a weird case, the header never gets unfloated and i have no no way to know
				//scrolled past the top of the table
			  } else {
				//scrolling within the table
				top = scrollingTop;
				triggerFloatEvent(true);
			  }
			  left = tableOffset.left + scrollContainerLeft - windowLeft;
			}
			return {top: Math.round(top), left: Math.round(left)};
		  };
		}
		/**
		 * returns a function that caches old floating container position and only updates css when the position changes
		 * @return {Function}
		 */
		function repositionFloatContainerFn(){
		  var oldTop = null;
		  var oldLeft = null;
		  var oldScrollLeft = null;
		  return function(pos, setWidth, setHeight){
			if(pos != null && (oldTop !== pos.top || oldLeft !== pos.left)){
			  if(ieVersion === 8){
				$floatContainer.css({
				  top: pos.top,
				  left: pos.left
				});
			  } else {
				var transform = 'translateX(' + pos.left + 'px) translateY(' + pos.top + 'px)';
				var cssObj = {
				  '-webkit-transform' : transform,
				  '-moz-transform'    : transform,
				  '-ms-transform'     : transform,
				  '-o-transform'      : transform,
				  'transform'         : transform,
				  'top': 0,
				  'left': 0,
				};
				$floatContainer.css(cssObj);
			  }
			  oldTop = pos.top;
			  oldLeft = pos.left;
			}
			if(setWidth){
			  setFloatWidth();
			}
			if(setHeight){
			  setHeaderHeight();
			}
			var scrollLeft = (responsive ? $responsiveContainer : $scrollContainer).scrollLeft();
			if(!useAbsolutePositioning || oldScrollLeft !== scrollLeft){
			  $floatContainer.scrollLeft(scrollLeft);
			  oldScrollLeft = scrollLeft;
			}
		  }
		}

		/**
		 * checks if THIS table has scrollbars, and finds their widths
		 */
		function calculateScrollBarSize(){ //this should happen after the floating table has been positioned
		  if($scrollContainer.length){
			if(opts.support && opts.support.perfectScrollbar && $scrollContainer.data().perfectScrollbar){
			  scrollbarOffset = {horizontal:0, vertical:0};
			} else {
			  if($scrollContainer.css('overflow-x') === 'scroll'){
				scrollbarOffset.horizontal = scrollbarWidth;
			  } else {
				var sw = $scrollContainer.width(), tw = tableWidth($table, $fthCells);
				var offsetv = sh < th ? scrollbarWidth : 0;
				scrollbarOffset.horizontal = sw - offsetv < tw ? scrollbarWidth : 0;
			  }
			  if($scrollContainer.css('overflow-y') === 'scroll'){
				scrollbarOffset.vertical = scrollbarWidth;
			  } else {
				var sh = $scrollContainer.height(), th = $table.height();
				var offseth = sw < tw ? scrollbarWidth : 0;
				scrollbarOffset.vertical = sh - offseth < th ? scrollbarWidth : 0;
			  }
			}
		  }
		}
		//finish up. create all calculation functions and bind them to events
		calculateScrollBarSize();

		var flow;

		var ensureReflow = function(){
		  flow = reflow();
		  flow();
		};

		ensureReflow();

		var calculateFloatContainerPos = calculateFloatContainerPosFn();
		var repositionFloatContainer = repositionFloatContainerFn();

		repositionFloatContainer(calculateFloatContainerPos('init'), true); //this must come after reflow because reflow changes scrollLeft back to 0 when it rips out the thead

		var windowScrollDoneEvent = util.debounce(function(){
		  repositionFloatContainer(calculateFloatContainerPos('windowScrollDone'), false);
		}, 1);

		var windowScrollEvent = function(){
		  repositionFloatContainer(calculateFloatContainerPos('windowScroll'), false);
		  if(absoluteToFixedOnScroll){
			windowScrollDoneEvent();
		  }
		};
		var containerScrollEvent = function(){
		  repositionFloatContainer(calculateFloatContainerPos('containerScroll'), false);
		};


		var windowResizeEvent = function(){
		  if($table.is(":hidden")){
			return;
		  }
		  updateScrollingOffsets();
		  calculateScrollBarSize();
		  ensureReflow();
		  calculateFloatContainerPos = calculateFloatContainerPosFn();
		  repositionFloatContainer = repositionFloatContainerFn();
		  repositionFloatContainer(calculateFloatContainerPos('resize'), true, true);
		};
		var reflowEvent = util.debounce(function(){
		  if($table.is(":hidden")){
			return;
		  }
		  calculateScrollBarSize();
		  updateScrollingOffsets();
		  ensureReflow();
		  calculateFloatContainerPos = calculateFloatContainerPosFn();
		  repositionFloatContainer(calculateFloatContainerPos('reflow'), true, true);
		}, 1);

		/////// printing stuff
		var beforePrint = function(){
		  unfloat();
		};
		var afterPrint = function(){
		  refloat();
		};
		var printEvent = function(mql){
		  //make printing the table work properly on IE10+
		  if(mql.matches) {
			beforePrint();
		  } else {
			afterPrint();
		  }
		};

		var matchMediaPrint = null;
		if(window.matchMedia && window.matchMedia('print').addListener && !buggyMatchMedia){
		  matchMediaPrint = window.matchMedia("print");
		  matchMediaPrint.addListener(printEvent);
		} else {
		  $window.on('fth-beforeprint', beforePrint);
		  $window.on('fth-afterprint', afterPrint);
		}
		////// end printing stuff


		if(locked){ //internal scrolling
		  if(useAbsolutePositioning){
			$scrollContainer.on(eventName('scroll'), containerScrollEvent);
		  } else {
			$scrollContainer.on(eventName('scroll'), containerScrollEvent);
			$window.on(eventName('scroll'), windowScrollEvent);
		  }
		} else { //window scrolling
		  $responsiveContainer.on(eventName('scroll'), containerScrollEvent);
		  $window.on(eventName('scroll'), windowScrollEvent);
		}

		$window.on(eventName('load'), reflowEvent); //for tables with images

		windowResize(eventName('resize'), windowResizeEvent);
		$table.on('reflow', reflowEvent);
		if(opts.support && opts.support.datatables && isDatatable($table)){
		  $table
			  .on('filter', reflowEvent)
			  .on('sort',   reflowEvent)
			  .on('page',   reflowEvent);
		}

		if(opts.support && opts.support.bootstrap) {
		  $window.on(eventName('shown.bs.tab'), reflowEvent); // people cant seem to figure out how to use this plugin with bs3 tabs... so this :P
		}
		if(opts.support && opts.support.jqueryUI) {
		  $window.on(eventName('tabsactivate'), reflowEvent); // same thing for jqueryui
		}


		if (canObserveMutations) {
		  var mutationElement = null;
		  if(util.isFunction(opts.autoReflow)){
			mutationElement = opts.autoReflow($table, $scrollContainer)
		  }
		  if(!mutationElement) {
			mutationElement = $scrollContainer.length ? $scrollContainer[0] : $table[0]
		  }
		  mObs = new MutationObserver(function(e){
			var wasTableRelated = function(nodes){
			  return nodes && nodes[0] && (nodes[0].nodeName === "THEAD" || nodes[0].nodeName === "TD"|| nodes[0].nodeName === "TH");
			};
			for(var i=0; i < e.length; i++){
			  if(!(wasTableRelated(e[i].addedNodes) || wasTableRelated(e[i].removedNodes))){
				reflowEvent();
				break;
			  }
			}
		  });
		  mObs.observe(mutationElement, {
			childList: true,
			subtree: true
		  });
		}

		//attach some useful functions to the table.
		$table.data('floatThead-attached', {
		  destroy: function(){
			var ns = '.fth-'+floatTheadId;
			unfloat();
			$table.css(layoutAuto);
			$tableColGroup.remove();
			createElements && $fthGrp.remove();
			if($newHeader.parent().length){ //only if it's in the DOM
			  $newHeader.replaceWith($header);
			}
			triggerFloatEvent(false);
			if(canObserveMutations){
			  mObs.disconnect();
			  mObs = null;
			}
			$table.off('reflow reflowed');
			$scrollContainer.off(ns);
			$responsiveContainer.off(ns);
			if (wrappedContainer) {
			  if ($scrollContainer.length) {
				$scrollContainer.unwrap();
			  }
			  else {
				$table.unwrap();
			  }
			}
			if(locked){
			  $scrollContainer.data('floatThead-containerWrap', false);
			} else {
			  $table.data('floatThead-containerWrap', false);
			}
			$table.css('minWidth', originalTableMinWidth);
			$floatContainer.remove();
			$table.data('floatThead-attached', false);
			$window.off(ns);
			$window.off('fth-beforeprint fth-afterprint'); // Not bound with id, so cant use ns.
			if (matchMediaPrint) {
			  matchMediaPrint.removeListener(printEvent);
			}
			beforePrint = afterPrint = function(){};

			return function reinit(){
			  return $table.floatThead(opts);
			}
		  },
		  reflow: function(){
			reflowEvent();
		  },
		  setHeaderHeight: function(){
			setHeaderHeight();
		  },
		  getFloatContainer: function(){
			return $floatContainer;
		  },
		  getRowGroups: function(){
			if(headerFloated){
			  return $floatContainer.find('>table>thead').add($table.children("tbody,tfoot"));
			} else {
			  return $table.children("thead,tbody,tfoot");
			}
		  }
		});
	  });
	  return this;
	};
  })((function(){
	var $ = window.jQuery;
	if(typeof module !== 'undefined' && module.exports && !$) {
	  // only use cjs if they dont have a jquery for me to use, and we have commonjs
	  $ = require('jquery');
	}
	return $;
  })());

  // ProgressBar.js 1.1.0
  // https://kimmobrunfeldt.github.io/progressbar.js
  // License: MIT

  (function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ProgressBar = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
  /*! Shifty 2.8.0 - https://github.com/jeremyckahn/shifty */
  !function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("shifty",[],n):"object"==typeof exports?exports.shifty=n():t.shifty=n()}(window,function(){return function(t){var n={};function e(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,e),i.l=!0,i.exports}return e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:r})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(e.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var i in t)e.d(r,i,function(n){return t[n]}.bind(null,i));return r},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=3)}([function(t,n,e){"use strict";(function(t){e.d(n,"e",function(){return d}),e.d(n,"c",function(){return y}),e.d(n,"b",function(){return _}),e.d(n,"a",function(){return g}),e.d(n,"d",function(){return w});var r=e(1);function i(t,n){for(var e=0;e<n.length;e++){var r=n[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function u(t){return(u="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function o(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{},r=Object.keys(e);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(e).filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.forEach(function(n){a(t,n,e[n])})}return t}function a(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}var c="undefined"!=typeof window?window:t,f=c.requestAnimationFrame||c.webkitRequestAnimationFrame||c.oRequestAnimationFrame||c.msRequestAnimationFrame||c.mozCancelRequestAnimationFrame&&c.mozRequestAnimationFrame||setTimeout,s=function(){},l=null,h=null,p=o({},r),d=function(t,n,e,r,i,u,o){var a=t<u?0:(t-u)/i;for(var c in n){var f=o[c],s=f.call?f:p[f],l=e[c];n[c]=l+(r[c]-l)*s(a)}return n},v=function(t,n){var e=t._attachment,r=t._currentState,i=t._delay,u=t._easing,o=t._originalState,a=t._duration,c=t._step,f=t._targetState,s=t._timestamp,l=s+i+a,h=n>l?l:n,p=a-(l-h);h>=l?(c(f,e,p),t.stop(!0)):(t._applyFilter("beforeTween"),h<s+i?(h=1,a=1,s=1):s+=i,d(h,r,o,f,a,s,u),t._applyFilter("afterTween"),c(r,e,p))},y=function(){for(var t=g.now(),n=l;n;){var e=n._next;v(n,t),n=e}},_=function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"linear",e={},r=u(n);if("string"===r||"function"===r)for(var i in t)e[i]=n;else for(var o in t)e[o]=n[o]||"linear";return e},m=function(t){if(t===l)(l=t._next)?l._previous=null:h=null;else if(t===h)(h=t._previous)?h._next=null:l=null;else{var n=t._previous,e=t._next;n._next=e,e._previous=n}t._previous=t._next=null},g=function(){function t(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;!function(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")}(this,t),this._currentState=n,this._configured=!1,this._filters=[],this._timestamp=null,this._next=null,this._previous=null,e&&this.setConfig(e)}var n,e,r;return n=t,(e=[{key:"_applyFilter",value:function(t){var n=!0,e=!1,r=void 0;try{for(var i,u=this._filters[Symbol.iterator]();!(n=(i=u.next()).done);n=!0){var o=i.value[t];o&&o(this)}}catch(t){e=!0,r=t}finally{try{n||null==u.return||u.return()}finally{if(e)throw r}}}},{key:"tween",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,e=this._attachment,r=this._configured;return!n&&r||this.setConfig(n),this._pausedAtTime=null,this._timestamp=t.now(),this._start(this.get(),e),this.resume()}},{key:"setConfig",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.attachment,i=e.delay,u=void 0===i?0:i,a=e.duration,c=void 0===a?500:a,f=e.easing,l=e.from,h=e.promise,p=void 0===h?Promise:h,d=e.start,v=void 0===d?s:d,y=e.step,m=void 0===y?s:y,g=e.to;this._configured=!0,this._attachment=r,this._isPlaying=!1,this._pausedAtTime=null,this._scheduleId=null,this._delay=u,this._start=v,this._step=m,this._duration=c,this._currentState=o({},l||this.get()),this._originalState=this.get(),this._targetState=o({},g||this.get());var w=this._currentState;this._targetState=o({},w,this._targetState),this._easing=_(w,f);var b=t.filters;for(var S in this._filters.length=0,b)b[S].doesApply(this)&&this._filters.push(b[S]);return this._applyFilter("tweenCreated"),this._promise=new p(function(t,e){n._resolve=t,n._reject=e}),this._promise.catch(s),this}},{key:"get",value:function(){return o({},this._currentState)}},{key:"set",value:function(t){this._currentState=t}},{key:"pause",value:function(){if(this._isPlaying)return this._pausedAtTime=t.now(),this._isPlaying=!1,m(this),this}},{key:"resume",value:function(){if(null===this._timestamp)return this.tween();if(this._isPlaying)return this._promise;var n=t.now();return this._pausedAtTime&&(this._timestamp+=n-this._pausedAtTime,this._pausedAtTime=null),this._isPlaying=!0,null===l?(l=this,h=this,function t(){l&&(f.call(c,t,1e3/60),y())}()):(this._previous=h,h._next=this,h=this),this._promise}},{key:"seek",value:function(n){n=Math.max(n,0);var e=t.now();return this._timestamp+n===0?this:(this._timestamp=e-n,this._isPlaying||v(this,e),this)}},{key:"stop",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=this._attachment,e=this._currentState,r=this._easing,i=this._originalState,u=this._targetState;if(this._isPlaying)return this._isPlaying=!1,m(this),t?(this._applyFilter("beforeTween"),d(1,e,i,u,1,0,r),this._applyFilter("afterTween"),this._applyFilter("afterTweenEnd"),this._resolve(e,n)):this._reject(e,n),this}},{key:"isPlaying",value:function(){return this._isPlaying}},{key:"setScheduleFunction",value:function(n){t.setScheduleFunction(n)}},{key:"dispose",value:function(){for(var t in this)delete this[t]}}])&&i(n.prototype,e),r&&i(n,r),t}();function w(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=new g,e=n.tween(t);return e.tweenable=n,e}g.setScheduleFunction=function(t){return f=t},g.formulas=p,g.filters={},g.now=Date.now||function(){return+new Date}}).call(this,e(2))},function(t,n,e){"use strict";e.r(n),e.d(n,"linear",function(){return r}),e.d(n,"easeInQuad",function(){return i}),e.d(n,"easeOutQuad",function(){return u}),e.d(n,"easeInOutQuad",function(){return o}),e.d(n,"easeInCubic",function(){return a}),e.d(n,"easeOutCubic",function(){return c}),e.d(n,"easeInOutCubic",function(){return f}),e.d(n,"easeInQuart",function(){return s}),e.d(n,"easeOutQuart",function(){return l}),e.d(n,"easeInOutQuart",function(){return h}),e.d(n,"easeInQuint",function(){return p}),e.d(n,"easeOutQuint",function(){return d}),e.d(n,"easeInOutQuint",function(){return v}),e.d(n,"easeInSine",function(){return y}),e.d(n,"easeOutSine",function(){return _}),e.d(n,"easeInOutSine",function(){return m}),e.d(n,"easeInExpo",function(){return g}),e.d(n,"easeOutExpo",function(){return w}),e.d(n,"easeInOutExpo",function(){return b}),e.d(n,"easeInCirc",function(){return S}),e.d(n,"easeOutCirc",function(){return O}),e.d(n,"easeInOutCirc",function(){return M}),e.d(n,"easeOutBounce",function(){return k}),e.d(n,"easeInBack",function(){return j}),e.d(n,"easeOutBack",function(){return P}),e.d(n,"easeInOutBack",function(){return x}),e.d(n,"elastic",function(){return T}),e.d(n,"swingFromTo",function(){return F}),e.d(n,"swingFrom",function(){return A}),e.d(n,"swingTo",function(){return E}),e.d(n,"bounce",function(){return I}),e.d(n,"bouncePast",function(){return C}),e.d(n,"easeFromTo",function(){return q}),e.d(n,"easeFrom",function(){return Q}),e.d(n,"easeTo",function(){return D});
  /*!
   * All equations are adapted from Thomas Fuchs'
   * [Scripty2](https://github.com/madrobby/scripty2/blob/master/src/effects/transitions/penner.js).
   *
   * Based on Easing Equations (c) 2003 [Robert
   * Penner](http://www.robertpenner.com/), all rights reserved. This work is
   * [subject to terms](http://www.robertpenner.com/easing_terms_of_use.html).
   */
  /*!
   *  TERMS OF USE - EASING EQUATIONS
   *  Open source under the BSD License.
   *  Easing Equations (c) 2003 Robert Penner, all rights reserved.
   */
  var r=function(t){return t},i=function(t){return Math.pow(t,2)},u=function(t){return-(Math.pow(t-1,2)-1)},o=function(t){return(t/=.5)<1?.5*Math.pow(t,2):-.5*((t-=2)*t-2)},a=function(t){return Math.pow(t,3)},c=function(t){return Math.pow(t-1,3)+1},f=function(t){return(t/=.5)<1?.5*Math.pow(t,3):.5*(Math.pow(t-2,3)+2)},s=function(t){return Math.pow(t,4)},l=function(t){return-(Math.pow(t-1,4)-1)},h=function(t){return(t/=.5)<1?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},p=function(t){return Math.pow(t,5)},d=function(t){return Math.pow(t-1,5)+1},v=function(t){return(t/=.5)<1?.5*Math.pow(t,5):.5*(Math.pow(t-2,5)+2)},y=function(t){return 1-Math.cos(t*(Math.PI/2))},_=function(t){return Math.sin(t*(Math.PI/2))},m=function(t){return-.5*(Math.cos(Math.PI*t)-1)},g=function(t){return 0===t?0:Math.pow(2,10*(t-1))},w=function(t){return 1===t?1:1-Math.pow(2,-10*t)},b=function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*--t))},S=function(t){return-(Math.sqrt(1-t*t)-1)},O=function(t){return Math.sqrt(1-Math.pow(t-1,2))},M=function(t){return(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},k=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},j=function(t){var n=1.70158;return t*t*((n+1)*t-n)},P=function(t){var n=1.70158;return(t-=1)*t*((n+1)*t+n)+1},x=function(t){var n=1.70158;return(t/=.5)<1?t*t*((1+(n*=1.525))*t-n)*.5:.5*((t-=2)*t*((1+(n*=1.525))*t+n)+2)},T=function(t){return-1*Math.pow(4,-8*t)*Math.sin((6*t-1)*(2*Math.PI)/2)+1},F=function(t){var n=1.70158;return(t/=.5)<1?t*t*((1+(n*=1.525))*t-n)*.5:.5*((t-=2)*t*((1+(n*=1.525))*t+n)+2)},A=function(t){var n=1.70158;return t*t*((n+1)*t-n)},E=function(t){var n=1.70158;return(t-=1)*t*((n+1)*t+n)+1},I=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},C=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?2-(7.5625*(t-=1.5/2.75)*t+.75):t<2.5/2.75?2-(7.5625*(t-=2.25/2.75)*t+.9375):2-(7.5625*(t-=2.625/2.75)*t+.984375)},q=function(t){return(t/=.5)<1?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},Q=function(t){return Math.pow(t,4)},D=function(t){return Math.pow(t,.25)}},function(t,n){var e;e=function(){return this}();try{e=e||new Function("return this")()}catch(t){"object"==typeof window&&(e=window)}t.exports=e},function(t,n,e){"use strict";e.r(n);var r={};e.r(r),e.d(r,"doesApply",function(){return x}),e.d(r,"tweenCreated",function(){return T}),e.d(r,"beforeTween",function(){return F}),e.d(r,"afterTween",function(){return A});var i,u,o=e(0),a=/(\d|-|\.)/,c=/([^\-0-9.]+)/g,f=/[0-9.-]+/g,s=(i=f.source,u=/,\s*/.source,new RegExp("rgb\\(".concat(i).concat(u).concat(i).concat(u).concat(i,"\\)"),"g")),l=/^.*\(/,h=/#([0-9]|[a-f]){3,6}/gi,p=function(t,n){return t.map(function(t,e){return"_".concat(n,"_").concat(e)})};function d(t){return parseInt(t,16)}var v=function(t){return"rgb(".concat((n=t,3===(n=n.replace(/#/,"")).length&&(n=(n=n.split(""))[0]+n[0]+n[1]+n[1]+n[2]+n[2]),[d(n.substr(0,2)),d(n.substr(2,2)),d(n.substr(4,2))]).join(","),")");var n},y=function(t,n,e){var r=n.match(t),i=n.replace(t,"VAL");return r&&r.forEach(function(t){return i=i.replace("VAL",e(t))}),i},_=function(t){for(var n in t){var e=t[n];"string"==typeof e&&e.match(h)&&(t[n]=y(h,e,v))}},m=function(t){var n=t.match(f).map(Math.floor),e=t.match(l)[0];return"".concat(e).concat(n.join(","),")")},g=function(t){return t.match(f)},w=function(t){var n,e,r={};for(var i in t){var u=t[i];"string"==typeof u&&(r[i]={formatString:(n=u,e=void 0,e=n.match(c),e?(1===e.length||n.charAt(0).match(a))&&e.unshift(""):e=["",""],e.join("VAL")),chunkNames:p(g(u),i)})}return r},b=function(t,n){var e=function(e){g(t[e]).forEach(function(r,i){return t[n[e].chunkNames[i]]=+r}),delete t[e]};for(var r in n)e(r)},S=function(t,n){var e={};return n.forEach(function(n){e[n]=t[n],delete t[n]}),e},O=function(t,n){return n.map(function(n){return t[n]})},M=function(t,n){return n.forEach(function(n){return t=t.replace("VAL",+n.toFixed(4))}),t},k=function(t,n){for(var e in n){var r=n[e],i=r.chunkNames,u=r.formatString,o=M(u,O(S(t,i),i));t[e]=y(s,o,m)}},j=function(t,n){var e=function(e){var r=n[e].chunkNames,i=t[e];if("string"==typeof i){var u=i.split(" "),o=u[u.length-1];r.forEach(function(n,e){return t[n]=u[e]||o})}else r.forEach(function(n){return t[n]=i});delete t[e]};for(var r in n)e(r)},P=function(t,n){for(var e in n){var r=n[e].chunkNames,i=t[r[0]];t[e]="string"==typeof i?r.map(function(n){var e=t[n];return delete t[n],e}).join(" "):i}},x=function(t){var n=t._currentState;return Object.keys(n).some(function(t){return"string"==typeof n[t]})};function T(t){var n=t._currentState;[n,t._originalState,t._targetState].forEach(_),t._tokenData=w(n)}function F(t){var n=t._currentState,e=t._originalState,r=t._targetState,i=t._easing,u=t._tokenData;j(i,u),[n,e,r].forEach(function(t){return b(t,u)})}function A(t){var n=t._currentState,e=t._originalState,r=t._targetState,i=t._easing,u=t._tokenData;[n,e,r].forEach(function(t){return k(t,u)}),P(i,u)}function E(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}var I=new o.a,C=o.a.filters,q=function(t,n,e,r){var i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,u=function(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{},r=Object.keys(e);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(e).filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.forEach(function(n){E(t,n,e[n])})}return t}({},t),a=Object(o.b)(t,r);for(var c in I._filters.length=0,I.set({}),I._currentState=u,I._originalState=t,I._targetState=n,I._easing=a,C)C[c].doesApply(I)&&I._filters.push(C[c]);I._applyFilter("tweenCreated"),I._applyFilter("beforeTween");var f=Object(o.e)(e,u,t,n,1,i,a);return I._applyFilter("afterTween"),f};function Q(t){return function(t){if(Array.isArray(t)){for(var n=0,e=new Array(t.length);n<t.length;n++)e[n]=t[n];return e}}(t)||function(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function D(t,n){for(var e=0;e<n.length;e++){var r=n[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function B(t,n){if(!n.has(t))throw new TypeError("attempted to get private field on non-instance");var e=n.get(t);return e.get?e.get.call(t):e.value}var N=function(){function t(){!function(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")}(this,t),R.set(this,{writable:!0,value:[]});for(var n=arguments.length,e=new Array(n),r=0;r<n;r++)e[r]=arguments[r];e.forEach(this.add.bind(this))}var n,e,r;return n=t,(e=[{key:"add",value:function(t){return B(this,R).push(t),t}},{key:"remove",value:function(t){var n=B(this,R).indexOf(t);return~n&&B(this,R).splice(n,1),t}},{key:"empty",value:function(){return this.tweenables.map(this.remove.bind(this))}},{key:"isPlaying",value:function(){return B(this,R).some(function(t){return t.isPlaying()})}},{key:"play",value:function(){return B(this,R).forEach(function(t){return t.tween()}),this}},{key:"pause",value:function(){return B(this,R).forEach(function(t){return t.pause()}),this}},{key:"resume",value:function(){return B(this,R).forEach(function(t){return t.resume()}),this}},{key:"stop",value:function(t){return B(this,R).forEach(function(n){return n.stop(t)}),this}},{key:"tweenables",get:function(){return Q(B(this,R))}},{key:"promises",get:function(){return B(this,R).map(function(t){return t._promise})}}])&&D(n.prototype,e),r&&D(n,r),t}(),R=new WeakMap;function z(t,n,e,r,i,u){var o=0,a=0,c=0,f=0,s=0,l=0,h=function(t){return((o*t+a)*t+c)*t},p=function(t){return t>=0?t:0-t};return o=1-(c=3*n)-(a=3*(r-n)-c),f=1-(l=3*e)-(s=3*(i-e)-l),function(t,n){return e=function(t,n){var e,r,i,u,f,s,l;for(i=t,s=0;s<8;s++){if(u=h(i)-t,p(u)<n)return i;if(p(f=(3*o*(l=i)+2*a)*l+c)<1e-6)break;i-=u/f}if((i=t)<(e=0))return e;if(i>(r=1))return r;for(;e<r;){if(u=h(i),p(u-t)<n)return i;t>u?e=i:r=i,i=.5*(r-e)+e}return i}(t,n),((f*e+s)*e+l)*e;var e}(t,function(t){return 1/(200*t)}(u))}var L=function(t,n,e,r,i){var u=function(t,n,e,r){return function(i){return z(i,t,n,e,r,1)}}(n,e,r,i);return u.displayName=t,u.x1=n,u.y1=e,u.x2=r,u.y2=i,o.a.formulas[t]=u},V=function(t){return delete o.a.formulas[t]};e.d(n,"processTweens",function(){return o.c}),e.d(n,"Tweenable",function(){return o.a}),e.d(n,"tween",function(){return o.d}),e.d(n,"interpolate",function(){return q}),e.d(n,"Scene",function(){return N}),e.d(n,"setBezierFunction",function(){return L}),e.d(n,"unsetBezierFunction",function(){return V}),o.a.filters.token=r}])});

  },{}],2:[function(require,module,exports){
  // Circle shaped progress bar

  var Shape = require('./shape');
  var utils = require('./utils');

  var Circle = function Circle(container, options) {
	  // Use two arcs to form a circle
	  // See this answer http://stackoverflow.com/a/10477334/1446092
	  this._pathTemplate =
		  'M 50,50 m 0,-{radius}' +
		  ' a {radius},{radius} 0 1 1 0,{2radius}' +
		  ' a {radius},{radius} 0 1 1 0,-{2radius}';

	  this.containerAspectRatio = 1;

	  Shape.apply(this, arguments);
  };

  Circle.prototype = new Shape();
  Circle.prototype.constructor = Circle;

  Circle.prototype._pathString = function _pathString(opts) {
	  var widthOfWider = opts.strokeWidth;
	  if (opts.trailWidth && opts.trailWidth > opts.strokeWidth) {
		  widthOfWider = opts.trailWidth;
	  }

	  var r = 50 - widthOfWider / 2;

	  return utils.render(this._pathTemplate, {
		  radius: r,
		  '2radius': r * 2
	  });
  };

  Circle.prototype._trailString = function _trailString(opts) {
	  return this._pathString(opts);
  };

  module.exports = Circle;

  },{"./shape":7,"./utils":9}],3:[function(require,module,exports){
  // Line shaped progress bar

  var Shape = require('./shape');
  var utils = require('./utils');

  var Line = function Line(container, options) {
	  this._pathTemplate = 'M 0,{center} L 100,{center}';
	  Shape.apply(this, arguments);
  };

  Line.prototype = new Shape();
  Line.prototype.constructor = Line;

  Line.prototype._initializeSvg = function _initializeSvg(svg, opts) {
	  svg.setAttribute('viewBox', '0 0 100 ' + opts.strokeWidth);
	  svg.setAttribute('preserveAspectRatio', 'none');
  };

  Line.prototype._pathString = function _pathString(opts) {
	  return utils.render(this._pathTemplate, {
		  center: opts.strokeWidth / 2
	  });
  };

  Line.prototype._trailString = function _trailString(opts) {
	  return this._pathString(opts);
  };

  module.exports = Line;

  },{"./shape":7,"./utils":9}],4:[function(require,module,exports){
  module.exports = {
	  // Higher level API, different shaped progress bars
	  Line: require('./line'),
	  Circle: require('./circle'),
	  SemiCircle: require('./semicircle'),
	  Square: require('./square'),

	  // Lower level API to use any SVG path
	  Path: require('./path'),

	  // Base-class for creating new custom shapes
	  // to be in line with the API of built-in shapes
	  // Undocumented.
	  Shape: require('./shape'),

	  // Internal utils, undocumented.
	  utils: require('./utils')
  };

  },{"./circle":2,"./line":3,"./path":5,"./semicircle":6,"./shape":7,"./square":8,"./utils":9}],5:[function(require,module,exports){
  // Lower level API to animate any kind of svg path

  var shifty = require('shifty');
  var utils = require('./utils');

  var Tweenable = shifty.Tweenable;

  var EASING_ALIASES = {
	  easeIn: 'easeInCubic',
	  easeOut: 'easeOutCubic',
	  easeInOut: 'easeInOutCubic'
  };

  var Path = function Path(path, opts) {
	  // Throw a better error if not initialized with `new` keyword
	  if (!(this instanceof Path)) {
		  throw new Error('Constructor was called without new keyword');
	  }

	  // Default parameters for animation
	  opts = utils.extend({
		  delay: 0,
		  duration: 800,
		  easing: 'linear',
		  from: {},
		  to: {},
		  step: function() {}
	  }, opts);

	  var element;
	  if (utils.isString(path)) {
		  element = document.querySelector(path);
	  } else {
		  element = path;
	  }

	  // Reveal .path as public attribute
	  this.path = element;
	  this._opts = opts;
	  this._tweenable = null;

	  // Set up the starting positions
	  var length = this.path.getTotalLength();
	  this.path.style.strokeDasharray = length + ' ' + length;
	  this.set(0);
  };

  Path.prototype.value = function value() {
	  var offset = this._getComputedDashOffset();
	  var length = this.path.getTotalLength();

	  var progress = 1 - offset / length;
	  // Round number to prevent returning very small number like 1e-30, which
	  // is practically 0
	  return parseFloat(progress.toFixed(6), 10);
  };

  Path.prototype.set = function set(progress) {
	  this.stop();

	  this.path.style.strokeDashoffset = this._progressToOffset(progress);

	  var step = this._opts.step;
	  if (utils.isFunction(step)) {
		  var easing = this._easing(this._opts.easing);
		  var values = this._calculateTo(progress, easing);
		  var reference = this._opts.shape || this;
		  step(values, reference, this._opts.attachment);
	  }
  };

  Path.prototype.stop = function stop() {
	  this._stopTween();
	  this.path.style.strokeDashoffset = this._getComputedDashOffset();
  };

  // Method introduced here:
  // http://jakearchibald.com/2013/animated-line-drawing-svg/
  Path.prototype.animate = function animate(progress, opts, cb) {
	  opts = opts || {};

	  if (utils.isFunction(opts)) {
		  cb = opts;
		  opts = {};
	  }

	  var passedOpts = utils.extend({}, opts);

	  // Copy default opts to new object so defaults are not modified
	  var defaultOpts = utils.extend({}, this._opts);
	  opts = utils.extend(defaultOpts, opts);

	  var shiftyEasing = this._easing(opts.easing);
	  var values = this._resolveFromAndTo(progress, shiftyEasing, passedOpts);

	  this.stop();

	  // Trigger a layout so styles are calculated & the browser
	  // picks up the starting position before animating
	  this.path.getBoundingClientRect();

	  var offset = this._getComputedDashOffset();
	  var newOffset = this._progressToOffset(progress);

	  var self = this;
	  this._tweenable = new Tweenable();
	  this._tweenable.tween({
		  from: utils.extend({ offset: offset }, values.from),
		  to: utils.extend({ offset: newOffset }, values.to),
		  duration: opts.duration,
		  delay: opts.delay,
		  easing: shiftyEasing,
		  step: function(state) {
			  self.path.style.strokeDashoffset = state.offset;
			  var reference = opts.shape || self;
			  opts.step(state, reference, opts.attachment);
		  }
	  }).then(function(state) {
		  if (utils.isFunction(cb)) {
			  cb();
		  }
	  });
  };

  Path.prototype._getComputedDashOffset = function _getComputedDashOffset() {
	  var computedStyle = window.getComputedStyle(this.path, null);
	  return parseFloat(computedStyle.getPropertyValue('stroke-dashoffset'), 10);
  };

  Path.prototype._progressToOffset = function _progressToOffset(progress) {
	  var length = this.path.getTotalLength();
	  return length - progress * length;
  };

  // Resolves from and to values for animation.
  Path.prototype._resolveFromAndTo = function _resolveFromAndTo(progress, easing, opts) {
	  if (opts.from && opts.to) {
		  return {
			  from: opts.from,
			  to: opts.to
		  };
	  }

	  return {
		  from: this._calculateFrom(easing),
		  to: this._calculateTo(progress, easing)
	  };
  };

  // Calculate `from` values from options passed at initialization
  Path.prototype._calculateFrom = function _calculateFrom(easing) {
	  return shifty.interpolate(this._opts.from, this._opts.to, this.value(), easing);
  };

  // Calculate `to` values from options passed at initialization
  Path.prototype._calculateTo = function _calculateTo(progress, easing) {
	  return shifty.interpolate(this._opts.from, this._opts.to, progress, easing);
  };

  Path.prototype._stopTween = function _stopTween() {
	  if (this._tweenable !== null) {
		  this._tweenable.stop();
		  this._tweenable = null;
	  }
  };

  Path.prototype._easing = function _easing(easing) {
	  if (EASING_ALIASES.hasOwnProperty(easing)) {
		  return EASING_ALIASES[easing];
	  }

	  return easing;
  };

  module.exports = Path;

  },{"./utils":9,"shifty":1}],6:[function(require,module,exports){
  // Semi-SemiCircle shaped progress bar

  var Shape = require('./shape');
  var Circle = require('./circle');
  var utils = require('./utils');

  var SemiCircle = function SemiCircle(container, options) {
	  // Use one arc to form a SemiCircle
	  // See this answer http://stackoverflow.com/a/10477334/1446092
	  this._pathTemplate =
		  'M 50,50 m -{radius},0' +
		  ' a {radius},{radius} 0 1 1 {2radius},0';

	  this.containerAspectRatio = 2;

	  Shape.apply(this, arguments);
  };

  SemiCircle.prototype = new Shape();
  SemiCircle.prototype.constructor = SemiCircle;

  SemiCircle.prototype._initializeSvg = function _initializeSvg(svg, opts) {
	  svg.setAttribute('viewBox', '0 0 100 50');
  };

  SemiCircle.prototype._initializeTextContainer = function _initializeTextContainer(
	  opts,
	  container,
	  textContainer
  ) {
	  if (opts.text.style) {
		  // Reset top style
		  textContainer.style.top = 'auto';
		  textContainer.style.bottom = '0';

		  if (opts.text.alignToBottom) {
			  utils.setStyle(textContainer, 'transform', 'translate(-50%, 0)');
		  } else {
			  utils.setStyle(textContainer, 'transform', 'translate(-50%, 50%)');
		  }
	  }
  };

  // Share functionality with Circle, just have different path
  SemiCircle.prototype._pathString = Circle.prototype._pathString;
  SemiCircle.prototype._trailString = Circle.prototype._trailString;

  module.exports = SemiCircle;

  },{"./circle":2,"./shape":7,"./utils":9}],7:[function(require,module,exports){
  // Base object for different progress bar shapes

  var Path = require('./path');
  var utils = require('./utils');

  var DESTROYED_ERROR = 'Object is destroyed';

  var Shape = function Shape(container, opts) {
	  // Throw a better error if progress bars are not initialized with `new`
	  // keyword
	  if (!(this instanceof Shape)) {
		  throw new Error('Constructor was called without new keyword');
	  }

	  // Prevent calling constructor without parameters so inheritance
	  // works correctly. To understand, this is how Shape is inherited:
	  //
	  //   Line.prototype = new Shape();
	  //
	  // We just want to set the prototype for Line.
	  if (arguments.length === 0) {
		  return;
	  }

	  // Default parameters for progress bar creation
	  this._opts = utils.extend({
		  color: '#555',
		  strokeWidth: 1.0,
		  trailColor: null,
		  trailWidth: null,
		  fill: null,
		  text: {
			  style: {
				  color: null,
				  position: 'absolute',
				  left: '50%',
				  top: '50%',
				  padding: 0,
				  margin: 0,
				  transform: {
					  prefix: true,
					  value: 'translate(-50%, -50%)'
				  }
			  },
			  autoStyleContainer: true,
			  alignToBottom: true,
			  value: null,
			  className: 'progressbar-text'
		  },
		  svgStyle: {
			  display: 'block',
			  width: '100%'
		  },
		  warnings: false
	  }, opts, true);  // Use recursive extend

	  // If user specifies e.g. svgStyle or text style, the whole object
	  // should replace the defaults to make working with styles easier
	  if (utils.isObject(opts) && opts.svgStyle !== undefined) {
		  this._opts.svgStyle = opts.svgStyle;
	  }
	  if (utils.isObject(opts) && utils.isObject(opts.text) && opts.text.style !== undefined) {
		  this._opts.text.style = opts.text.style;
	  }

	  var svgView = this._createSvgView(this._opts);

	  var element;
	  if (utils.isString(container)) {
		  element = document.querySelector(container);
	  } else {
		  element = container;
	  }

	  if (!element) {
		  throw new Error('Container does not exist: ' + container);
	  }

	  this._container = element;
	  this._container.appendChild(svgView.svg);
	  if (this._opts.warnings) {
		  this._warnContainerAspectRatio(this._container);
	  }

	  if (this._opts.svgStyle) {
		  utils.setStyles(svgView.svg, this._opts.svgStyle);
	  }

	  // Expose public attributes before Path initialization
	  this.svg = svgView.svg;
	  this.path = svgView.path;
	  this.trail = svgView.trail;
	  this.text = null;

	  var newOpts = utils.extend({
		  attachment: undefined,
		  shape: this
	  }, this._opts);
	  this._progressPath = new Path(svgView.path, newOpts);

	  if (utils.isObject(this._opts.text) && this._opts.text.value !== null) {
		  this.setText(this._opts.text.value);
	  }
  };

  Shape.prototype.animate = function animate(progress, opts, cb) {
	  if (this._progressPath === null) {
		  throw new Error(DESTROYED_ERROR);
	  }

	  this._progressPath.animate(progress, opts, cb);
  };

  Shape.prototype.stop = function stop() {
	  if (this._progressPath === null) {
		  throw new Error(DESTROYED_ERROR);
	  }

	  // Don't crash if stop is called inside step function
	  if (this._progressPath === undefined) {
		  return;
	  }

	  this._progressPath.stop();
  };

  Shape.prototype.pause = function pause() {
	  if (this._progressPath === null) {
		  throw new Error(DESTROYED_ERROR);
	  }

	  if (this._progressPath === undefined) {
		  return;
	  }

	  if (!this._progressPath._tweenable) {
		  // It seems that we can't pause this
		  return;
	  }

	  this._progressPath._tweenable.pause();
  };

  Shape.prototype.resume = function resume() {
	  if (this._progressPath === null) {
		  throw new Error(DESTROYED_ERROR);
	  }

	  if (this._progressPath === undefined) {
		  return;
	  }

	  if (!this._progressPath._tweenable) {
		  // It seems that we can't resume this
		  return;
	  }

	  this._progressPath._tweenable.resume();
  };

  Shape.prototype.destroy = function destroy() {
	  if (this._progressPath === null) {
		  throw new Error(DESTROYED_ERROR);
	  }

	  this.stop();
	  this.svg.parentNode.removeChild(this.svg);
	  this.svg = null;
	  this.path = null;
	  this.trail = null;
	  this._progressPath = null;

	  if (this.text !== null) {
		  this.text.parentNode.removeChild(this.text);
		  this.text = null;
	  }
  };

  Shape.prototype.set = function set(progress) {
	  if (this._progressPath === null) {
		  throw new Error(DESTROYED_ERROR);
	  }

	  this._progressPath.set(progress);
  };

  Shape.prototype.value = function value() {
	  if (this._progressPath === null) {
		  throw new Error(DESTROYED_ERROR);
	  }

	  if (this._progressPath === undefined) {
		  return 0;
	  }

	  return this._progressPath.value();
  };

  Shape.prototype.setText = function setText(newText) {
	  if (this._progressPath === null) {
		  throw new Error(DESTROYED_ERROR);
	  }

	  if (this.text === null) {
		  // Create new text node
		  this.text = this._createTextContainer(this._opts, this._container);
		  this._container.appendChild(this.text);
	  }

	  // Remove previous text and add new
	  if (utils.isObject(newText)) {
		  utils.removeChildren(this.text);
		  this.text.appendChild(newText);
	  } else {
		  this.text.innerHTML = newText;
	  }
  };

  Shape.prototype._createSvgView = function _createSvgView(opts) {
	  var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
	  this._initializeSvg(svg, opts);

	  var trailPath = null;
	  // Each option listed in the if condition are 'triggers' for creating
	  // the trail path
	  if (opts.trailColor || opts.trailWidth) {
		  trailPath = this._createTrail(opts);
		  svg.appendChild(trailPath);
	  }

	  var path = this._createPath(opts);
	  svg.appendChild(path);

	  return {
		  svg: svg,
		  path: path,
		  trail: trailPath
	  };
  };

  Shape.prototype._initializeSvg = function _initializeSvg(svg, opts) {
	  svg.setAttribute('viewBox', '0 0 100 100');
  };

  Shape.prototype._createPath = function _createPath(opts) {
	  var pathString = this._pathString(opts);
	  return this._createPathElement(pathString, opts);
  };

  Shape.prototype._createTrail = function _createTrail(opts) {
	  // Create path string with original passed options
	  var pathString = this._trailString(opts);

	  // Prevent modifying original
	  var newOpts = utils.extend({}, opts);

	  // Defaults for parameters which modify trail path
	  if (!newOpts.trailColor) {
		  newOpts.trailColor = '#eee';
	  }
	  if (!newOpts.trailWidth) {
		  newOpts.trailWidth = newOpts.strokeWidth;
	  }

	  newOpts.color = newOpts.trailColor;
	  newOpts.strokeWidth = newOpts.trailWidth;

	  // When trail path is set, fill must be set for it instead of the
	  // actual path to prevent trail stroke from clipping
	  newOpts.fill = null;

	  return this._createPathElement(pathString, newOpts);
  };

  Shape.prototype._createPathElement = function _createPathElement(pathString, opts) {
	  var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
	  path.setAttribute('d', pathString);
	  path.setAttribute('stroke', opts.color);
	  path.setAttribute('stroke-width', opts.strokeWidth);

	  if (opts.fill) {
		  path.setAttribute('fill', opts.fill);
	  } else {
		  path.setAttribute('fill-opacity', '0');
	  }

	  return path;
  };

  Shape.prototype._createTextContainer = function _createTextContainer(opts, container) {
	  var textContainer = document.createElement('div');
	  textContainer.className = opts.text.className;

	  var textStyle = opts.text.style;
	  if (textStyle) {
		  if (opts.text.autoStyleContainer) {
			  container.style.position = 'relative';
		  }

		  utils.setStyles(textContainer, textStyle);
		  // Default text color to progress bar's color
		  if (!textStyle.color) {
			  textContainer.style.color = opts.color;
		  }
	  }

	  this._initializeTextContainer(opts, container, textContainer);
	  return textContainer;
  };

  // Give custom shapes possibility to modify text element
  Shape.prototype._initializeTextContainer = function(opts, container, element) {
	  // By default, no-op
	  // Custom shapes should respect API options, such as text.style
  };

  Shape.prototype._pathString = function _pathString(opts) {
	  throw new Error('Override this function for each progress bar');
  };

  Shape.prototype._trailString = function _trailString(opts) {
	  throw new Error('Override this function for each progress bar');
  };

  Shape.prototype._warnContainerAspectRatio = function _warnContainerAspectRatio(container) {
	  if (!this.containerAspectRatio) {
		  return;
	  }

	  var computedStyle = window.getComputedStyle(container, null);
	  var width = parseFloat(computedStyle.getPropertyValue('width'), 10);
	  var height = parseFloat(computedStyle.getPropertyValue('height'), 10);
	  if (!utils.floatEquals(this.containerAspectRatio, width / height)) {
		  console.warn(
			  'Incorrect aspect ratio of container',
			  '#' + container.id,
			  'detected:',
			  computedStyle.getPropertyValue('width') + '(width)',
			  '/',
			  computedStyle.getPropertyValue('height') + '(height)',
			  '=',
			  width / height
		  );

		  console.warn(
			  'Aspect ratio of should be',
			  this.containerAspectRatio
		  );
	  }
  };

  module.exports = Shape;

  },{"./path":5,"./utils":9}],8:[function(require,module,exports){
  // Square shaped progress bar
  // Note: Square is not core part of API anymore. It's left here
  //       for reference. square is not included to the progressbar
  //       build anymore

  var Shape = require('./shape');
  var utils = require('./utils');

  var Square = function Square(container, options) {
	  this._pathTemplate =
		  'M 0,{halfOfStrokeWidth}' +
		  ' L {width},{halfOfStrokeWidth}' +
		  ' L {width},{width}' +
		  ' L {halfOfStrokeWidth},{width}' +
		  ' L {halfOfStrokeWidth},{strokeWidth}';

	  this._trailTemplate =
		  'M {startMargin},{halfOfStrokeWidth}' +
		  ' L {width},{halfOfStrokeWidth}' +
		  ' L {width},{width}' +
		  ' L {halfOfStrokeWidth},{width}' +
		  ' L {halfOfStrokeWidth},{halfOfStrokeWidth}';

	  Shape.apply(this, arguments);
  };

  Square.prototype = new Shape();
  Square.prototype.constructor = Square;

  Square.prototype._pathString = function _pathString(opts) {
	  var w = 100 - opts.strokeWidth / 2;

	  return utils.render(this._pathTemplate, {
		  width: w,
		  strokeWidth: opts.strokeWidth,
		  halfOfStrokeWidth: opts.strokeWidth / 2
	  });
  };

  Square.prototype._trailString = function _trailString(opts) {
	  var w = 100 - opts.strokeWidth / 2;

	  return utils.render(this._trailTemplate, {
		  width: w,
		  strokeWidth: opts.strokeWidth,
		  halfOfStrokeWidth: opts.strokeWidth / 2,
		  startMargin: opts.strokeWidth / 2 - opts.trailWidth / 2
	  });
  };

  module.exports = Square;

  },{"./shape":7,"./utils":9}],9:[function(require,module,exports){
  // Utility functions

  var PREFIXES = 'Webkit Moz O ms'.split(' ');
  var FLOAT_COMPARISON_EPSILON = 0.001;

  // Copy all attributes from source object to destination object.
  // destination object is mutated.
  function extend(destination, source, recursive) {
	  destination = destination || {};
	  source = source || {};
	  recursive = recursive || false;

	  for (var attrName in source) {
		  if (source.hasOwnProperty(attrName)) {
			  var destVal = destination[attrName];
			  var sourceVal = source[attrName];
			  if (recursive && isObject(destVal) && isObject(sourceVal)) {
				  destination[attrName] = extend(destVal, sourceVal, recursive);
			  } else {
				  destination[attrName] = sourceVal;
			  }
		  }
	  }

	  return destination;
  }

  // Renders templates with given variables. Variables must be surrounded with
  // braces without any spaces, e.g. {variable}
  // All instances of variable placeholders will be replaced with given content
  // Example:
  // render('Hello, {message}!', {message: 'world'})
  function render(template, vars) {
	  var rendered = template;

	  for (var key in vars) {
		  if (vars.hasOwnProperty(key)) {
			  var val = vars[key];
			  var regExpString = '\\{' + key + '\\}';
			  var regExp = new RegExp(regExpString, 'g');

			  rendered = rendered.replace(regExp, val);
		  }
	  }

	  return rendered;
  }

  function setStyle(element, style, value) {
	  var elStyle = element.style;  // cache for performance

	  for (var i = 0; i < PREFIXES.length; ++i) {
		  var prefix = PREFIXES[i];
		  elStyle[prefix + capitalize(style)] = value;
	  }

	  elStyle[style] = value;
  }

  function setStyles(element, styles) {
	  forEachObject(styles, function(styleValue, styleName) {
		  // Allow disabling some individual styles by setting them
		  // to null or undefined
		  if (styleValue === null || styleValue === undefined) {
			  return;
		  }

		  // If style's value is {prefix: true, value: '50%'},
		  // Set also browser prefixed styles
		  if (isObject(styleValue) && styleValue.prefix === true) {
			  setStyle(element, styleName, styleValue.value);
		  } else {
			  element.style[styleName] = styleValue;
		  }
	  });
  }

  function capitalize(text) {
	  return text.charAt(0).toUpperCase() + text.slice(1);
  }

  function isString(obj) {
	  return typeof obj === 'string' || obj instanceof String;
  }

  function isFunction(obj) {
	  return typeof obj === 'function';
  }

  function isArray(obj) {
	  return Object.prototype.toString.call(obj) === '[object Array]';
  }

  // Returns true if `obj` is object as in {a: 1, b: 2}, not if it's function or
  // array
  function isObject(obj) {
	  if (isArray(obj)) {
		  return false;
	  }

	  var type = typeof obj;
	  return type === 'object' && !!obj;
  }

  function forEachObject(object, callback) {
	  for (var key in object) {
		  if (object.hasOwnProperty(key)) {
			  var val = object[key];
			  callback(val, key);
		  }
	  }
  }

  function floatEquals(a, b) {
	  return Math.abs(a - b) < FLOAT_COMPARISON_EPSILON;
  }

  // https://coderwall.com/p/nygghw/don-t-use-innerhtml-to-empty-dom-elements
  function removeChildren(el) {
	  while (el.firstChild) {
		  el.removeChild(el.firstChild);
	  }
  }

  module.exports = {
	  extend: extend,
	  render: render,
	  setStyle: setStyle,
	  setStyles: setStyles,
	  capitalize: capitalize,
	  isString: isString,
	  isFunction: isFunction,
	  isObject: isObject,
	  forEachObject: forEachObject,
	  floatEquals: floatEquals,
	  removeChildren: removeChildren
  };

  },{}]},{},[4])(4)
  });

  (function (global, factory) {
	  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (global = global || self, factory(global.countUp = {}));
  }(this, (function (exports) { 'use strict';

	  var __assign = (undefined && undefined.__assign) || function () {
		  __assign = Object.assign || function(t) {
			  for (var s, i = 1, n = arguments.length; i < n; i++) {
				  s = arguments[i];
				  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
					  t[p] = s[p];
			  }
			  return t;
		  };
		  return __assign.apply(this, arguments);
	  };
	  // playground: stackblitz.com/edit/countup-typescript
	  var CountUp = /** @class */ (function () {
		  function CountUp(target, endVal, options) {
			  var _this = this;
			  this.target = target;
			  this.endVal = endVal;
			  this.options = options;
			  this.version = '2.0.7';
			  this.defaults = {
				  startVal: 0,
				  decimalPlaces: 0,
				  duration: 2,
				  useEasing: true,
				  useGrouping: true,
				  smartEasingThreshold: 999,
				  smartEasingAmount: 333,
				  separator: ',',
				  decimal: '.',
				  prefix: '',
				  suffix: ''
			  };
			  this.finalEndVal = null; // for smart easing
			  this.useEasing = true;
			  this.countDown = false;
			  this.error = '';
			  this.startVal = 0;
			  this.paused = true;
			  this.count = function (timestamp) {
				  if (!_this.startTime) {
					  _this.startTime = timestamp;
				  }
				  var progress = timestamp - _this.startTime;
				  _this.remaining = _this.duration - progress;
				  // to ease or not to ease
				  if (_this.useEasing) {
					  if (_this.countDown) {
						  _this.frameVal = _this.startVal - _this.easingFn(progress, 0, _this.startVal - _this.endVal, _this.duration);
					  }
					  else {
						  _this.frameVal = _this.easingFn(progress, _this.startVal, _this.endVal - _this.startVal, _this.duration);
					  }
				  }
				  else {
					  if (_this.countDown) {
						  _this.frameVal = _this.startVal - ((_this.startVal - _this.endVal) * (progress / _this.duration));
					  }
					  else {
						  _this.frameVal = _this.startVal + (_this.endVal - _this.startVal) * (progress / _this.duration);
					  }
				  }
				  // don't go past endVal since progress can exceed duration in the last frame
				  if (_this.countDown) {
					  _this.frameVal = (_this.frameVal < _this.endVal) ? _this.endVal : _this.frameVal;
				  }
				  else {
					  _this.frameVal = (_this.frameVal > _this.endVal) ? _this.endVal : _this.frameVal;
				  }
				  // decimal
				  _this.frameVal = Number(_this.frameVal.toFixed(_this.options.decimalPlaces));
				  // format and print value
				  _this.printValue(_this.frameVal);
				  // whether to continue
				  if (progress < _this.duration) {
					  _this.rAF = requestAnimationFrame(_this.count);
				  }
				  else if (_this.finalEndVal !== null) {
					  // smart easing
					  _this.update(_this.finalEndVal);
				  }
				  else {
					  if (_this.callback) {
						  _this.callback();
					  }
				  }
			  };
			  // default format and easing functions
			  this.formatNumber = function (num) {
				  var neg = (num < 0) ? '-' : '';
				  var result, x, x1, x2, x3;
				  result = Math.abs(num).toFixed(_this.options.decimalPlaces);
				  result += '';
				  x = result.split('.');
				  x1 = x[0];
				  x2 = x.length > 1 ? _this.options.decimal + x[1] : '';
				  if (_this.options.useGrouping) {
					  x3 = '';
					  for (var i = 0, len = x1.length; i < len; ++i) {
						  if (i !== 0 && (i % 3) === 0) {
							  x3 = _this.options.separator + x3;
						  }
						  x3 = x1[len - i - 1] + x3;
					  }
					  x1 = x3;
				  }
				  // optional numeral substitution
				  if (_this.options.numerals && _this.options.numerals.length) {
					  x1 = x1.replace(/[0-9]/g, function (w) { return _this.options.numerals[+w]; });
					  x2 = x2.replace(/[0-9]/g, function (w) { return _this.options.numerals[+w]; });
				  }
				  return neg + _this.options.prefix + x1 + x2 + _this.options.suffix;
			  };
			  this.easeOutExpo = function (t, b, c, d) {
				  return c * (-Math.pow(2, -10 * t / d) + 1) * 1024 / 1023 + b;
			  };
			  this.options = __assign(__assign({}, this.defaults), options);
			  this.formattingFn = (this.options.formattingFn) ?
				  this.options.formattingFn : this.formatNumber;
			  this.easingFn = (this.options.easingFn) ?
				  this.options.easingFn : this.easeOutExpo;
			  this.startVal = this.validateValue(this.options.startVal);
			  this.frameVal = this.startVal;
			  this.endVal = this.validateValue(endVal);
			  this.options.decimalPlaces = Math.max( this.options.decimalPlaces);
			  this.resetDuration();
			  this.options.separator = String(this.options.separator);
			  this.useEasing = this.options.useEasing;
			  if (this.options.separator === '') {
				  this.options.useGrouping = false;
			  }
			  this.el = (typeof target === 'string') ? document.getElementById(target) : target;
			  if (this.el) {
				  this.printValue(this.startVal);
			  }
			  else {
				  this.error = '[CountUp] target is null or undefined';
			  }
		  }
		  // determines where easing starts and whether to count down or up
		  CountUp.prototype.determineDirectionAndSmartEasing = function () {
			  var end = (this.finalEndVal) ? this.finalEndVal : this.endVal;
			  this.countDown = (this.startVal > end);
			  var animateAmount = end - this.startVal;
			  if (Math.abs(animateAmount) > this.options.smartEasingThreshold) {
				  this.finalEndVal = end;
				  var up = (this.countDown) ? 1 : -1;
				  this.endVal = end + (up * this.options.smartEasingAmount);
				  this.duration = this.duration / 2;
			  }
			  else {
				  this.endVal = end;
				  this.finalEndVal = null;
			  }
			  if (this.finalEndVal) {
				  this.useEasing = false;
			  }
			  else {
				  this.useEasing = this.options.useEasing;
			  }
		  };
		  // start animation
		  CountUp.prototype.start = function (callback) {
			  if (this.error) {
				  return;
			  }
			  this.callback = callback;
			  if (this.duration > 0) {
				  this.determineDirectionAndSmartEasing();
				  this.paused = false;
				  this.rAF = requestAnimationFrame(this.count);
			  }
			  else {
				  this.printValue(this.endVal);
			  }
		  };
		  // pause/resume animation
		  CountUp.prototype.pauseResume = function () {
			  if (!this.paused) {
				  cancelAnimationFrame(this.rAF);
			  }
			  else {
				  this.startTime = null;
				  this.duration = this.remaining;
				  this.startVal = this.frameVal;
				  this.determineDirectionAndSmartEasing();
				  this.rAF = requestAnimationFrame(this.count);
			  }
			  this.paused = !this.paused;
		  };
		  // reset to startVal so animation can be run again
		  CountUp.prototype.reset = function () {
			  cancelAnimationFrame(this.rAF);
			  this.paused = true;
			  this.resetDuration();
			  this.startVal = this.validateValue(this.options.startVal);
			  this.frameVal = this.startVal;
			  this.printValue(this.startVal);
		  };
		  // pass a new endVal and start animation
		  CountUp.prototype.update = function (newEndVal) {
			  cancelAnimationFrame(this.rAF);
			  this.startTime = null;
			  this.endVal = this.validateValue(newEndVal);
			  if (this.endVal === this.frameVal) {
				  return;
			  }
			  this.startVal = this.frameVal;
			  if (!this.finalEndVal) {
				  this.resetDuration();
			  }
			  this.finalEndVal = null;
			  this.determineDirectionAndSmartEasing();
			  this.rAF = requestAnimationFrame(this.count);
		  };
		  CountUp.prototype.printValue = function (val) {
			  var result = this.formattingFn(val);
			  if (this.el.tagName === 'INPUT') {
				  var input = this.el;
				  input.value = result;
			  }
			  else if (this.el.tagName === 'text' || this.el.tagName === 'tspan') {
				  this.el.textContent = result;
			  }
			  else {
				  this.el.innerHTML = result;
			  }
		  };
		  CountUp.prototype.ensureNumber = function (n) {
			  return (typeof n === 'number' && !isNaN(n));
		  };
		  CountUp.prototype.validateValue = function (value) {
			  var newValue = Number(value);
			  if (!this.ensureNumber(newValue)) {
				  this.error = "[CountUp] invalid start or end value: " + value;
				  return null;
			  }
			  else {
				  return newValue;
			  }
		  };
		  CountUp.prototype.resetDuration = function () {
			  this.startTime = null;
			  this.duration = Number(this.options.duration) * 1000;
			  this.remaining = this.duration;
		  };
		  return CountUp;
	  }());

	  exports.CountUp = CountUp;

	  Object.defineProperty(exports, '__esModule', { value: true });

  })));

  /* ---------------------------------------------------------------------------------------------------------------------
  NAVBAR JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(function ($) {
	  var $navBarDropDown = $('#navbarNavDropdown'),
		  $mobileToggler = $('.mobile-toggler');

	  if ($navBarDropDown.length !== 1) return;
	  $navBarDropDown.on("hide.bs.collapse", function () {
		  $mobileToggler.css('visibility', 'hidden');
	  });
	  $navBarDropDown.on("show.bs.collapse", function () {
		  $mobileToggler.css('visibility', 'visible');
	  });
  });
  /* ---------------------------------------------------------------------------------------------------------------------
  PROMO BANNER JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(function ($) {
	  var $promoBanner = $('#promoBanner');
	  if ($promoBanner.length === 0) return;

	  if (getCookie('promo_banner') !== 'hidden') {
		  $promoBanner.show();
		  var $closeBtn = $promoBanner.find('.close');
		  $closeBtn.on('click', function () {
			  setCookie('promo_banner', 'hidden', 365);
			  $promoBanner.hide();
		  });
	  }
  });
  /* ---------------------------------------------------------------------------------------------------------------------
  SLICK SLIDERS JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(function ($) {

	  var $heroSlider = $('#hero-slider'),
		  $heroSliderIndicators = $('#hero-slider-indicators'),
		  $heroSliderArrows = $('#hero-slider-arrows'),

		  $productSlider = $('.product-slider'),

		  $charitySlider = $('#charity-slider'),

		  $topWinnersSlider = $('#top-winners-slider'),
		  $winnersSlider = $('.winners-slider'),
		  $winnersSliderTabs = $('.winner-slider-tabs'),

		  $competitionSlider = $('#competition-carousel'),
		  $competitionNav = $('#competition-carousel-nav'),
		  $competitionArrows = $('#competition-arrows'),
		  $competitionIndicators = $('#competition-indicators');

	  // Hero Slider
	  $heroSlider.slick({
		  lazyLoad: 'ondemand',
		  slidesToShow: 1,
		  slidesToScroll: 1,
		  dots: true,
		  rows: 0,
		  fade: true,
		  autoplaySpeed: 5000,
		  appendDots: $heroSliderIndicators,
		  appendArrows: $heroSliderArrows,
		  prevArrow: '<button type="button" class="slick-prev"><svg><use xlink:href="#slider-white-arrow"></use></svg></button>',
		  nextArrow: '<button type="button" class="slick-next"><svg><use xlink:href="#slider-white-arrow"></use></svg></button>',
	  });


	  // Product Sliders
	  $productSlider.each(function () {
		  var $this = $(this),
			  columns = $this.data('columns') ? $this.data('columns') : 3;
		  $this.slick({
			  lazyLoad: 'ondemand',
			  slidesToShow: 3,
			  autoplay: true,
			  autoplaySpeed: 2000,
			  slidesToScroll: 3,
			  dots: true,
			  infinite: true,
			  prevArrow: false,
			  nextArrow: false,
			  adapativeHeight: true,
			  variableWidth: false,
			  rows: 0,
			  mobileFirst: true,
			  responsive: [
				{
					breakpoint: 200,
					settings: {
						slidesToShow: 1,
						slidesToScroll: 1,
						dots: true,
					}
				},				  {
					breakpoint: 820,
					settings: {
						slidesToShow: 2,
						slidesToScroll: 1,
						dots: true,
					}
				},
				{
					breakpoint: 1200,
					settings: {
						slidesToShow: columns,
						slidesToScroll: 1,
						dots: true,
					}
				},
			  ]
		  });
	  });

	  // Charity Page Slider
	  $charitySlider.slick({
		  lazyLoad: 'ondemand',
		  slidesToShow: 2,
		  autoplay: true,
		  autoplaySpeed: 8000,
		  slidesToScroll: 1,
		  dots: true,
		  infinite: true,
		  prevArrow: false,
		  nextArrow: false,
		  adapativeHeight: true,
		  rows: 0,
		  mobileFirst: true,
		  responsive: [
			  {
				  breakpoint: 200,
				  settings: {
					  slidesToShow: 1,
					  slidesToScroll: 1,
					  dots: false,
					  variableWidth: false,
				  }
			  },
			  {
				  breakpoint: 820,
				  settings: {
					  slidesToShow: 3,
					  slidesToScroll: 3,
					  dots: false,
					  variableWidth: false,
				  }
			  },
			  {
				  breakpoint: 1200,
				  settings: {
					  slidesToShow: 4,
					  slidesToScroll: 4,
					  dots: true,
					  variableWidth: false,
				  }
			  }
		  ]
	  });

	  // Top Winners Slider
	  $topWinnersSlider.slick({
		  lazyLoad: 'ondemand',
		  slidesToShow: 1,
		  slidesToScroll: 1,
		  autoplay: true,
		  autoplaySpeed: 2000,
		  dots: false,
		  rows: 0,
		  mobileFirst: true,
		  infinite: true,
	  });

	  // Winners Slider
	  $winnersSlider.slick({
		  lazyLoad: 'ondemand',
		  slidesToShow: 1,
		  slidesToScroll: 1,
		  autoplay: true,
		  autoplaySpeed: 2000,
		  dots: true,
		  rows: 0,
		  prevArrow: false,
		  nextArrow: false,
		  centerMode: true,
		  mobileFirst: true,
		  infinite: true,
		  responsive: [
			  {
				  breakpoint: 500,
				  settings: {
					  slidesToShow: 2,
					  centerMode: false,
					  slidesToScroll: 1,
					  dots: true
				  }
			  },
			  {
				  breakpoint: 768,
				  settings: {
					  slidesToShow: 3,
					  centerMode: false,
					  slidesToScroll: 1,
					  dots: true
				  }
			  },
			  {
				  breakpoint: 992,
				  settings: {
					  slidesToShow: 4,
					  centerMode: false,
					  slidesToScroll: 1,
					  dots: true
				  }
			  }
		  ]
	  });

	  $winnersSliderTabs.find('a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
		  $winnersSlider.slick('unslick');
		  var $target = $(this).attr('href');
		  $($target).find('.winners-slider').slick('init');
	  });

	  $competitionSlider.slick({
		  lazyLoad: 'ondemand',
		  slidesToShow: 1,
		  slidesToScroll: 1,
		  rows: 0,
		  dots: true,
		  autoplay: true,
		  autoplaySpeed: 5000,
		  adaptiveHeight: true,
		  infinite: true,
		  asNavFor: $competitionNav,
		  appendDots: $competitionIndicators,
		  appendArrows: $competitionArrows,
		  prevArrow: '<button type="button" class="slick-prev"><svg><use xlink:href="#slider-white-arrow"></use></svg></button>',
		  nextArrow: '<button type="button" class="slick-next"><svg><use xlink:href="#slider-white-arrow"></use></svg></button>',
		  customPaging: function (slider, i) {
			  var thumb = $(slider.$slides[i]).data();
			  return '<a>' + (i + 1) + '</a>';
		  },
	  });

	  $competitionNav.slick({
		  lazyLoad: 'ondemand',
		  slidesToShow: 3,
		  slidesToScroll: 1,
		  infinite: true,
		  dots: false,
		  centerMode: true,
		  autoplaySpeed: 5000,
		  focusOnSelect: true,
		  asNavFor: $competitionSlider,
		  mobileFirst: true,
		  prevArrow: '<button type="button" class="slick-prev"><svg><use xlink:href="#slider-white-arrow-dark"></use></svg></button>',
		  nextArrow: '<button type="button" class="slick-next"><svg><use xlink:href="#slider-white-arrow-dark"></use></svg></button>',
		  responsive: [
			  {
				  breakpoint: 992,
				  settings: {
					  slidesToShow: 5,
					  centerMode: false,
					  slidesToScroll: 1,
					  dots: true
				  }
			  }
		  ]
	  });
  });


  /* ---------------------------------------------------------------------------------------------------------------------
  ACCOUNT DROPDOWN JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(function ($) {
	  $(window).click(function(e) {
		  var $target = $(e.target),
			  $accountMenu = $('.account-menu');
		  if ($target.hasClass('account-display-name')) {
			  $accountMenu.toggleClass('open');
		  } else {
			  if ($accountMenu.has(e.target).length === 0) {
				  $accountMenu.removeClass('open');
			  }
		  }
	  });
  });
  /* ---------------------------------------------------------------------------------------------------------------------
  SLICK SLIDERS JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(function ($) {

	  var $competitionCarousel = $('#competition-carousel');
	  if($competitionCarousel.length !== 1) return;

		var $pswp = $('.pswp')[0];
		var image = [];

	  $competitionCarousel.each(function() {
		  var $pic     = $(this),
			  getItems = function() {
				  var items = [];
				  $('#competition-carousel-nav img').each(function() {
					  var $href   = '/firefly/file/img?id='+$(this).data('src')+'&w=1500&h=1000',
						  $size   = $(this).data('size').split('x'),
						  $width  = $size[0],
						  $height = $size[1];

					  var item = {
						  src : $href,
						  w   : $width,
						  h   : $height
					  };

					  items.push(item);
				  });
				  return items;
			  };

		  var items = getItems();
		  $.each(items, function(index, value) {
			  image[index]     = new Image();
			  image[index].src = value['src'];
		  });

		  $pic.on('click', 'figure', function(event) {
			  event.preventDefault();
			  var $index = $(this).index();
			  var options = {
				  index: $index,
				  bgOpacity: .8,
				  showHideOpacity: true,
				  timeToIdle: 10000,
				  zoomEl: true,
				  maxSpreadZoom: 1
			  };
			  console.log(items, options);
			  var lightBox = new PhotoSwipe($pswp, PhotoSwipeUI_Default, items, options);
			  lightBox.init();
		  });
	  });
  });

  /* ---------------------------------------------------------------------------------------------------------------------
  COMPETITION AJAX FILTERING JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(function ($) {
	  var $competitionsFilter = $('#competitions-filter'),
		  $ajaxResults = $('#ajax_results'),
		  $page, $category;

	  if ($competitionsFilter.length === 0 || $ajaxResults.length === 0) return;

	  function find_page_number(element) {
		  element.find('span').remove();
		  return parseInt(element.html());
	  }

	  $(document).on('click', '#competitions-filter a, .pagination a, .woocommerce-pagination a', function(e) {
		  e.preventDefault();
		  if ($(this).hasClass('page-link') || $(this).hasClass('page-numbers')) {
			  if($(this).hasClass('next') || $(this).hasClass('prev')) {
				  $page = $(this).attr('href').replace(/\D/g, "");
			  } else {
				  $page = find_page_number($(this).clone());
			  }
			  $category = $competitionsFilter.find('a.active').data('cat');
		  } else {
			  $category = $(this).data('cat');
			  $page = 1;
		  }

		  $.ajax({
			  url: competitions_ajax_filter.ajaxurl,
			  type: 'POST',
			  dataType: 'json',
			  data: {
				  action: 'competitions_filter',
				  page: $page,
				  category: $category,
				  type: competitions_ajax_filter.post_type
			  },
			  beforeSend: function() {
				  $ajaxResults.css('height', '50vh');
				  $('body, html').animate({
					  scrollTop: $ajaxResults.offset().top - $competitionsFilter.outerHeight()
				  }, 500);
				 $ajaxResults.empty().append('<div id="loader"></div>');
			  },
			  success: function(html) {
				  setTimeout(function() {
					  $ajaxResults.find('#loader').remove();
					  $ajaxResults.css('height', "");
					  $ajaxResults.append(html);
				  }, 600);
			  }
		  })
	  });
  });
  /* ---------------------------------------------------------------------------------------------------------------------
  PAST COMPETITIONS AJAX JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(function ($) {
	  var $pastCompetitions = $('#past_competitions');
	  if ($pastCompetitions.length === 0) return;

	  var limit = $pastCompetitions.data('limit'),
		  i = 1,
		  offset = limit * i,
		  scrollLoad = true;

	  $(window).on('scroll', function(e) {
		  e.preventDefault();

		  if (scrollLoad && $(window).scrollTop() + $(window).height() >= $pastCompetitions.offset().top + $pastCompetitions.height()) {
			  scrollLoad = false;

			  $.ajax({
				  url: woocommerce_params.ajax_url,
				  type: 'POST',
				  dataType: 'json',
				  data: {
					  action: 'past_competitions',
					  offset: offset,
				  },
				  beforeSend: function() {

				  },
				  success: function(response) {
					  $pastCompetitions.find('ul.products').append(response);
					  offset = limit * i++;
					  scrollLoad = true;
				  }
			  })
		  }
	  });
  });
  /* ---------------------------------------------------------------------------------------------------------------------
  TOTAL RAISED JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(function($) {
	  var $total_raised = $('#competition-total-raised-progressbar');
	  if ($total_raised.length) {
		  var $total_raised_progress = $total_raised.data('progress') / 100;
		  if ($total_raised_progress > 1) $total_raised_progress = 1;
		  var $total_raised_bar = new ProgressBar.Circle('#competition-total-raised-progressbar', {
			  strokeWidth: 3,
			  duration: 1000,
			  color: '#5200ac',
			  trailColor: '#878789',
			  trailWidth: 1,

		  });
		  $total_raised_bar.path.setAttribute('stroke-linecap', 'round');
		  $total_raised_bar.animate($total_raised_progress);
	  }
  });
  /* ---------------------------------------------------------------------------------------------------------------------
  TICKET COUNTER JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(ticketCounterPercentage());

  jQuery(window).resize(function() {
	  ticketCounterPercentage();
  });

  function ticketCounterPercentage() {
	  var $ = jQuery.noConflict();
	  var $ticketCounterProgressWrapper = $('.wc-comps-tickets-progress-wrapper');
	  if ($ticketCounterProgressWrapper.length === 0) return;

	  var $ticketCounterProgress = $ticketCounterProgressWrapper.find('.wc-comps-tickets-progress'),
		  $ticketPercentageSold = $ticketCounterProgress.find('.ticket-progress-percentage-sold'),
		  $progressBar = $ticketCounterProgress.find('.wc-comps-tickets-progress-bar'),
		  progress = parseInt($progressBar.attr('aria-valuenow'));

	  if (progress <= 10) {
		  $ticketPercentageSold
			  .css('left', progress + '%')
			  .css('left', '-=' + $ticketPercentageSold.width() / 2 + 'px')
			  .css('left', '+=' + $ticketCounterProgress.css('padding-left'));
	  } else if(progress > 10  && progress < 50) {
			  $ticketPercentageSold
				  .css('left', progress + '%')
				  .css('left', '-=' + $ticketPercentageSold.width() / 2 + 'px')
	  } else if(progress === 50) {
		  $ticketPercentageSold
			  .css('left', progress + '%')
			  .css('left', '-=' + $ticketPercentageSold.width() / 2 + 'px')
	  } else {
		  $ticketPercentageSold
			  .css('left', progress + '%')
			  .css('left', '-=' + $ticketPercentageSold.width() / 2 + 'px')
			  .css('left', '-=' + $ticketCounterProgress.css('padding-right'));
	  }
	  $ticketPercentageSold.css('visibility', 'visible');
  }

  /* ---------------------------------------------------------------------------------------------------------------------
  WOOCOMMERCE ENTRY LISTS JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(function ($) {
	  var $entryListTable = $('.wc-comps-product-entry-list-table');
	  if ($entryListTable.length === 0) return;
	  $entryListTable.floatThead({
		  position: 'absolute',
	  });
  });
  /* ---------------------------------------------------------------------------------------------------------------------
  REFER FRIENDS JS
  --------------------------------------------------------------------------------------------------------------------- */
  (function($) {
	  var $rf_modal = $('#rf-modal');
	  if ($rf_modal.length === 0) return;

	  if (getCookie('rf_modal') !== 'hidden') {
		  setTimeout(function () {
			  $rf_modal.modal('show');
		  }, 1500);
		  $rf_modal.on('hidden.bs.modal', function () {
			  setCookie('rf_modal', 'hidden', 365);
		  });
		  $rf_modal.find('.close').on('click', function() {
			  setCookie('rf_modal', 'hidden', 365);
		  });
	  } else {
		  $rf_modal.hide();
	  }
  })(jQuery);
  /* ---------------------------------------------------------------------------------------------------------------------
  SOCIAL SHARING JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(function ($) {
	  var fbShareBtn = $('#shareBtn'),
		  fbMessageBtn = $('#messageBtn');

	  fbShareBtn.on('click', function() {
		  var url = $(this).data('url');
		  FB.ui({
			  display: 'popup',
			  method: 'share',
			  href: url,
		  });
	  });

	  fbMessageBtn.on('click', function() {
		  var url = $(this).data('url');
		  FB.ui({
			  method: 'send',
			  link: url,
		  });
	  });

	  window.twttr = (function (d, s, id) {
		  var js, fjs = d.getElementsByTagName(s)[0],
			  t = window.twttr || {};
		  if (d.getElementById(id)) return t;
		  js = d.createElement(s);
		  js.id = id;
		  js.src = "https://platform.twitter.com/widgets.js";
		  fjs.parentNode.insertBefore(js, fjs);
		  t._e = [];
		  t.ready = function (f) {
			  t._e.push(f);
		  };
		  return t;
	  } (document, "script", "twitter-wjs"));
  });
  /* ---------------------------------------------------------------------------------------------------------------------
  DREAM POINTS MODAL JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(function ($) {
	  var $dp_modal = $('#dp-modal');
	  if ($dp_modal.length === 0) return;
	  if (getCookie('dp_modal') !== 'hidden') {
		  setTimeout(function() {
			  $dp_modal.modal('show');
		  },1500);
		  $dp_modal.on('hidden.bs.modal', function () {
			  setCookie('dp_modal', 'hidden', 365);
		  });
		  $('.modal-text-btn').on('click', function() {
			  setCookie('dp_modal', 'hidden', 365);
		  });
	  } else {
		  $dp_modal.hide();
	  }
  });

  /* ---------------------------------------------------------------------------------------------------------------------
  DREAM POINTS POPOUT JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(function ($) {
	  $(window).click(function(e) {
		  var $target = $(e.target),
			  $dreamPointsPopout = $('#dream_points_popout');
		  if ($target.hasClass('dream-points__button-icon')) {
			  $dreamPointsPopout.toggleClass('active');
			  e.preventDefault();
		  } else {
			  if ($dreamPointsPopout.has(e.target).length === 0) {
				  $dreamPointsPopout.removeClass('active');
			  }
		  }
	  });
  });

  /* ---------------------------------------------------------------------------------------------------------------------
  MAILCHIMP NEWSLETTER SIGNUP JS
  --------------------------------------------------------------------------------------------------------------------- */
  jQuery(document).ready(function ($) {
	  $('.newsletter-signup').on('blur', function () {
		  $('#mc4wp-form-1 span').removeClass('active');
	  }).on('focus', function () {
		  $('#mc4wp-form-1 span').addClass('active');
	  });
  });
  /* ---------------------------------------------------------------------------------------------------------------------
  COOKIES JS
  --------------------------------------------------------------------------------------------------------------------- */
  function setCookie(cname, cvalue, exdays) {
	  var d = new Date();
	  d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
	  var expires = "expires=" + d.toUTCString();
	  document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }

  function getCookie(cname) {
	  var name = cname + "=";
	  var ca = document.cookie.split(';');
	  for (var i = 0; i < ca.length; i++) {
		  var c = ca[i];
		  while (c.charAt(0) === ' ') {
			  c = c.substring(1);
		  }
		  if (c.indexOf(name) === 0) {
			  return c.substring(name.length, c.length);
		  }
	  }
	  return "";
  }



/* ---------------------------------------------------------------------------------------------------------------------
COMPETITION DRAW COUNTDOWN TIMER
--------------------------------------------------------------------------------------------------------------------- */


jQuery(document).ready(function ($) {
	var drawCountdownTimers = Array.from(document.getElementsByClassName('draw-countdown-timer'));
	if (drawCountdownTimers.length > 0) {
		const drawCountdownFunction = function(countdownTimers) {
			for (var idx=0; idx<drawCountdownTimers.length; idx++) {
				var drawTimerSpan = drawCountdownTimers[idx];
				var devDateNow = drawTimerSpan.getAttribute('data-dev-date-now');
				var nowTimestamp;
				if (devDateNow) {
					var realNow = new Date();
					var devDateParts = devDateNow.split('-');
					var nowDevDate = new Date(devDateParts[0], devDateParts[1]-1, devDateParts[2], realNow.getHours(), realNow.getMinutes(), realNow.getSeconds());
					nowTimestampSecs = Math.round(nowDevDate.getTime()/1000);
				}
				else {
					nowTimestampSecs = Math.round(Date.now()/1000);
				}
				var drawTimestampSecs = parseInt(drawTimerSpan.getAttribute('data-draw-timestamp'));
				if (drawTimestampSecs) {
					var remainingSecs = drawTimestampSecs - nowTimestampSecs;
					if (remainingSecs > 86400) {
						// it's kinda dumb to be updating this every minute ... but it's cheap anyway
						var days = Math.floor(remainingSecs/86400);
						drawTimerSpan.innerHTML = '+'+days+ 'D';
					}
					else if (remainingSecs > 3600) {
						var hours = Math.floor(remainingSecs/3600);
						drawTimerSpan.innerHTML = '+'+hours+'H';
					}
					else if (remainingSecs > 60) {
						var mins = Math.floor(remainingSecs/60);
						drawTimerSpan.innerHTML = '+'+mins+'m';
					}
					else if (remainingSecs > 0) {
						drawTimerSpan.innerHTML = '<1m';
					}
					else {
						drawTimerSpan.innerHTML = '<1m';// asked to do this rather than '0' for now
					}
				}
			}
		}

		drawCountdownFunction();
		setInterval(function() {
			drawCountdownFunction(drawCountdownTimers)
		},60000);
	}
});


/* ---------------------------------------------------------------------------------------------------------------------
CONTENT IFRAME RESIZER
--------------------------------------------------------------------------------------------------------------------- */

jQuery(document).ready(function ($) {
	// assumes aspect ratio of 16:9 (standard youtube)
	var iframe = $('.entry-content iframe');
	if (iframe.length>0) {
		iframe.height(Math.floor(iframe.width() * 9 / 16));
		$(window).on('resize',function () {
			iframe.height(Math.floor(iframe.width() * 9 / 16));
		});
	}
});
